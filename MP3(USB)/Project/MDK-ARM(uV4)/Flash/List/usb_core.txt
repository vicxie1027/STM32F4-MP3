; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_core.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usb_core.crf ..\..\Libraries\STM32_USB_OTG_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;322    */
;;;323    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;326      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;327      USB_OTG_GCCFG_TypeDef    gccfg;
;;;328      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;329      
;;;330      usbcfg.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;331      gccfg.d32 = 0;
00000a  9001              STR      r0,[sp,#4]
;;;332      ahbcfg.d32 = 0;
00000c  9000              STR      r0,[sp,#0]
;;;333      
;;;334      
;;;335      
;;;336      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00000e  7a20              LDRB     r0,[r4,#8]
000010  2801              CMP      r0,#1
000012  d143              BNE      |L1.156|
;;;337      {
;;;338        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
000014  68e0              LDR      r0,[r4,#0xc]
000016  6b80              LDR      r0,[r0,#0x38]
000018  9001              STR      r0,[sp,#4]
;;;339        gccfg.b.pwdn = 0;
00001a  9801              LDR      r0,[sp,#4]
00001c  f4203080          BIC      r0,r0,#0x10000
000020  9001              STR      r0,[sp,#4]
;;;340        
;;;341        if (pdev->cfg.Sof_output)
000022  7a60              LDRB     r0,[r4,#9]
000024  b128              CBZ      r0,|L1.50|
;;;342        {
;;;343          gccfg.b.sofouten = 1;   
000026  9801              LDR      r0,[sp,#4]
000028  f4201080          BIC      r0,r0,#0x100000
00002c  f5001080          ADD      r0,r0,#0x100000
000030  9001              STR      r0,[sp,#4]
                  |L1.50|
;;;344        }
;;;345        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000032  9801              LDR      r0,[sp,#4]
000034  68e1              LDR      r1,[r4,#0xc]
000036  6388              STR      r0,[r1,#0x38]
;;;346        
;;;347        /* Init The ULPI Interface */
;;;348        usbcfg.d32 = 0;
000038  2000              MOVS     r0,#0
00003a  9002              STR      r0,[sp,#8]
;;;349        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  68c0              LDR      r0,[r0,#0xc]
000040  9002              STR      r0,[sp,#8]
;;;350        
;;;351        usbcfg.b.physel            = 0; /* HS Interface */
000042  9802              LDR      r0,[sp,#8]
000044  f0200040          BIC      r0,r0,#0x40
000048  9002              STR      r0,[sp,#8]
;;;352    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;353        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;354    #else
;;;355    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;356        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
00004a  9802              LDR      r0,[sp,#8]
00004c  f4201080          BIC      r0,r0,#0x100000
000050  f5001080          ADD      r0,r0,#0x100000
000054  9002              STR      r0,[sp,#8]
;;;357    #endif
;;;358    #endif 
;;;359        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
000056  9802              LDR      r0,[sp,#8]
000058  f4200080          BIC      r0,r0,#0x400000
00005c  9002              STR      r0,[sp,#8]
;;;360        
;;;361        usbcfg.b.ulpi_fsls = 0;
00005e  9802              LDR      r0,[sp,#8]
000060  f4203000          BIC      r0,r0,#0x20000
000064  9002              STR      r0,[sp,#8]
;;;362        usbcfg.b.ulpi_clk_sus_m = 0;
000066  9802              LDR      r0,[sp,#8]
000068  f4202000          BIC      r0,r0,#0x80000
00006c  9002              STR      r0,[sp,#8]
;;;363        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00006e  9802              LDR      r0,[sp,#8]
000070  68e1              LDR      r1,[r4,#0xc]
000072  60c8              STR      r0,[r1,#0xc]
;;;364        
;;;365        /* Reset after a PHY select  */
;;;366        USB_OTG_CoreReset(pdev);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USB_OTG_CoreReset
;;;367        
;;;368        if(pdev->cfg.dma_enable == 1)
00007a  78e0              LDRB     r0,[r4,#3]
00007c  2801              CMP      r0,#1
00007e  d143              BNE      |L1.264|
;;;369        {
;;;370          
;;;371          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000080  9800              LDR      r0,[sp,#0]
000082  f020001e          BIC      r0,r0,#0x1e
000086  300a              ADDS     r0,r0,#0xa
000088  9000              STR      r0,[sp,#0]
;;;372          ahbcfg.b.dmaenable = 1;
00008a  9800              LDR      r0,[sp,#0]
00008c  f0200020          BIC      r0,r0,#0x20
000090  3020              ADDS     r0,r0,#0x20
000092  9000              STR      r0,[sp,#0]
;;;373          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
000094  9800              LDR      r0,[sp,#0]
000096  68e1              LDR      r1,[r4,#0xc]
000098  6088              STR      r0,[r1,#8]
00009a  e035              B        |L1.264|
                  |L1.156|
;;;374          
;;;375        }    
;;;376      }
;;;377      else /* FS interface (embedded Phy) */
;;;378      {
;;;379        
;;;380        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
00009c  68e0              LDR      r0,[r4,#0xc]
00009e  68c0              LDR      r0,[r0,#0xc]
0000a0  9002              STR      r0,[sp,#8]
;;;381        usbcfg.b.physel  = 1; /* FS Interface */
0000a2  9802              LDR      r0,[sp,#8]
0000a4  f0200040          BIC      r0,r0,#0x40
0000a8  3040              ADDS     r0,r0,#0x40
0000aa  9002              STR      r0,[sp,#8]
;;;382        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
0000ac  9802              LDR      r0,[sp,#8]
0000ae  68e1              LDR      r1,[r4,#0xc]
0000b0  60c8              STR      r0,[r1,#0xc]
;;;383        /* Reset after a PHY select and set Host mode */
;;;384        USB_OTG_CoreReset(pdev);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       USB_OTG_CoreReset
;;;385        /* Deactivate the power down*/
;;;386        gccfg.d32 = 0;
0000b8  2000              MOVS     r0,#0
0000ba  9001              STR      r0,[sp,#4]
;;;387        gccfg.b.pwdn = 1;
0000bc  9801              LDR      r0,[sp,#4]
0000be  f4203080          BIC      r0,r0,#0x10000
0000c2  f5003080          ADD      r0,r0,#0x10000
0000c6  9001              STR      r0,[sp,#4]
;;;388        
;;;389        gccfg.b.vbussensingA = 1 ;
0000c8  9801              LDR      r0,[sp,#4]
0000ca  f4202080          BIC      r0,r0,#0x40000
0000ce  f5002080          ADD      r0,r0,#0x40000
0000d2  9001              STR      r0,[sp,#4]
;;;390        gccfg.b.vbussensingB = 1 ;     
0000d4  9801              LDR      r0,[sp,#4]
0000d6  f4202000          BIC      r0,r0,#0x80000
0000da  f5002000          ADD      r0,r0,#0x80000
0000de  9001              STR      r0,[sp,#4]
;;;391    #ifndef VBUS_SENSING_ENABLED
;;;392        gccfg.b.disablevbussensing = 1; 
0000e0  9801              LDR      r0,[sp,#4]
0000e2  f4201000          BIC      r0,r0,#0x200000
0000e6  f5001000          ADD      r0,r0,#0x200000
0000ea  9001              STR      r0,[sp,#4]
;;;393    #endif    
;;;394        
;;;395        if(pdev->cfg.Sof_output)
0000ec  7a60              LDRB     r0,[r4,#9]
0000ee  b128              CBZ      r0,|L1.252|
;;;396        {
;;;397          gccfg.b.sofouten = 1;  
0000f0  9801              LDR      r0,[sp,#4]
0000f2  f4201080          BIC      r0,r0,#0x100000
0000f6  f5001080          ADD      r0,r0,#0x100000
0000fa  9001              STR      r0,[sp,#4]
                  |L1.252|
;;;398        }
;;;399        
;;;400        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
0000fc  9801              LDR      r0,[sp,#4]
0000fe  68e1              LDR      r1,[r4,#0xc]
000100  6388              STR      r0,[r1,#0x38]
;;;401        USB_OTG_BSP_mDelay(20);
000102  2014              MOVS     r0,#0x14
000104  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L1.264|
;;;402      }
;;;403      /* case the HS core is working in FS mode */
;;;404      if(pdev->cfg.dma_enable == 1)
000108  78e0              LDRB     r0,[r4,#3]
00010a  2801              CMP      r0,#1
00010c  d10f              BNE      |L1.302|
;;;405      {
;;;406        
;;;407        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
00010e  68e0              LDR      r0,[r4,#0xc]
000110  6880              LDR      r0,[r0,#8]
000112  9000              STR      r0,[sp,#0]
;;;408        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000114  9800              LDR      r0,[sp,#0]
000116  f020001e          BIC      r0,r0,#0x1e
00011a  300a              ADDS     r0,r0,#0xa
00011c  9000              STR      r0,[sp,#0]
;;;409        ahbcfg.b.dmaenable = 1;
00011e  9800              LDR      r0,[sp,#0]
000120  f0200020          BIC      r0,r0,#0x20
000124  3020              ADDS     r0,r0,#0x20
000126  9000              STR      r0,[sp,#0]
;;;410        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
000128  9800              LDR      r0,[sp,#0]
00012a  68e1              LDR      r1,[r4,#0xc]
00012c  6088              STR      r0,[r1,#8]
                  |L1.302|
;;;411        
;;;412      }
;;;413      /* initialize OTG features */
;;;414    #ifdef  USE_OTG_MODE
;;;415      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;416      usbcfg.b.hnpcap = 1;
;;;417      usbcfg.b.srpcap = 1;
;;;418      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;419      USB_OTG_EnableCommonInt(pdev);
;;;420    #endif
;;;421      return status;
00012e  4628              MOV      r0,r5
;;;422    }
000130  bd3e              POP      {r1-r5,pc}
;;;423    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitHost PROC
;;;611    */
;;;612    USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
000000  b5fe              PUSH     {r1-r7,lr}
;;;613    {
000002  4604              MOV      r4,r0
;;;614      USB_OTG_STS                     status = USB_OTG_OK;
000004  2600              MOVS     r6,#0
;;;615      USB_OTG_FSIZ_TypeDef            nptxfifosize;
;;;616      USB_OTG_FSIZ_TypeDef            ptxfifosize;  
;;;617      USB_OTG_HCFG_TypeDef            hcfg;
;;;618      
;;;619    #ifdef USE_OTG_MODE
;;;620      USB_OTG_OTGCTL_TypeDef          gotgctl;
;;;621    #endif
;;;622      
;;;623      uint32_t                        i = 0;
000006  2500              MOVS     r5,#0
;;;624      
;;;625      nptxfifosize.d32 = 0;  
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;626      ptxfifosize.d32 = 0;
00000c  9001              STR      r0,[sp,#4]
;;;627    #ifdef USE_OTG_MODE
;;;628      gotgctl.d32 = 0;
;;;629    #endif
;;;630      hcfg.d32 = 0;
00000e  9000              STR      r0,[sp,#0]
;;;631      
;;;632      
;;;633      /* configure charge pump IO */
;;;634      USB_OTG_BSP_ConfigVBUS(pdev);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;635      
;;;636      /* Restart the Phy Clock */
;;;637      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000016  2100              MOVS     r1,#0
000018  f8d4010c          LDR      r0,[r4,#0x10c]
00001c  6001              STR      r1,[r0,#0]
;;;638      
;;;639      /* Initialize Host Configuration Register */
;;;640      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00001e  7a20              LDRB     r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d103              BNE      |L2.44|
;;;641      {
;;;642        USB_OTG_InitFSLSPClkSel(pdev , HCFG_30_60_MHZ); 
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
00002a  e003              B        |L2.52|
                  |L2.44|
;;;643      }
;;;644      else
;;;645      {
;;;646        USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
                  |L2.52|
;;;647      }
;;;648      USB_OTG_ResetPort(pdev);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       USB_OTG_ResetPort
;;;649      
;;;650      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
00003a  6960              LDR      r0,[r4,#0x14]
00003c  6800              LDR      r0,[r0,#0]
00003e  9000              STR      r0,[sp,#0]
;;;651      hcfg.b.fslssupp = 0;
000040  9800              LDR      r0,[sp,#0]
000042  f0200004          BIC      r0,r0,#4
000046  9000              STR      r0,[sp,#0]
;;;652      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000048  9900              LDR      r1,[sp,#0]
00004a  6960              LDR      r0,[r4,#0x14]
00004c  6001              STR      r1,[r0,#0]
;;;653      
;;;654      /* Configure data FIFO sizes */
;;;655      /* Rx FIFO */
;;;656    #ifdef USB_OTG_FS_CORE
;;;657      if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
;;;658      {
;;;659        /* set Rx FIFO size */
;;;660        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
;;;661        nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
;;;662        nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
;;;663        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
;;;664        
;;;665        ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
;;;666        ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
;;;667        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
;;;668      }
;;;669    #endif
;;;670    #ifdef USB_OTG_HS_CORE  
;;;671      if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
00004e  7ae0              LDRB     r0,[r4,#0xb]
000050  bb00              CBNZ     r0,|L2.148|
;;;672      {
;;;673        /* set Rx FIFO size */
;;;674        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
000052  f44f7000          MOV      r0,#0x200
000056  68e1              LDR      r1,[r4,#0xc]
000058  6248              STR      r0,[r1,#0x24]
;;;675        nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
00005a  9802              LDR      r0,[sp,#8]
00005c  f36f000f          BFC      r0,#0,#16
000060  f5007000          ADD      r0,r0,#0x200
000064  9002              STR      r0,[sp,#8]
;;;676        nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
000066  9802              LDR      r0,[sp,#8]
000068  b280              UXTH     r0,r0
00006a  f1007080          ADD      r0,r0,#0x1000000
00006e  9002              STR      r0,[sp,#8]
;;;677        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
000070  9802              LDR      r0,[sp,#8]
000072  68e1              LDR      r1,[r4,#0xc]
000074  6288              STR      r0,[r1,#0x28]
;;;678        
;;;679        ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
000076  9801              LDR      r0,[sp,#4]
000078  f36f000f          BFC      r0,#0,#16
00007c  f5007040          ADD      r0,r0,#0x300
000080  9001              STR      r0,[sp,#4]
;;;680        ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
000082  9801              LDR      r0,[sp,#4]
000084  b280              UXTH     r0,r0
000086  f1007080          ADD      r0,r0,#0x1000000
00008a  9001              STR      r0,[sp,#4]
;;;681        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
00008c  9801              LDR      r0,[sp,#4]
00008e  68e1              LDR      r1,[r4,#0xc]
000090  f8c10100          STR      r0,[r1,#0x100]
                  |L2.148|
;;;682      }
;;;683    #endif  
;;;684      
;;;685    #ifdef USE_OTG_MODE
;;;686      /* Clear Host Set HNP Enable in the USB_OTG Control Register */
;;;687      gotgctl.b.hstsethnpen = 1;
;;;688      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
;;;689    #endif
;;;690      
;;;691      /* Make sure the FIFOs are flushed. */
;;;692      USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
000094  2110              MOVS     r1,#0x10
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;693      USB_OTG_FlushRxFifo(pdev);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;694      
;;;695      
;;;696      /* Clear all pending HC Interrupts */
;;;697      for (i = 0; i < pdev->cfg.host_channels; i++)
0000a2  2500              MOVS     r5,#0
0000a4  e00d              B        |L2.194|
                  |L2.166|
;;;698      {
;;;699        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
0000a6  f04f31ff          MOV      r1,#0xffffffff
0000aa  f1040090          ADD      r0,r4,#0x90
0000ae  f8500025          LDR      r0,[r0,r5,LSL #2]
0000b2  6081              STR      r1,[r0,#8]
;;;700        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
0000b4  2100              MOVS     r1,#0
0000b6  f1040090          ADD      r0,r4,#0x90
0000ba  f8500025          LDR      r0,[r0,r5,LSL #2]
0000be  60c1              STR      r1,[r0,#0xc]
0000c0  1c6d              ADDS     r5,r5,#1              ;697
                  |L2.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;697
0000c4  42a8              CMP      r0,r5                 ;697
0000c6  d8ee              BHI      |L2.166|
;;;701      }
;;;702    #ifndef USE_OTG_MODE
;;;703      USB_OTG_DriveVbus(pdev, 1);
0000c8  2101              MOVS     r1,#1
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       USB_OTG_DriveVbus
;;;704    #endif
;;;705      
;;;706      USB_OTG_EnableHostInt(pdev);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       USB_OTG_EnableHostInt
;;;707      return status;
0000d6  4630              MOV      r0,r6
;;;708    }
0000d8  bdfe              POP      {r1-r7,pc}
;;;709    
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;122    */
;;;123    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125      USB_OTG_STS status = USB_OTG_OK;
000004  2600              MOVS     r6,#0
;;;126      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;127      uint32_t count = 0;
000006  2500              MOVS     r5,#0
;;;128      
;;;129      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;130      /* Wait for AHB master IDLE state. */
;;;131      do
00000c  bf00              NOP      
                  |L3.14|
;;;132      {
;;;133        USB_OTG_BSP_uDelay(3);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;134        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
000014  68e0              LDR      r0,[r4,#0xc]
000016  6900              LDR      r0,[r0,#0x10]
000018  9000              STR      r0,[sp,#0]
;;;135        if (++count > 200000)
00001a  1c68              ADDS     r0,r5,#1
00001c  4605              MOV      r5,r0
00001e  4913              LDR      r1,|L3.108|
000020  4288              CMP      r0,r1
000022  d901              BLS      |L3.40|
;;;136        {
;;;137          return USB_OTG_OK;
000024  2000              MOVS     r0,#0
                  |L3.38|
;;;138        }
;;;139      }
;;;140      while (greset.b.ahbidle == 0);
;;;141      /* Core Soft Reset */
;;;142      count = 0;
;;;143      greset.b.csftrst = 1;
;;;144      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;145      do
;;;146      {
;;;147        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;148        if (++count > 200000)
;;;149        {
;;;150          break;
;;;151        }
;;;152      }
;;;153      while (greset.b.csftrst == 1);
;;;154      /* Wait for 3 PHY Clocks*/
;;;155      USB_OTG_BSP_uDelay(3);
;;;156      return status;
;;;157    }
000026  bdf8              POP      {r3-r7,pc}
                  |L3.40|
000028  9800              LDR      r0,[sp,#0]            ;140
00002a  0fc0              LSRS     r0,r0,#31             ;140
00002c  2800              CMP      r0,#0                 ;140
00002e  d0ee              BEQ      |L3.14|
000030  2500              MOVS     r5,#0                 ;142
000032  9800              LDR      r0,[sp,#0]            ;143
000034  f0200001          BIC      r0,r0,#1              ;143
000038  1c40              ADDS     r0,r0,#1              ;143
00003a  9000              STR      r0,[sp,#0]            ;143
00003c  9800              LDR      r0,[sp,#0]            ;144
00003e  68e1              LDR      r1,[r4,#0xc]          ;144
000040  6108              STR      r0,[r1,#0x10]         ;144
000042  bf00              NOP                            ;145
                  |L3.68|
000044  68e0              LDR      r0,[r4,#0xc]          ;147
000046  6900              LDR      r0,[r0,#0x10]         ;147
000048  9000              STR      r0,[sp,#0]            ;147
00004a  1c68              ADDS     r0,r5,#1              ;148
00004c  4605              MOV      r5,r0                 ;148
00004e  4907              LDR      r1,|L3.108|
000050  4288              CMP      r0,r1                 ;148
000052  d900              BLS      |L3.86|
000054  e004              B        |L3.96|
                  |L3.86|
000056  9800              LDR      r0,[sp,#0]            ;153
000058  f0000001          AND      r0,r0,#1              ;153
00005c  2800              CMP      r0,#0                 ;153
00005e  d1f1              BNE      |L3.68|
                  |L3.96|
000060  bf00              NOP                            ;150
000062  2003              MOVS     r0,#3                 ;155
000064  f7fffffe          BL       USB_OTG_BSP_uDelay
000068  4630              MOV      r0,r6                 ;156
00006a  e7dc              B        |L3.38|
;;;158    
                          ENDP

                  |L3.108|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;446    */
;;;447    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;448    {
000002  4601              MOV      r1,r0
;;;449      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;450      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;451      ahbcfg.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;452      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
00000a  9a00              LDR      r2,[sp,#0]
00000c  f0220201          BIC      r2,r2,#1
000010  1c52              ADDS     r2,r2,#1
000012  9200              STR      r2,[sp,#0]
;;;453      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000014  68ca              LDR      r2,[r1,#0xc]
000016  6892              LDR      r2,[r2,#8]
000018  9b00              LDR      r3,[sp,#0]
00001a  439a              BICS     r2,r2,r3
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  609a              STR      r2,[r3,#8]
;;;454      return status;
;;;455    }
000020  bd08              POP      {r3,pc}
;;;456    
                          ENDP


                          AREA ||i.USB_OTG_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_OTG_DriveVbus PROC
;;;726    */
;;;727    void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  b538              PUSH     {r3-r5,lr}
;;;728    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;729      USB_OTG_HPRT0_TypeDef     hprt0;
;;;730      
;;;731      hprt0.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;732      
;;;733      /* enable disable the external charge pump */
;;;734      USB_OTG_BSP_DriveVBUS(pdev, state);
00000a  4621              MOV      r1,r4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;735      
;;;736      /* Turn on the Host port power. */
;;;737      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       USB_OTG_ReadHPRT0
000018  9000              STR      r0,[sp,#0]
;;;738      if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
00001a  9800              LDR      r0,[sp,#0]
00001c  f3c03000          UBFX     r0,r0,#12,#1
000020  b958              CBNZ     r0,|L5.58|
000022  2c01              CMP      r4,#1
000024  d109              BNE      |L5.58|
;;;739      {
;;;740        hprt0.b.prtpwr = 1;
000026  9800              LDR      r0,[sp,#0]
000028  f4205080          BIC      r0,r0,#0x1000
00002c  f5005080          ADD      r0,r0,#0x1000
000030  9000              STR      r0,[sp,#0]
;;;741        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000032  9900              LDR      r1,[sp,#0]
000034  f8d500cc          LDR      r0,[r5,#0xcc]
000038  6001              STR      r1,[r0,#0]
                  |L5.58|
;;;742      }
;;;743      if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
00003a  9800              LDR      r0,[sp,#0]
00003c  f3c03000          UBFX     r0,r0,#12,#1
000040  b140              CBZ      r0,|L5.84|
000042  b93c              CBNZ     r4,|L5.84|
;;;744      {
;;;745        hprt0.b.prtpwr = 0;
000044  9800              LDR      r0,[sp,#0]
000046  f4205080          BIC      r0,r0,#0x1000
00004a  9000              STR      r0,[sp,#0]
;;;746        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00004c  9900              LDR      r1,[sp,#0]
00004e  f8d500cc          LDR      r0,[r5,#0xcc]
000052  6001              STR      r1,[r0,#0]
                  |L5.84|
;;;747      }
;;;748      
;;;749      USB_OTG_BSP_mDelay(200);
000054  20c8              MOVS     r0,#0xc8
000056  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;750    }
00005a  bd38              POP      {r3-r5,pc}
;;;751    /**
                          ENDP


                          AREA ||i.USB_OTG_EnableCommonInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableCommonInt PROC
;;;94     */
;;;95     static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;96     {
;;;97       USB_OTG_GINTMSK_TypeDef  int_mask;
;;;98       
;;;99       int_mask.d32 = 0;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
;;;100      /* Clear any pending USB_OTG Interrupts */
;;;101    #ifndef USE_OTG_MODE
;;;102      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
000006  1e49              SUBS     r1,r1,#1
000008  68c2              LDR      r2,[r0,#0xc]
00000a  6051              STR      r1,[r2,#4]
;;;103    #endif
;;;104      /* Clear any pending interrupts */
;;;105      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
00000c  f06f4180          MVN      r1,#0x40000000
000010  68c2              LDR      r2,[r0,#0xc]
000012  6151              STR      r1,[r2,#0x14]
;;;106      /* Enable the interrupts in the INTMSK */
;;;107      int_mask.b.wkupintr = 1;
000014  9900              LDR      r1,[sp,#0]
000016  f0214100          BIC      r1,r1,#0x80000000
00001a  f1014100          ADD      r1,r1,#0x80000000
00001e  9100              STR      r1,[sp,#0]
;;;108      int_mask.b.usbsuspend = 1; 
000020  9900              LDR      r1,[sp,#0]
000022  f4216100          BIC      r1,r1,#0x800
000026  f5016100          ADD      r1,r1,#0x800
00002a  9100              STR      r1,[sp,#0]
;;;109      
;;;110    #ifdef USE_OTG_MODE
;;;111      int_mask.b.otgintr = 1;
;;;112      int_mask.b.sessreqintr = 1;
;;;113      int_mask.b.conidstschng = 1;
;;;114    #endif
;;;115      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
00002c  9900              LDR      r1,[sp,#0]
00002e  68c2              LDR      r2,[r0,#0xc]
000030  6191              STR      r1,[r2,#0x18]
;;;116    }
000032  bd08              POP      {r3,pc}
;;;117    
                          ENDP


                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;428    */
;;;429    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;430    {
000002  4601              MOV      r1,r0
;;;431      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;432      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;433      
;;;434      ahbcfg.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;435      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
00000a  9a00              LDR      r2,[sp,#0]
00000c  f0220201          BIC      r2,r2,#1
000010  1c52              ADDS     r2,r2,#1
000012  9200              STR      r2,[sp,#0]
;;;436      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000014  68ca              LDR      r2,[r1,#0xc]
000016  6892              LDR      r2,[r2,#8]
000018  9b00              LDR      r3,[sp,#0]
00001a  431a              ORRS     r2,r2,r3
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  609a              STR      r2,[r3,#8]
;;;437      return status;
;;;438    }
000020  bd08              POP      {r3,pc}
;;;439    
                          ENDP


                          AREA ||i.USB_OTG_EnableHostInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableHostInt PROC
;;;755    */
;;;756    USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;757    {
000002  4604              MOV      r4,r0
;;;758      USB_OTG_STS       status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;759      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;760      intmsk.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;761      /* Disable all interrupts. */
;;;762      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  6188              STR      r0,[r1,#0x18]
;;;763      
;;;764      /* Clear any pending interrupts. */
;;;765      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
00000e  1e40              SUBS     r0,r0,#1
000010  68e1              LDR      r1,[r4,#0xc]
000012  6148              STR      r0,[r1,#0x14]
;;;766      
;;;767      /* Enable the common interrupts */
;;;768      USB_OTG_EnableCommonInt(pdev);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       USB_OTG_EnableCommonInt
;;;769      
;;;770      if (pdev->cfg.dma_enable == 0)
00001a  78e0              LDRB     r0,[r4,#3]
00001c  b920              CBNZ     r0,|L8.40|
;;;771      {  
;;;772        intmsk.b.rxstsqlvl  = 1;
00001e  9800              LDR      r0,[sp,#0]
000020  f0200010          BIC      r0,r0,#0x10
000024  3010              ADDS     r0,r0,#0x10
000026  9000              STR      r0,[sp,#0]
                  |L8.40|
;;;773      }  
;;;774      intmsk.b.portintr   = 1;
000028  9800              LDR      r0,[sp,#0]
00002a  f0207080          BIC      r0,r0,#0x1000000
00002e  f1007080          ADD      r0,r0,#0x1000000
000032  9000              STR      r0,[sp,#0]
;;;775      intmsk.b.hcintr     = 1;
000034  9800              LDR      r0,[sp,#0]
000036  f0207000          BIC      r0,r0,#0x2000000
00003a  f1007000          ADD      r0,r0,#0x2000000
00003e  9000              STR      r0,[sp,#0]
;;;776      intmsk.b.disconnect = 1;  
000040  9800              LDR      r0,[sp,#0]
000042  f0205000          BIC      r0,r0,#0x20000000
000046  f1005000          ADD      r0,r0,#0x20000000
00004a  9000              STR      r0,[sp,#0]
;;;777      intmsk.b.sofintr    = 1;  
00004c  9800              LDR      r0,[sp,#0]
00004e  f0200008          BIC      r0,r0,#8
000052  3008              ADDS     r0,r0,#8
000054  9000              STR      r0,[sp,#0]
;;;778      intmsk.b.incomplisoout  = 1; 
000056  9800              LDR      r0,[sp,#0]
000058  f4201000          BIC      r0,r0,#0x200000
00005c  f5001000          ADD      r0,r0,#0x200000
000060  9000              STR      r0,[sp,#0]
;;;779      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000062  68e0              LDR      r0,[r4,#0xc]
000064  6980              LDR      r0,[r0,#0x18]
000066  9900              LDR      r1,[sp,#0]
000068  4388              BICS     r0,r0,r1
00006a  4308              ORRS     r0,r0,r1
00006c  68e1              LDR      r1,[r4,#0xc]
00006e  6188              STR      r0,[r1,#0x18]
;;;780      return status;
000070  4628              MOV      r0,r5
;;;781    }
000072  bd38              POP      {r3-r5,pc}
;;;782    
                          ENDP


                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;493    */
;;;494    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b5f8              PUSH     {r3-r7,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;497      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;498      uint32_t count = 0;
000006  2600              MOVS     r6,#0
;;;499      
;;;500      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;501      greset.b.rxfflsh = 1;
00000c  9800              LDR      r0,[sp,#0]
00000e  f0200010          BIC      r0,r0,#0x10
000012  3010              ADDS     r0,r0,#0x10
000014  9000              STR      r0,[sp,#0]
;;;502      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000016  9800              LDR      r0,[sp,#0]
000018  68e1              LDR      r1,[r4,#0xc]
00001a  6108              STR      r0,[r1,#0x10]
;;;503      do
00001c  bf00              NOP      
                  |L9.30|
;;;504      {
;;;505        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
00001e  68e0              LDR      r0,[r4,#0xc]
000020  6900              LDR      r0,[r0,#0x10]
000022  9000              STR      r0,[sp,#0]
;;;506        if (++count > 200000)
000024  1c70              ADDS     r0,r6,#1
000026  4606              MOV      r6,r0
000028  4907              LDR      r1,|L9.72|
00002a  4288              CMP      r0,r1
00002c  d900              BLS      |L9.48|
;;;507        {
;;;508          break;
00002e  e004              B        |L9.58|
                  |L9.48|
;;;509        }
;;;510      }
;;;511      while (greset.b.rxfflsh == 1);
000030  9800              LDR      r0,[sp,#0]
000032  f3c01000          UBFX     r0,r0,#4,#1
000036  2800              CMP      r0,#0
000038  d1f1              BNE      |L9.30|
                  |L9.58|
00003a  bf00              NOP                            ;508
;;;512      /* Wait for 3 PHY Clocks*/
;;;513      USB_OTG_BSP_uDelay(3);
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;514      return status;
000042  4628              MOV      r0,r5
;;;515    }
000044  bdf8              POP      {r3-r7,pc}
;;;516    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;463    */
;;;464    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b5f8              PUSH     {r3-r7,lr}
;;;465    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;466      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;467      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;468      
;;;469      uint32_t count = 0;
000008  2700              MOVS     r7,#0
;;;470      greset.d32 = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;471      greset.b.txfflsh = 1;
00000e  9800              LDR      r0,[sp,#0]
000010  f0200020          BIC      r0,r0,#0x20
000014  3020              ADDS     r0,r0,#0x20
000016  9000              STR      r0,[sp,#0]
;;;472      greset.b.txfnum  = num;
000018  9800              LDR      r0,[sp,#0]
00001a  f365108a          BFI      r0,r5,#6,#5
00001e  9000              STR      r0,[sp,#0]
;;;473      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000020  9800              LDR      r0,[sp,#0]
000022  68e1              LDR      r1,[r4,#0xc]
000024  6108              STR      r0,[r1,#0x10]
;;;474      do
000026  bf00              NOP      
                  |L10.40|
;;;475      {
;;;476        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
000028  68e0              LDR      r0,[r4,#0xc]
00002a  6900              LDR      r0,[r0,#0x10]
00002c  9000              STR      r0,[sp,#0]
;;;477        if (++count > 200000)
00002e  1c78              ADDS     r0,r7,#1
000030  4607              MOV      r7,r0
000032  4907              LDR      r1,|L10.80|
000034  4288              CMP      r0,r1
000036  d900              BLS      |L10.58|
;;;478        {
;;;479          break;
000038  e004              B        |L10.68|
                  |L10.58|
;;;480        }
;;;481      }
;;;482      while (greset.b.txfflsh == 1);
00003a  9800              LDR      r0,[sp,#0]
00003c  f3c01040          UBFX     r0,r0,#5,#1
000040  2800              CMP      r0,#0
000042  d1f1              BNE      |L10.40|
                  |L10.68|
000044  bf00              NOP                            ;479
;;;483      /* Wait for 3 PHY Clocks*/
;;;484      USB_OTG_BSP_uDelay(3);
000046  2003              MOVS     r0,#3
000048  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;485      return status;
00004c  4630              MOV      r0,r6
;;;486    }
00004e  bdf8              POP      {r3-r7,pc}
;;;487    
                          ENDP

                  |L10.80|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;553    */
;;;554    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;555    {
;;;556      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  68c8              LDR      r0,[r1,#0xc]
000004  6940              LDR      r0,[r0,#0x14]
000006  f0000001          AND      r0,r0,#1
;;;557    }
00000a  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.USB_OTG_HC_DoPing||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_DoPing PROC
;;;1122   */
;;;1123   USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b51c              PUSH     {r2-r4,lr}
;;;1124   {
000002  4602              MOV      r2,r0
;;;1125     USB_OTG_STS               status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1126     USB_OTG_HCCHAR_TypeDef    hcchar;
;;;1127     USB_OTG_HCTSIZn_TypeDef   hctsiz;  
;;;1128     
;;;1129     hctsiz.d32 = 0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;1130     hctsiz.b.dopng = 1;
00000a  9b00              LDR      r3,[sp,#0]
00000c  f0234300          BIC      r3,r3,#0x80000000
000010  f1034300          ADD      r3,r3,#0x80000000
000014  9300              STR      r3,[sp,#0]
;;;1131     hctsiz.b.pktcnt = 1;
000016  2401              MOVS     r4,#1
000018  9b00              LDR      r3,[sp,#0]
00001a  f36443dc          BFI      r3,r4,#19,#10
00001e  9300              STR      r3,[sp,#0]
;;;1132     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000020  f1020390          ADD      r3,r2,#0x90
000024  f8533021          LDR      r3,[r3,r1,LSL #2]
000028  9c00              LDR      r4,[sp,#0]
00002a  611c              STR      r4,[r3,#0x10]
;;;1133     
;;;1134     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00002c  f1020390          ADD      r3,r2,#0x90
000030  f8533021          LDR      r3,[r3,r1,LSL #2]
000034  681b              LDR      r3,[r3,#0]
000036  9301              STR      r3,[sp,#4]
;;;1135     hcchar.b.chen = 1;
000038  9b01              LDR      r3,[sp,#4]
00003a  f0234300          BIC      r3,r3,#0x80000000
00003e  f1034300          ADD      r3,r3,#0x80000000
000042  9301              STR      r3,[sp,#4]
;;;1136     hcchar.b.chdis = 0;
000044  9b01              LDR      r3,[sp,#4]
000046  f0234380          BIC      r3,r3,#0x40000000
00004a  9301              STR      r3,[sp,#4]
;;;1137     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
00004c  f1020390          ADD      r3,r2,#0x90
000050  f8533021          LDR      r3,[r3,r1,LSL #2]
000054  9c01              LDR      r4,[sp,#4]
000056  601c              STR      r4,[r3,#0]
;;;1138     return status;  
;;;1139   }
000058  bd1c              POP      {r2-r4,pc}
;;;1140   
                          ENDP


                          AREA ||i.USB_OTG_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Halt PROC
;;;1083   */
;;;1084   USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1085   {
000002  b086              SUB      sp,sp,#0x18
000004  4602              MOV      r2,r0
;;;1086     USB_OTG_STS status = USB_OTG_OK;
000006  2000              MOVS     r0,#0
;;;1087     USB_OTG_HNPTXSTS_TypeDef            nptxsts;
;;;1088     USB_OTG_HPTXSTS_TypeDef             hptxsts;
;;;1089     USB_OTG_HCCHAR_TypeDef              hcchar;
;;;1090     
;;;1091     nptxsts.d32 = 0;
000008  2300              MOVS     r3,#0
00000a  9303              STR      r3,[sp,#0xc]
;;;1092     hptxsts.d32 = 0;
00000c  9301              STR      r3,[sp,#4]
;;;1093     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
00000e  f1020390          ADD      r3,r2,#0x90
000012  f8533021          LDR      r3,[r3,r1,LSL #2]
000016  681b              LDR      r3,[r3,#0]
000018  9300              STR      r3,[sp,#0]
;;;1094     hcchar.b.chen = 1;
00001a  9b00              LDR      r3,[sp,#0]
00001c  f0234300          BIC      r3,r3,#0x80000000
000020  f1034300          ADD      r3,r3,#0x80000000
000024  9300              STR      r3,[sp,#0]
;;;1095     hcchar.b.chdis = 1;
000026  9b00              LDR      r3,[sp,#0]
000028  f0234380          BIC      r3,r3,#0x40000000
00002c  f1034380          ADD      r3,r3,#0x40000000
000030  9300              STR      r3,[sp,#0]
;;;1096     
;;;1097     /* Check for space in the request queue to issue the halt. */
;;;1098     if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
000032  9b00              LDR      r3,[sp,#0]
000034  f3c34381          UBFX     r3,r3,#18,#2
000038  b123              CBZ      r3,|L13.68|
00003a  9b00              LDR      r3,[sp,#0]
00003c  f3c34381          UBFX     r3,r3,#18,#2
000040  2b02              CMP      r3,#2
000042  d10b              BNE      |L13.92|
                  |L13.68|
;;;1099     {
;;;1100       nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
000044  68d3              LDR      r3,[r2,#0xc]
000046  6adb              LDR      r3,[r3,#0x2c]
000048  9303              STR      r3,[sp,#0xc]
;;;1101       if (nptxsts.b.nptxqspcavail == 0)
00004a  9b03              LDR      r3,[sp,#0xc]
00004c  f3c34307          UBFX     r3,r3,#16,#8
000050  b97b              CBNZ     r3,|L13.114|
;;;1102       {
;;;1103         hcchar.b.chen = 0;
000052  9b00              LDR      r3,[sp,#0]
000054  f0234300          BIC      r3,r3,#0x80000000
000058  9300              STR      r3,[sp,#0]
00005a  e00a              B        |L13.114|
                  |L13.92|
;;;1104       }
;;;1105     }
;;;1106     else
;;;1107     {
;;;1108       hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
00005c  6953              LDR      r3,[r2,#0x14]
00005e  691b              LDR      r3,[r3,#0x10]
000060  9301              STR      r3,[sp,#4]
;;;1109       if (hptxsts.b.ptxqspcavail == 0)
000062  9b01              LDR      r3,[sp,#4]
000064  f3c34307          UBFX     r3,r3,#16,#8
000068  b91b              CBNZ     r3,|L13.114|
;;;1110       {
;;;1111         hcchar.b.chen = 0;
00006a  9b00              LDR      r3,[sp,#0]
00006c  f0234300          BIC      r3,r3,#0x80000000
000070  9300              STR      r3,[sp,#0]
                  |L13.114|
;;;1112       }
;;;1113     }
;;;1114     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000072  f1020390          ADD      r3,r2,#0x90
000076  f8533021          LDR      r3,[r3,r1,LSL #2]
00007a  9c00              LDR      r4,[sp,#0]
00007c  601c              STR      r4,[r3,#0]
;;;1115     return status;
;;;1116   }
00007e  b006              ADD      sp,sp,#0x18
000080  bd10              POP      {r4,pc}
;;;1117   
                          ENDP


                          AREA ||i.USB_OTG_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Init PROC
;;;856    */
;;;857    USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b53f              PUSH     {r0-r5,lr}
;;;858    {
000002  4602              MOV      r2,r0
;;;859      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;860      uint32_t intr_enable = 0;
000006  2300              MOVS     r3,#0
;;;861      USB_OTG_HCINTMSK_TypeDef  hcintmsk;
;;;862      USB_OTG_GINTMSK_TypeDef    gintmsk;
;;;863      USB_OTG_HCCHAR_TypeDef     hcchar;
;;;864      USB_OTG_HCINTn_TypeDef     hcint;
;;;865      
;;;866      
;;;867      gintmsk.d32 = 0;
000008  2400              MOVS     r4,#0
00000a  9402              STR      r4,[sp,#8]
;;;868      hcintmsk.d32 = 0;
00000c  9403              STR      r4,[sp,#0xc]
;;;869      hcchar.d32 = 0;
00000e  9401              STR      r4,[sp,#4]
;;;870      
;;;871      /* Clear old interrupt conditions for this host channel. */
;;;872      hcint.d32 = 0xFFFFFFFF;
000010  1e44              SUBS     r4,r0,#1
000012  9400              STR      r4,[sp,#0]
;;;873      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
000014  f1020490          ADD      r4,r2,#0x90
000018  f8544021          LDR      r4,[r4,r1,LSL #2]
00001c  9d00              LDR      r5,[sp,#0]
00001e  60a5              STR      r5,[r4,#8]
;;;874      
;;;875      /* Enable channel interrupts required for this transfer. */
;;;876      hcintmsk.d32 = 0;
000020  2400              MOVS     r4,#0
000022  9403              STR      r4,[sp,#0xc]
;;;877      
;;;878      if (pdev->cfg.dma_enable == 1)
000024  78d4              LDRB     r4,[r2,#3]
000026  2c01              CMP      r4,#1
000028  d104              BNE      |L14.52|
;;;879      {
;;;880        hcintmsk.b.ahberr = 1;
00002a  9c03              LDR      r4,[sp,#0xc]
00002c  f0240404          BIC      r4,r4,#4
000030  1d24              ADDS     r4,r4,#4
000032  9403              STR      r4,[sp,#0xc]
                  |L14.52|
;;;881      }
;;;882      
;;;883      switch (pdev->host.hc[hc_num].ep_type) 
000034  f502746b          ADD      r4,r2,#0x3ac
000038  eb041441          ADD      r4,r4,r1,LSL #5
00003c  7964              LDRB     r4,[r4,#5]
00003e  b134              CBZ      r4,|L14.78|
000040  2c01              CMP      r4,#1
000042  d06a              BEQ      |L14.282|
000044  2c02              CMP      r4,#2
000046  d003              BEQ      |L14.80|
000048  2c03              CMP      r4,#3
00004a  d138              BNE      |L14.190|
00004c  e038              B        |L14.192|
                  |L14.78|
;;;884      {
;;;885      case EP_TYPE_CTRL:
;;;886      case EP_TYPE_BULK:
00004e  bf00              NOP      
                  |L14.80|
;;;887        hcintmsk.b.xfercompl = 1;
000050  9c03              LDR      r4,[sp,#0xc]
000052  f0240401          BIC      r4,r4,#1
000056  1c64              ADDS     r4,r4,#1
000058  9403              STR      r4,[sp,#0xc]
;;;888        hcintmsk.b.stall = 1;
00005a  9c03              LDR      r4,[sp,#0xc]
00005c  f0240408          BIC      r4,r4,#8
000060  3408              ADDS     r4,r4,#8
000062  9403              STR      r4,[sp,#0xc]
;;;889        hcintmsk.b.xacterr = 1;
000064  9c03              LDR      r4,[sp,#0xc]
000066  f0240480          BIC      r4,r4,#0x80
00006a  3480              ADDS     r4,r4,#0x80
00006c  9403              STR      r4,[sp,#0xc]
;;;890        hcintmsk.b.datatglerr = 1;
00006e  9c03              LDR      r4,[sp,#0xc]
000070  f4246480          BIC      r4,r4,#0x400
000074  f5046480          ADD      r4,r4,#0x400
000078  9403              STR      r4,[sp,#0xc]
;;;891        hcintmsk.b.nak = 1;  
00007a  9c03              LDR      r4,[sp,#0xc]
00007c  f0240410          BIC      r4,r4,#0x10
000080  3410              ADDS     r4,r4,#0x10
000082  9403              STR      r4,[sp,#0xc]
;;;892        if (pdev->host.hc[hc_num].ep_is_in) 
000084  f502746b          ADD      r4,r2,#0x3ac
000088  eb041441          ADD      r4,r4,r1,LSL #5
00008c  78a4              LDRB     r4,[r4,#2]
00008e  b134              CBZ      r4,|L14.158|
;;;893        {
;;;894          hcintmsk.b.bblerr = 1;
000090  9c03              LDR      r4,[sp,#0xc]
000092  f4247480          BIC      r4,r4,#0x100
000096  f5047480          ADD      r4,r4,#0x100
00009a  9403              STR      r4,[sp,#0xc]
00009c  e00f              B        |L14.190|
                  |L14.158|
;;;895        } 
;;;896        else 
;;;897        {
;;;898          hcintmsk.b.nyet = 1;
00009e  9c03              LDR      r4,[sp,#0xc]
0000a0  f0240440          BIC      r4,r4,#0x40
0000a4  3440              ADDS     r4,r4,#0x40
0000a6  9403              STR      r4,[sp,#0xc]
;;;899          if (pdev->host.hc[hc_num].do_ping) 
0000a8  f502746b          ADD      r4,r2,#0x3ac
0000ac  eb041441          ADD      r4,r4,r1,LSL #5
0000b0  7924              LDRB     r4,[r4,#4]
0000b2  b124              CBZ      r4,|L14.190|
;;;900          {
;;;901            hcintmsk.b.ack = 1;
0000b4  9c03              LDR      r4,[sp,#0xc]
0000b6  f0240420          BIC      r4,r4,#0x20
0000ba  3420              ADDS     r4,r4,#0x20
0000bc  9403              STR      r4,[sp,#0xc]
                  |L14.190|
;;;902          }
;;;903        }
;;;904        break;
0000be  e04e              B        |L14.350|
                  |L14.192|
;;;905      case EP_TYPE_INTR:
;;;906        hcintmsk.b.xfercompl = 1;
0000c0  9c03              LDR      r4,[sp,#0xc]
0000c2  f0240401          BIC      r4,r4,#1
0000c6  1c64              ADDS     r4,r4,#1
0000c8  9403              STR      r4,[sp,#0xc]
;;;907        hcintmsk.b.nak = 1;
0000ca  9c03              LDR      r4,[sp,#0xc]
0000cc  f0240410          BIC      r4,r4,#0x10
0000d0  3410              ADDS     r4,r4,#0x10
0000d2  9403              STR      r4,[sp,#0xc]
;;;908        hcintmsk.b.stall = 1;
0000d4  9c03              LDR      r4,[sp,#0xc]
0000d6  f0240408          BIC      r4,r4,#8
0000da  3408              ADDS     r4,r4,#8
0000dc  9403              STR      r4,[sp,#0xc]
;;;909        hcintmsk.b.xacterr = 1;
0000de  9c03              LDR      r4,[sp,#0xc]
0000e0  f0240480          BIC      r4,r4,#0x80
0000e4  3480              ADDS     r4,r4,#0x80
0000e6  9403              STR      r4,[sp,#0xc]
;;;910        hcintmsk.b.datatglerr = 1;
0000e8  9c03              LDR      r4,[sp,#0xc]
0000ea  f4246480          BIC      r4,r4,#0x400
0000ee  f5046480          ADD      r4,r4,#0x400
0000f2  9403              STR      r4,[sp,#0xc]
;;;911        hcintmsk.b.frmovrun = 1;
0000f4  9c03              LDR      r4,[sp,#0xc]
0000f6  f4247400          BIC      r4,r4,#0x200
0000fa  f5047400          ADD      r4,r4,#0x200
0000fe  9403              STR      r4,[sp,#0xc]
;;;912        
;;;913        if (pdev->host.hc[hc_num].ep_is_in) 
000100  f502746b          ADD      r4,r2,#0x3ac
000104  eb041441          ADD      r4,r4,r1,LSL #5
000108  78a4              LDRB     r4,[r4,#2]
00010a  b12c              CBZ      r4,|L14.280|
;;;914        {
;;;915          hcintmsk.b.bblerr = 1;
00010c  9c03              LDR      r4,[sp,#0xc]
00010e  f4247480          BIC      r4,r4,#0x100
000112  f5047480          ADD      r4,r4,#0x100
000116  9403              STR      r4,[sp,#0xc]
                  |L14.280|
;;;916        }
;;;917        
;;;918        break;
000118  e021              B        |L14.350|
                  |L14.282|
;;;919      case EP_TYPE_ISOC:
;;;920        hcintmsk.b.xfercompl = 1;
00011a  9c03              LDR      r4,[sp,#0xc]
00011c  f0240401          BIC      r4,r4,#1
000120  1c64              ADDS     r4,r4,#1
000122  9403              STR      r4,[sp,#0xc]
;;;921        hcintmsk.b.frmovrun = 1;
000124  9c03              LDR      r4,[sp,#0xc]
000126  f4247400          BIC      r4,r4,#0x200
00012a  f5047400          ADD      r4,r4,#0x200
00012e  9403              STR      r4,[sp,#0xc]
;;;922        hcintmsk.b.ack = 1;
000130  9c03              LDR      r4,[sp,#0xc]
000132  f0240420          BIC      r4,r4,#0x20
000136  3420              ADDS     r4,r4,#0x20
000138  9403              STR      r4,[sp,#0xc]
;;;923        
;;;924        if (pdev->host.hc[hc_num].ep_is_in) 
00013a  f502746b          ADD      r4,r2,#0x3ac
00013e  eb041441          ADD      r4,r4,r1,LSL #5
000142  78a4              LDRB     r4,[r4,#2]
000144  b154              CBZ      r4,|L14.348|
;;;925        {
;;;926          hcintmsk.b.xacterr = 1;
000146  9c03              LDR      r4,[sp,#0xc]
000148  f0240480          BIC      r4,r4,#0x80
00014c  3480              ADDS     r4,r4,#0x80
00014e  9403              STR      r4,[sp,#0xc]
;;;927          hcintmsk.b.bblerr = 1;
000150  9c03              LDR      r4,[sp,#0xc]
000152  f4247480          BIC      r4,r4,#0x100
000156  f5047480          ADD      r4,r4,#0x100
00015a  9403              STR      r4,[sp,#0xc]
                  |L14.348|
;;;928        }
;;;929        break;
00015c  bf00              NOP      
                  |L14.350|
00015e  bf00              NOP                            ;904
;;;930      }
;;;931      
;;;932      
;;;933      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
000160  f1020490          ADD      r4,r2,#0x90
000164  f8544021          LDR      r4,[r4,r1,LSL #2]
000168  9d03              LDR      r5,[sp,#0xc]
00016a  60e5              STR      r5,[r4,#0xc]
;;;934      
;;;935      
;;;936      /* Enable the top level host channel interrupt. */
;;;937      intr_enable = (1 << hc_num);
00016c  2401              MOVS     r4,#1
00016e  fa04f301          LSL      r3,r4,r1
;;;938      USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
000172  6954              LDR      r4,[r2,#0x14]
000174  69a4              LDR      r4,[r4,#0x18]
000176  431c              ORRS     r4,r4,r3
000178  6955              LDR      r5,[r2,#0x14]
00017a  61ac              STR      r4,[r5,#0x18]
;;;939      
;;;940      /* Make sure host channel interrupts are enabled. */
;;;941      gintmsk.b.hcintr = 1;
00017c  9c02              LDR      r4,[sp,#8]
00017e  f0247400          BIC      r4,r4,#0x2000000
000182  f1047400          ADD      r4,r4,#0x2000000
000186  9402              STR      r4,[sp,#8]
;;;942      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
000188  68d4              LDR      r4,[r2,#0xc]
00018a  69a4              LDR      r4,[r4,#0x18]
00018c  9d02              LDR      r5,[sp,#8]
00018e  432c              ORRS     r4,r4,r5
000190  68d5              LDR      r5,[r2,#0xc]
000192  61ac              STR      r4,[r5,#0x18]
;;;943      
;;;944      /* Program the HCCHAR register */
;;;945      hcchar.d32 = 0;
000194  2400              MOVS     r4,#0
000196  9401              STR      r4,[sp,#4]
;;;946      hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
000198  f502746b          ADD      r4,r2,#0x3ac
00019c  eb041441          ADD      r4,r4,r1,LSL #5
0001a0  7825              LDRB     r5,[r4,#0]
0001a2  9c01              LDR      r4,[sp,#4]
0001a4  f365549c          BFI      r4,r5,#22,#7
0001a8  9401              STR      r4,[sp,#4]
;;;947      hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
0001aa  f502746b          ADD      r4,r2,#0x3ac
0001ae  eb041441          ADD      r4,r4,r1,LSL #5
0001b2  7865              LDRB     r5,[r4,#1]
0001b4  9c01              LDR      r4,[sp,#4]
0001b6  f36524ce          BFI      r4,r5,#11,#4
0001ba  9401              STR      r4,[sp,#4]
;;;948      hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
0001bc  f502746b          ADD      r4,r2,#0x3ac
0001c0  eb041441          ADD      r4,r4,r1,LSL #5
0001c4  78a5              LDRB     r5,[r4,#2]
0001c6  9c01              LDR      r4,[sp,#4]
0001c8  f36534cf          BFI      r4,r5,#15,#1
0001cc  9401              STR      r4,[sp,#4]
;;;949      hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
0001ce  f502746b          ADD      r4,r2,#0x3ac
0001d2  eb041441          ADD      r4,r4,r1,LSL #5
0001d6  78e4              LDRB     r4,[r4,#3]
0001d8  2c02              CMP      r4,#2
0001da  d101              BNE      |L14.480|
0001dc  2501              MOVS     r5,#1
0001de  e000              B        |L14.482|
                  |L14.480|
0001e0  2500              MOVS     r5,#0
                  |L14.482|
0001e2  9c01              LDR      r4,[sp,#4]
0001e4  f3654451          BFI      r4,r5,#17,#1
0001e8  9401              STR      r4,[sp,#4]
;;;950      hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
0001ea  f502746b          ADD      r4,r2,#0x3ac
0001ee  eb041441          ADD      r4,r4,r1,LSL #5
0001f2  7965              LDRB     r5,[r4,#5]
0001f4  9c01              LDR      r4,[sp,#4]
0001f6  f3654493          BFI      r4,r5,#18,#2
0001fa  9401              STR      r4,[sp,#4]
;;;951      hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
0001fc  f502746b          ADD      r4,r2,#0x3ac
000200  eb041441          ADD      r4,r4,r1,LSL #5
000204  88e5              LDRH     r5,[r4,#6]
000206  9c01              LDR      r4,[sp,#4]
000208  f365040a          BFI      r4,r5,#0,#11
00020c  9401              STR      r4,[sp,#4]
;;;952      if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
00020e  f502746b          ADD      r4,r2,#0x3ac
000212  eb041441          ADD      r4,r4,r1,LSL #5
000216  7964              LDRB     r4,[r4,#5]
000218  2c03              CMP      r4,#3
00021a  d105              BNE      |L14.552|
;;;953      {
;;;954        hcchar.b.oddfrm  = 1;
00021c  9c01              LDR      r4,[sp,#4]
00021e  f0245400          BIC      r4,r4,#0x20000000
000222  f1045400          ADD      r4,r4,#0x20000000
000226  9401              STR      r4,[sp,#4]
                  |L14.552|
;;;955      }
;;;956      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000228  f1020490          ADD      r4,r2,#0x90
00022c  f8544021          LDR      r4,[r4,r1,LSL #2]
000230  9d01              LDR      r5,[sp,#4]
000232  6025              STR      r5,[r4,#0]
;;;957      return status;
;;;958    }
000234  b004              ADD      sp,sp,#0x10
000236  bd30              POP      {r4,r5,pc}
;;;959    
                          ENDP


                          AREA ||i.USB_OTG_HC_StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_StartXfer PROC
;;;966    */
;;;967    USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;968    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;969      USB_OTG_STS status = USB_OTG_OK;
00000a  f04f0900          MOV      r9,#0
;;;970      USB_OTG_HCCHAR_TypeDef   hcchar;
;;;971      USB_OTG_HCTSIZn_TypeDef  hctsiz;
;;;972      USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
;;;973      USB_OTG_HPTXSTS_TypeDef  hptxsts; 
;;;974      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;975      uint16_t                 len_words = 0;   
00000e  46c8              MOV      r8,r9
;;;976      
;;;977      uint16_t num_packets;
;;;978      uint16_t max_hc_pkt_count;
;;;979      
;;;980      max_hc_pkt_count = 256;
000010  f44f7780          MOV      r7,#0x100
;;;981      hctsiz.d32 = 0;
000014  2000              MOVS     r0,#0
000016  9006              STR      r0,[sp,#0x18]
;;;982      hcchar.d32 = 0;
000018  9007              STR      r0,[sp,#0x1c]
;;;983      intmsk.d32 = 0;
00001a  9000              STR      r0,[sp,#0]
;;;984      
;;;985      /* Compute the expected number of packets associated to the transfer */
;;;986      if (pdev->host.hc[hc_num].xfer_len > 0)
00001c  f504706b          ADD      r0,r4,#0x3ac
000020  eb001045          ADD      r0,r0,r5,LSL #5
000024  6900              LDR      r0,[r0,#0x10]
000026  b310              CBZ      r0,|L15.110|
;;;987      {
;;;988        num_packets = (pdev->host.hc[hc_num].xfer_len + \
000028  f504706b          ADD      r0,r4,#0x3ac
00002c  eb001045          ADD      r0,r0,r5,LSL #5
000030  6901              LDR      r1,[r0,#0x10]
000032  f504706b          ADD      r0,r4,#0x3ac
000036  eb001045          ADD      r0,r0,r5,LSL #5
00003a  88c0              LDRH     r0,[r0,#6]
00003c  4401              ADD      r1,r1,r0
00003e  1e49              SUBS     r1,r1,#1
000040  f504706b          ADD      r0,r4,#0x3ac
000044  eb001045          ADD      r0,r0,r5,LSL #5
000048  88c0              LDRH     r0,[r0,#6]
00004a  fbb1f0f0          UDIV     r0,r1,r0
00004e  b286              UXTH     r6,r0
;;;989          pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
;;;990        
;;;991        if (num_packets > max_hc_pkt_count)
000050  42be              CMP      r6,r7
000052  dd0d              BLE      |L15.112|
;;;992        {
;;;993          num_packets = max_hc_pkt_count;
000054  463e              MOV      r6,r7
;;;994          pdev->host.hc[hc_num].xfer_len = num_packets * \
000056  f504706b          ADD      r0,r4,#0x3ac
00005a  eb001045          ADD      r0,r0,r5,LSL #5
00005e  88c1              LDRH     r1,[r0,#6]
000060  4371              MULS     r1,r6,r1
000062  f504706b          ADD      r0,r4,#0x3ac
000066  eb001045          ADD      r0,r0,r5,LSL #5
00006a  6101              STR      r1,[r0,#0x10]
00006c  e000              B        |L15.112|
                  |L15.110|
;;;995            pdev->host.hc[hc_num].max_packet;
;;;996        }
;;;997      }
;;;998      else
;;;999      {
;;;1000       num_packets = 1;
00006e  2601              MOVS     r6,#1
                  |L15.112|
;;;1001     }
;;;1002     if (pdev->host.hc[hc_num].ep_is_in)
000070  f504706b          ADD      r0,r4,#0x3ac
000074  eb001045          ADD      r0,r0,r5,LSL #5
000078  7880              LDRB     r0,[r0,#2]
00007a  b150              CBZ      r0,|L15.146|
;;;1003     {
;;;1004       pdev->host.hc[hc_num].xfer_len = num_packets * \
00007c  f504706b          ADD      r0,r4,#0x3ac
000080  eb001045          ADD      r0,r0,r5,LSL #5
000084  88c1              LDRH     r1,[r0,#6]
000086  4371              MULS     r1,r6,r1
000088  f504706b          ADD      r0,r4,#0x3ac
00008c  eb001045          ADD      r0,r0,r5,LSL #5
000090  6101              STR      r1,[r0,#0x10]
                  |L15.146|
;;;1005         pdev->host.hc[hc_num].max_packet;
;;;1006     }
;;;1007     /* Initialize the HCTSIZn register */
;;;1008     hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
000092  f504706b          ADD      r0,r4,#0x3ac
000096  eb001045          ADD      r0,r0,r5,LSL #5
00009a  6901              LDR      r1,[r0,#0x10]
00009c  9806              LDR      r0,[sp,#0x18]
00009e  f3610012          BFI      r0,r1,#0,#19
0000a2  9006              STR      r0,[sp,#0x18]
;;;1009     hctsiz.b.pktcnt = num_packets;
0000a4  9806              LDR      r0,[sp,#0x18]
0000a6  f36640dc          BFI      r0,r6,#19,#10
0000aa  9006              STR      r0,[sp,#0x18]
;;;1010     hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
0000ac  f504706b          ADD      r0,r4,#0x3ac
0000b0  eb001045          ADD      r0,r0,r5,LSL #5
0000b4  7a01              LDRB     r1,[r0,#8]
0000b6  9806              LDR      r0,[sp,#0x18]
0000b8  f361705e          BFI      r0,r1,#29,#2
0000bc  9006              STR      r0,[sp,#0x18]
;;;1011     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
0000be  f1040090          ADD      r0,r4,#0x90
0000c2  f8500025          LDR      r0,[r0,r5,LSL #2]
0000c6  9906              LDR      r1,[sp,#0x18]
0000c8  6101              STR      r1,[r0,#0x10]
;;;1012     
;;;1013     if (pdev->cfg.dma_enable == 1)
0000ca  78e0              LDRB     r0,[r4,#3]
0000cc  2801              CMP      r0,#1
0000ce  d109              BNE      |L15.228|
;;;1014     {
;;;1015       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
0000d0  f504706b          ADD      r0,r4,#0x3ac
0000d4  eb001045          ADD      r0,r0,r5,LSL #5
0000d8  68c1              LDR      r1,[r0,#0xc]
0000da  f1040090          ADD      r0,r4,#0x90
0000de  f8500025          LDR      r0,[r0,r5,LSL #2]
0000e2  6141              STR      r1,[r0,#0x14]
                  |L15.228|
;;;1016     }
;;;1017     
;;;1018     
;;;1019     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
0000e4  f1040090          ADD      r0,r4,#0x90
0000e8  f8500025          LDR      r0,[r0,r5,LSL #2]
0000ec  6800              LDR      r0,[r0,#0]
0000ee  9007              STR      r0,[sp,#0x1c]
;;;1020     hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       USB_OTG_IsEvenFrame
0000f6  9907              LDR      r1,[sp,#0x1c]
0000f8  f360715d          BFI      r1,r0,#29,#1
0000fc  9107              STR      r1,[sp,#0x1c]
;;;1021     
;;;1022     /* Set host channel enable */
;;;1023     hcchar.b.chen = 1;
0000fe  9807              LDR      r0,[sp,#0x1c]
000100  f0204000          BIC      r0,r0,#0x80000000
000104  f1004000          ADD      r0,r0,#0x80000000
000108  9007              STR      r0,[sp,#0x1c]
;;;1024     hcchar.b.chdis = 0;
00010a  9807              LDR      r0,[sp,#0x1c]
00010c  f0204080          BIC      r0,r0,#0x40000000
000110  9007              STR      r0,[sp,#0x1c]
;;;1025     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000112  f1040090          ADD      r0,r4,#0x90
000116  f8500025          LDR      r0,[r0,r5,LSL #2]
00011a  9907              LDR      r1,[sp,#0x1c]
00011c  6001              STR      r1,[r0,#0]
;;;1026     
;;;1027     if (pdev->cfg.dma_enable == 0) /* Slave mode */
00011e  78e0              LDRB     r0,[r4,#3]
000120  2800              CMP      r0,#0
000122  d164              BNE      |L15.494|
;;;1028     {  
;;;1029       if((pdev->host.hc[hc_num].ep_is_in == 0) && 
000124  f504706b          ADD      r0,r4,#0x3ac
000128  eb001045          ADD      r0,r0,r5,LSL #5
00012c  7880              LDRB     r0,[r0,#2]
00012e  2800              CMP      r0,#0
000130  d15d              BNE      |L15.494|
;;;1030          (pdev->host.hc[hc_num].xfer_len > 0))
000132  f504706b          ADD      r0,r4,#0x3ac
000136  eb001045          ADD      r0,r0,r5,LSL #5
00013a  6900              LDR      r0,[r0,#0x10]
00013c  2800              CMP      r0,#0
00013e  d056              BEQ      |L15.494|
;;;1031       {
;;;1032         switch(pdev->host.hc[hc_num].ep_type) 
000140  f504706b          ADD      r0,r4,#0x3ac
000144  eb001045          ADD      r0,r0,r5,LSL #5
000148  7940              LDRB     r0,[r0,#5]
00014a  b130              CBZ      r0,|L15.346|
00014c  2801              CMP      r0,#1
00014e  d021              BEQ      |L15.404|
000150  2802              CMP      r0,#2
000152  d003              BEQ      |L15.348|
000154  2803              CMP      r0,#3
000156  d139              BNE      |L15.460|
000158  e01b              B        |L15.402|
                  |L15.346|
;;;1033         {
;;;1034           /* Non periodic transfer */
;;;1035         case EP_TYPE_CTRL:
;;;1036         case EP_TYPE_BULK:
00015a  bf00              NOP      
                  |L15.348|
;;;1037           
;;;1038           hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
00015c  68e0              LDR      r0,[r4,#0xc]
00015e  6ac0              LDR      r0,[r0,#0x2c]
000160  9003              STR      r0,[sp,#0xc]
;;;1039           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
000162  f504706b          ADD      r0,r4,#0x3ac
000166  eb001045          ADD      r0,r0,r5,LSL #5
00016a  6900              LDR      r0,[r0,#0x10]
00016c  1cc0              ADDS     r0,r0,#3
00016e  f3c0088f          UBFX     r8,r0,#2,#16
;;;1040           
;;;1041           /* check if there is enough space in FIFO space */
;;;1042           if(len_words > hnptxsts.b.nptxfspcavail)
000172  9803              LDR      r0,[sp,#0xc]
000174  b280              UXTH     r0,r0
000176  4540              CMP      r0,r8
000178  da0a              BGE      |L15.400|
;;;1043           {
;;;1044             /* need to process data in nptxfempty interrupt */
;;;1045             intmsk.b.nptxfempty = 1;
00017a  9800              LDR      r0,[sp,#0]
00017c  f0200020          BIC      r0,r0,#0x20
000180  3020              ADDS     r0,r0,#0x20
000182  9000              STR      r0,[sp,#0]
;;;1046             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
000184  68e0              LDR      r0,[r4,#0xc]
000186  6980              LDR      r0,[r0,#0x18]
000188  9900              LDR      r1,[sp,#0]
00018a  4308              ORRS     r0,r0,r1
00018c  68e1              LDR      r1,[r4,#0xc]
00018e  6188              STR      r0,[r1,#0x18]
                  |L15.400|
;;;1047           }
;;;1048           
;;;1049           break;
000190  e01d              B        |L15.462|
                  |L15.402|
;;;1050           /* Periodic transfer */
;;;1051         case EP_TYPE_INTR:
;;;1052         case EP_TYPE_ISOC:
000192  bf00              NOP      
                  |L15.404|
;;;1053           hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
000194  6960              LDR      r0,[r4,#0x14]
000196  6900              LDR      r0,[r0,#0x10]
000198  9001              STR      r0,[sp,#4]
;;;1054           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
00019a  f504706b          ADD      r0,r4,#0x3ac
00019e  eb001045          ADD      r0,r0,r5,LSL #5
0001a2  6900              LDR      r0,[r0,#0x10]
0001a4  1cc0              ADDS     r0,r0,#3
0001a6  f3c0088f          UBFX     r8,r0,#2,#16
;;;1055           /* check if there is enough space in FIFO space */
;;;1056           if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
0001aa  9801              LDR      r0,[sp,#4]
0001ac  b280              UXTH     r0,r0
0001ae  4540              CMP      r0,r8
0001b0  da0b              BGE      |L15.458|
;;;1057           {
;;;1058             /* need to process data in ptxfempty interrupt */
;;;1059             intmsk.b.ptxfempty = 1;
0001b2  9800              LDR      r0,[sp,#0]
0001b4  f0206080          BIC      r0,r0,#0x4000000
0001b8  f1006080          ADD      r0,r0,#0x4000000
0001bc  9000              STR      r0,[sp,#0]
;;;1060             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0001be  68e0              LDR      r0,[r4,#0xc]
0001c0  6980              LDR      r0,[r0,#0x18]
0001c2  9900              LDR      r1,[sp,#0]
0001c4  4308              ORRS     r0,r0,r1
0001c6  68e1              LDR      r1,[r4,#0xc]
0001c8  6188              STR      r0,[r1,#0x18]
                  |L15.458|
;;;1061           }
;;;1062           break;
0001ca  e000              B        |L15.462|
                  |L15.460|
;;;1063           
;;;1064         default:
;;;1065           break;
0001cc  bf00              NOP      
                  |L15.462|
0001ce  bf00              NOP                            ;1049
;;;1066         }
;;;1067         
;;;1068         /* Write packet into the Tx FIFO. */
;;;1069         USB_OTG_WritePacket(pdev, 
0001d0  f504706b          ADD      r0,r4,#0x3ac
0001d4  eb001045          ADD      r0,r0,r5,LSL #5
0001d8  8a00              LDRH     r0,[r0,#0x10]
0001da  b283              UXTH     r3,r0
0001dc  f504706b          ADD      r0,r4,#0x3ac
0001e0  eb001045          ADD      r0,r0,r5,LSL #5
0001e4  462a              MOV      r2,r5
0001e6  68c1              LDR      r1,[r0,#0xc]
0001e8  4620              MOV      r0,r4
0001ea  f7fffffe          BL       USB_OTG_WritePacket
                  |L15.494|
;;;1070                             pdev->host.hc[hc_num].xfer_buff , 
;;;1071                             hc_num, pdev->host.hc[hc_num].xfer_len);
;;;1072       }
;;;1073     }
;;;1074     return status;
0001ee  4648              MOV      r0,r9
;;;1075   }
0001f0  b008              ADD      sp,sp,#0x20
0001f2  e8bd83f0          POP      {r4-r9,pc}
;;;1076   
                          ENDP


                          AREA ||i.USB_OTG_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitFSLSPClkSel PROC
;;;789    */
;;;790    void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
000000  b508              PUSH     {r3,lr}
;;;791    {
;;;792      USB_OTG_HCFG_TypeDef   hcfg;
;;;793      
;;;794      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000002  6942              LDR      r2,[r0,#0x14]
000004  6812              LDR      r2,[r2,#0]
000006  9200              STR      r2,[sp,#0]
;;;795      hcfg.b.fslspclksel = freq;
000008  9a00              LDR      r2,[sp,#0]
00000a  f3610201          BFI      r2,r1,#0,#2
00000e  9200              STR      r2,[sp,#0]
;;;796      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000010  9b00              LDR      r3,[sp,#0]
000012  6942              LDR      r2,[r0,#0x14]
000014  6013              STR      r3,[r2,#0]
;;;797    }
000016  bd08              POP      {r3,pc}
;;;798    
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;564    */
;;;565    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;566    {
000002  4602              MOV      r2,r0
;;;567      return (USB_OTG_GetMode(pdev) != HOST_MODE);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USB_OTG_GetMode
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L17.18|
00000e  2001              MOVS     r0,#1
                  |L17.16|
;;;568    }
000010  bd00              POP      {pc}
                  |L17.18|
000012  2000              MOVS     r0,#0                 ;567
000014  e7fc              B        |L17.16|
;;;569    
                          ENDP


                          AREA ||i.USB_OTG_IsEvenFrame||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsEvenFrame PROC
;;;715    */
;;;716    uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  4601              MOV      r1,r0
;;;717    {
;;;718      return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
000002  6948              LDR      r0,[r1,#0x14]
000004  6880              LDR      r0,[r0,#8]
000006  f0000001          AND      r0,r0,#1
00000a  f0800001          EOR      r0,r0,#1
;;;719    }
00000e  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;575    */
;;;576    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;577    {
000002  4602              MOV      r2,r0
;;;578      return (USB_OTG_GetMode(pdev) == HOST_MODE);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USB_OTG_GetMode
00000a  2801              CMP      r0,#1
00000c  d100              BNE      |L19.16|
                  |L19.14|
;;;579    }
00000e  bd00              POP      {pc}
                  |L19.16|
000010  2000              MOVS     r0,#0                 ;578
000012  e7fc              B        |L19.14|
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;586    */
;;;587    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;588    {
;;;589      uint32_t v = 0;
000002  2000              MOVS     r0,#0
;;;590      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000004  68ca              LDR      r2,[r1,#0xc]
000006  6950              LDR      r0,[r2,#0x14]
;;;591      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000008  68ca              LDR      r2,[r1,#0xc]
00000a  6992              LDR      r2,[r2,#0x18]
00000c  4010              ANDS     r0,r0,r2
;;;592      return v;
;;;593    }
00000e  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_ReadHPRT0||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHPRT0 PROC
;;;804    */
;;;805    uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;806    {
000002  4601              MOV      r1,r0
;;;807      USB_OTG_HPRT0_TypeDef  hprt0;
;;;808      
;;;809      hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  f8d100cc          LDR      r0,[r1,#0xcc]
000008  6800              LDR      r0,[r0,#0]
00000a  9000              STR      r0,[sp,#0]
;;;810      hprt0.b.prtena = 0;
00000c  9800              LDR      r0,[sp,#0]
00000e  f0200004          BIC      r0,r0,#4
000012  9000              STR      r0,[sp,#0]
;;;811      hprt0.b.prtconndet = 0;
000014  9800              LDR      r0,[sp,#0]
000016  f0200002          BIC      r0,r0,#2
00001a  9000              STR      r0,[sp,#0]
;;;812      hprt0.b.prtenchng = 0;
00001c  9800              LDR      r0,[sp,#0]
00001e  f0200008          BIC      r0,r0,#8
000022  9000              STR      r0,[sp,#0]
;;;813      hprt0.b.prtovrcurrchng = 0;
000024  9800              LDR      r0,[sp,#0]
000026  f0200020          BIC      r0,r0,#0x20
00002a  9000              STR      r0,[sp,#0]
;;;814      return hprt0.d32;
00002c  9800              LDR      r0,[sp,#0]
;;;815    }
00002e  bd08              POP      {r3,pc}
;;;816    
                          ENDP


                          AREA ||i.USB_OTG_ReadHostAllChannels_intr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHostAllChannels_intr PROC
;;;822    */
;;;823    uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;824    {
;;;825      return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
000002  6948              LDR      r0,[r1,#0x14]
000004  6940              LDR      r0,[r0,#0x14]
;;;826    }
000006  4770              BX       lr
;;;827    
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;600    */
;;;601    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;602    {
;;;603      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  68c8              LDR      r0,[r1,#0xc]
000004  6840              LDR      r0,[r0,#4]
;;;604    }
000006  4770              BX       lr
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;196    */
;;;197    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;198                             uint8_t *dest, 
;;;199                             uint16_t len)
;;;200    {
000002  4603              MOV      r3,r0
;;;201      uint32_t i=0;
000004  2400              MOVS     r4,#0
;;;202      uint32_t count32b = (len + 3) / 4;
000006  1cd0              ADDS     r0,r2,#3
000008  17c7              ASRS     r7,r0,#31
00000a  eb007797          ADD      r7,r0,r7,LSR #30
00000e  10bd              ASRS     r5,r7,#2
;;;203      
;;;204      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
000010  f8d360d0          LDR      r6,[r3,#0xd0]
;;;205      
;;;206      for ( i = 0; i < count32b; i++, dest += 4 )
000014  bf00              NOP      
000016  e003              B        |L24.32|
                  |L24.24|
;;;207      {
;;;208        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000018  6830              LDR      r0,[r6,#0]
00001a  6008              STR      r0,[r1,#0]
00001c  1c64              ADDS     r4,r4,#1              ;206
00001e  1d09              ADDS     r1,r1,#4              ;206
                  |L24.32|
000020  42ac              CMP      r4,r5                 ;206
000022  d3f9              BCC      |L24.24|
;;;209        
;;;210      }
;;;211      return ((void *)dest);
000024  4608              MOV      r0,r1
;;;212    }
000026  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP


                          AREA ||i.USB_OTG_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_OTG_ResetPort PROC
;;;835    */
;;;836    uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;837    {
000002  4604              MOV      r4,r0
;;;838      USB_OTG_HPRT0_TypeDef  hprt0;
;;;839      
;;;840      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       USB_OTG_ReadHPRT0
00000a  9000              STR      r0,[sp,#0]
;;;841      hprt0.b.prtrst = 1;
00000c  9800              LDR      r0,[sp,#0]
00000e  f4207080          BIC      r0,r0,#0x100
000012  f5007080          ADD      r0,r0,#0x100
000016  9000              STR      r0,[sp,#0]
;;;842      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000018  9900              LDR      r1,[sp,#0]
00001a  f8d400cc          LDR      r0,[r4,#0xcc]
00001e  6001              STR      r1,[r0,#0]
;;;843      USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
000020  200a              MOVS     r0,#0xa
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;844      hprt0.b.prtrst = 0;
000026  9800              LDR      r0,[sp,#0]
000028  f4207080          BIC      r0,r0,#0x100
00002c  9000              STR      r0,[sp,#0]
;;;845      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00002e  9900              LDR      r1,[sp,#0]
000030  f8d400cc          LDR      r0,[r4,#0xcc]
000034  6001              STR      r1,[r0,#0]
;;;846      USB_OTG_BSP_mDelay (20);   
000036  2014              MOVS     r0,#0x14
000038  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;847      return 1;
00003c  2001              MOVS     r0,#1
;;;848    }
00003e  bd38              POP      {r3-r5,pc}
;;;849    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;220    */
;;;221    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;222                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;223    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;224      uint32_t i , baseAddress = 0;
000006  2300              MOVS     r3,#0
;;;225      USB_OTG_STS status = USB_OTG_OK;
000008  2000              MOVS     r0,#0
;;;226      
;;;227      pdev->cfg.dma_enable       = 0;
00000a  2500              MOVS     r5,#0
00000c  70d5              STRB     r5,[r2,#3]
;;;228      
;;;229      /* at startup the core is in FS mode */
;;;230      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
00000e  2501              MOVS     r5,#1
000010  7095              STRB     r5,[r2,#2]
;;;231      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
000012  2540              MOVS     r5,#0x40
000014  8095              STRH     r5,[r2,#4]
;;;232      
;;;233      /* initialize device cfg following its address */
;;;234      if (coreID == USB_OTG_FS_CORE_ID)
000016  2c01              CMP      r4,#1
000018  d10c              BNE      |L26.52|
;;;235      {
;;;236        baseAddress                = USB_OTG_FS_BASE_ADDR;
00001a  f04f43a0          MOV      r3,#0x50000000
;;;237        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
00001e  2501              MOVS     r5,#1
000020  72d5              STRB     r5,[r2,#0xb]
;;;238        pdev->cfg.host_channels    = 8 ;
000022  2508              MOVS     r5,#8
000024  7015              STRB     r5,[r2,#0]
;;;239        pdev->cfg.dev_endpoints    = 4 ;
000026  2504              MOVS     r5,#4
000028  7055              STRB     r5,[r2,#1]
;;;240        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
00002a  159d              ASRS     r5,r3,#22
00002c  80d5              STRH     r5,[r2,#6]
;;;241        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
00002e  2502              MOVS     r5,#2
000030  7215              STRB     r5,[r2,#8]
000032  e00e              B        |L26.82|
                  |L26.52|
;;;242        
;;;243    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;244        pdev->cfg.Sof_output       = 1;    
;;;245    #endif 
;;;246        
;;;247    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;248        pdev->cfg.low_power        = 1;    
;;;249    #endif     
;;;250      }
;;;251      else if (coreID == USB_OTG_HS_CORE_ID)
000034  b96c              CBNZ     r4,|L26.82|
;;;252      {
;;;253        baseAddress                = USB_OTG_HS_BASE_ADDR;
000036  4b27              LDR      r3,|L26.212|
;;;254        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000038  2500              MOVS     r5,#0
00003a  72d5              STRB     r5,[r2,#0xb]
;;;255        pdev->cfg.host_channels    = 12 ;
00003c  250c              MOVS     r5,#0xc
00003e  7015              STRB     r5,[r2,#0]
;;;256        pdev->cfg.dev_endpoints    = 6 ;
000040  2506              MOVS     r5,#6
000042  7055              STRB     r5,[r2,#1]
;;;257        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
000044  f44f65a0          MOV      r5,#0x500
000048  80d5              STRH     r5,[r2,#6]
;;;258        
;;;259    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;260        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;261    #else    
;;;262    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;263        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
00004a  2502              MOVS     r5,#2
00004c  7215              STRB     r5,[r2,#8]
;;;264    #endif  
;;;265    #endif      
;;;266        
;;;267    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;268        pdev->cfg.dma_enable       = 1;    
00004e  2501              MOVS     r5,#1
000050  70d5              STRB     r5,[r2,#3]
                  |L26.82|
;;;269    #endif
;;;270        
;;;271    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;272        pdev->cfg.Sof_output       = 1;    
;;;273    #endif 
;;;274        
;;;275    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;276        pdev->cfg.low_power        = 1;    
;;;277    #endif 
;;;278        
;;;279      }
;;;280      
;;;281      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
000052  60d3              STR      r3,[r2,#0xc]
;;;282        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;283      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
000054  f5036500          ADD      r5,r3,#0x800
000058  6115              STR      r5,[r2,#0x10]
;;;284        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;285      
;;;286      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
00005a  2100              MOVS     r1,#0
00005c  e010              B        |L26.128|
                  |L26.94|
;;;287      {
;;;288        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
00005e  f5036510          ADD      r5,r3,#0x900
000062  eb051641          ADD      r6,r5,r1,LSL #5
000066  f1020518          ADD      r5,r2,#0x18
00006a  f8456021          STR      r6,[r5,r1,LSL #2]
;;;289          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;290            (i * USB_OTG_EP_REG_OFFSET));
;;;291        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
00006e  f5036530          ADD      r5,r3,#0xb00
000072  eb051641          ADD      r6,r5,r1,LSL #5
000076  f1020554          ADD      r5,r2,#0x54
00007a  f8456021          STR      r6,[r5,r1,LSL #2]
00007e  1c49              ADDS     r1,r1,#1              ;286
                  |L26.128|
000080  7855              LDRB     r5,[r2,#1]            ;286
000082  428d              CMP      r5,r1                 ;286
000084  d8eb              BHI      |L26.94|
;;;292          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;293            (i * USB_OTG_EP_REG_OFFSET));
;;;294      }
;;;295      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
000086  f5036580          ADD      r5,r3,#0x400
00008a  6155              STR      r5,[r2,#0x14]
;;;296        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;297      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
00008c  3540              ADDS     r5,r5,#0x40
00008e  f8c250cc          STR      r5,[r2,#0xcc]
;;;298      
;;;299      for (i = 0; i < pdev->cfg.host_channels; i++)
000092  2100              MOVS     r1,#0
000094  e008              B        |L26.168|
                  |L26.150|
;;;300      {
;;;301        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
000096  f50365a0          ADD      r5,r3,#0x500
00009a  eb051641          ADD      r6,r5,r1,LSL #5
00009e  f1020590          ADD      r5,r2,#0x90
0000a2  f8456021          STR      r6,[r5,r1,LSL #2]
0000a6  1c49              ADDS     r1,r1,#1              ;299
                  |L26.168|
0000a8  7815              LDRB     r5,[r2,#0]            ;299
0000aa  428d              CMP      r5,r1                 ;299
0000ac  d8f3              BHI      |L26.150|
;;;302          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;303            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;304      }
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
0000ae  2100              MOVS     r1,#0
0000b0  e008              B        |L26.196|
                  |L26.178|
;;;306      {
;;;307        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
0000b2  f5035580          ADD      r5,r3,#0x1000
0000b6  eb053601          ADD      r6,r5,r1,LSL #12
0000ba  f10205d0          ADD      r5,r2,#0xd0
0000be  f8456021          STR      r6,[r5,r1,LSL #2]
0000c2  1c49              ADDS     r1,r1,#1              ;305
                  |L26.196|
0000c4  7815              LDRB     r5,[r2,#0]            ;305
0000c6  428d              CMP      r5,r1                 ;305
0000c8  d8f3              BHI      |L26.178|
;;;308          (i * USB_OTG_DATA_FIFO_SIZE));
;;;309      }
;;;310      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000ca  f5036560          ADD      r5,r3,#0xe00
0000ce  f8c2510c          STR      r5,[r2,#0x10c]
;;;311      
;;;312      return status;
;;;313    }
0000d2  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

                  |L26.212|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;523    */
;;;524    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b5f8              PUSH     {r3-r7,lr}
;;;525    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;526      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;527      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;528      
;;;529      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000008  68e0              LDR      r0,[r4,#0xc]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  9000              STR      r0,[sp,#0]
;;;530      
;;;531      usbcfg.b.force_host = 0;
00000e  9800              LDR      r0,[sp,#0]
000010  f0205000          BIC      r0,r0,#0x20000000
000014  9000              STR      r0,[sp,#0]
;;;532      usbcfg.b.force_dev = 0;
000016  9800              LDR      r0,[sp,#0]
000018  f0204080          BIC      r0,r0,#0x40000000
00001c  9000              STR      r0,[sp,#0]
;;;533      
;;;534      if ( mode == HOST_MODE)
00001e  2d01              CMP      r5,#1
000020  d106              BNE      |L27.48|
;;;535      {
;;;536        usbcfg.b.force_host = 1;
000022  9800              LDR      r0,[sp,#0]
000024  f0205000          BIC      r0,r0,#0x20000000
000028  f1005000          ADD      r0,r0,#0x20000000
00002c  9000              STR      r0,[sp,#0]
00002e  e006              B        |L27.62|
                  |L27.48|
;;;537      }
;;;538      else if ( mode == DEVICE_MODE)
000030  b92d              CBNZ     r5,|L27.62|
;;;539      {
;;;540        usbcfg.b.force_dev = 1;
000032  9800              LDR      r0,[sp,#0]
000034  f0204080          BIC      r0,r0,#0x40000000
000038  f1004080          ADD      r0,r0,#0x40000000
00003c  9000              STR      r0,[sp,#0]
                  |L27.62|
;;;541      }
;;;542      
;;;543      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00003e  9800              LDR      r0,[sp,#0]
000040  68e1              LDR      r1,[r4,#0xc]
000042  60c8              STR      r0,[r1,#0xc]
;;;544      USB_OTG_BSP_mDelay(50);
000044  2032              MOVS     r0,#0x32
000046  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;545      return status;
00004a  4630              MOV      r0,r6
;;;546    }
00004c  bdf8              POP      {r3-r7,pc}
;;;547    
                          ENDP


                          AREA ||i.USB_OTG_StopHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopHost PROC
;;;1145   */
;;;1146   void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;1147   {
000002  4604              MOV      r4,r0
;;;1148     USB_OTG_HCCHAR_TypeDef  hcchar;
;;;1149     uint32_t                i;
;;;1150     
;;;1151     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
000004  2100              MOVS     r1,#0
000006  6960              LDR      r0,[r4,#0x14]
000008  6181              STR      r1,[r0,#0x18]
;;;1152     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
00000a  1e49              SUBS     r1,r1,#1
00000c  6960              LDR      r0,[r4,#0x14]
00000e  6141              STR      r1,[r0,#0x14]
;;;1153     /* Flush out any leftover queued requests. */
;;;1154     
;;;1155     for (i = 0; i < pdev->cfg.host_channels; i++)
000010  2500              MOVS     r5,#0
000012  e01a              B        |L28.74|
                  |L28.20|
;;;1156     {
;;;1157       hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
000014  f1040090          ADD      r0,r4,#0x90
000018  f8500025          LDR      r0,[r0,r5,LSL #2]
00001c  6800              LDR      r0,[r0,#0]
00001e  9000              STR      r0,[sp,#0]
;;;1158       hcchar.b.chen = 0;
000020  9800              LDR      r0,[sp,#0]
000022  f0204000          BIC      r0,r0,#0x80000000
000026  9000              STR      r0,[sp,#0]
;;;1159       hcchar.b.chdis = 1;
000028  9800              LDR      r0,[sp,#0]
00002a  f0204080          BIC      r0,r0,#0x40000000
00002e  f1004080          ADD      r0,r0,#0x40000000
000032  9000              STR      r0,[sp,#0]
;;;1160       hcchar.b.epdir = 0;
000034  9800              LDR      r0,[sp,#0]
000036  f4204000          BIC      r0,r0,#0x8000
00003a  9000              STR      r0,[sp,#0]
;;;1161       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
00003c  f1040090          ADD      r0,r4,#0x90
000040  f8500025          LDR      r0,[r0,r5,LSL #2]
000044  9900              LDR      r1,[sp,#0]
000046  6001              STR      r1,[r0,#0]
000048  1c6d              ADDS     r5,r5,#1              ;1155
                  |L28.74|
00004a  7820              LDRB     r0,[r4,#0]            ;1155
00004c  42a8              CMP      r0,r5                 ;1155
00004e  d8e1              BHI      |L28.20|
;;;1162     }
;;;1163     
;;;1164     /* Flush the FIFO */
;;;1165     USB_OTG_FlushRxFifo(pdev);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1166     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
000056  2110              MOVS     r1,#0x10
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;1167   }
00005e  bd38              POP      {r3-r5,pc}
;;;1168   #endif
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
000004  4604              MOV      r4,r0
;;;173      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;174      if (pdev->cfg.dma_enable == 0)
000008  78e0              LDRB     r0,[r4,#3]
00000a  b9b0              CBNZ     r0,|L29.58|
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
00000c  2700              MOVS     r7,#0
00000e  2000              MOVS     r0,#0
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
000010  1cdd              ADDS     r5,r3,#3
000012  ea4f78e5          ASR      r8,r5,#31
000016  eb057898          ADD      r8,r5,r8,LSR #30
00001a  ea4f07a8          ASR      r7,r8,#2
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
00001e  f10405d0          ADD      r5,r4,#0xd0
000022  f855c022          LDR      r12,[r5,r2,LSL #2]
;;;181        for (i = 0; i < count32b; i++, src+=4)
000026  bf00              NOP      
000028  e004              B        |L29.52|
                  |L29.42|
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
00002a  680d              LDR      r5,[r1,#0]
00002c  f8cc5000          STR      r5,[r12,#0]
000030  1c40              ADDS     r0,r0,#1              ;181
000032  1d09              ADDS     r1,r1,#4              ;181
                  |L29.52|
000034  42b8              CMP      r0,r7                 ;181
000036  d3f8              BCC      |L29.42|
;;;184        }
;;;185      }
000038  bf00              NOP      
                  |L29.58|
;;;186      return status;
00003a  4630              MOV      r0,r6
;;;187    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;188    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_OTG_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 144
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
