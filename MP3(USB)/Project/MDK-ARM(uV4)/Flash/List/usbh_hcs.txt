; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usbh_hcs.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usbh_hcs.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usbh_hcs.crf ..\..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_hcs.c]
                          THUMB

                          AREA ||i.USBH_Alloc_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Alloc_Channel PROC
;;;173      */
;;;174    uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;176      uint16_t hc_num;
;;;177      
;;;178      hc_num =  USBH_GetFreeChannel(pdev);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       USBH_GetFreeChannel
00000c  4604              MOV      r4,r0
;;;179    
;;;180      if (hc_num != HC_ERROR)
00000e  f64f70ff          MOV      r0,#0xffff
000012  4284              CMP      r4,r0
000014  d005              BEQ      |L1.34|
;;;181      {
;;;182    	pdev->host.channel[hc_num] = HC_USED | ep_addr;
000016  f4464100          ORR      r1,r6,#0x8000
00001a  f205508c          ADD      r0,r5,#0x58c
00001e  f8201014          STRH     r1,[r0,r4,LSL #1]
                  |L1.34|
;;;183      }
;;;184      return hc_num;
000022  b2e0              UXTB     r0,r4
;;;185    }
000024  bd70              POP      {r4-r6,pc}
;;;186    
                          ENDP


                          AREA ||i.USBH_DeAllocate_AllChannel||, CODE, READONLY, ALIGN=1

                  USBH_DeAllocate_AllChannel PROC
;;;208      */
;;;209    uint8_t USBH_DeAllocate_AllChannel  (USB_OTG_CORE_HANDLE *pdev)
000000  4602              MOV      r2,r0
;;;210    {
;;;211       uint8_t idx;
;;;212       
;;;213       for (idx = 2; idx < HC_MAX ; idx ++)
000002  2102              MOVS     r1,#2
000004  e006              B        |L2.20|
                  |L2.6|
;;;214       {
;;;215    	 pdev->host.channel[idx] = 0;
000006  2300              MOVS     r3,#0
000008  f202508c          ADD      r0,r2,#0x58c
00000c  f8203011          STRH     r3,[r0,r1,LSL #1]
000010  1c48              ADDS     r0,r1,#1              ;213
000012  b2c1              UXTB     r1,r0                 ;213
                  |L2.20|
000014  2908              CMP      r1,#8                 ;213
000016  dbf6              BLT      |L2.6|
;;;216       }
;;;217       return USBH_OK;
000018  2000              MOVS     r0,#0
;;;218    }
00001a  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.USBH_Free_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Free_Channel PROC
;;;192      */
;;;193    uint8_t USBH_Free_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t idx)
000000  4602              MOV      r2,r0
;;;194    {
;;;195       if(idx < HC_MAX)
000002  2908              CMP      r1,#8
000004  da09              BGE      |L3.26|
;;;196       {
;;;197    	 pdev->host.channel[idx] &= HC_USED_MASK;
000006  f202508c          ADD      r0,r2,#0x58c
00000a  f8300011          LDRH     r0,[r0,r1,LSL #1]
00000e  f3c0030e          UBFX     r3,r0,#0,#15
000012  f202508c          ADD      r0,r2,#0x58c
000016  f8203011          STRH     r3,[r0,r1,LSL #1]
                  |L3.26|
;;;198       }
;;;199       return USBH_OK;
00001a  2000              MOVS     r0,#0
;;;200    }
00001c  4770              BX       lr
;;;201    
                          ENDP


                          AREA ||i.USBH_GetFreeChannel||, CODE, READONLY, ALIGN=1

                  USBH_GetFreeChannel PROC
;;;225      */
;;;226    static uint16_t USBH_GetFreeChannel (USB_OTG_CORE_HANDLE *pdev)
000000  4602              MOV      r2,r0
;;;227    {
;;;228      uint8_t idx = 0;
000002  2100              MOVS     r1,#0
;;;229      
;;;230      for (idx = 0 ; idx < HC_MAX ; idx++)
000004  bf00              NOP      
000006  e00a              B        |L4.30|
                  |L4.8|
;;;231      {
;;;232    	if ((pdev->host.channel[idx] & HC_USED) == 0)
000008  f202508c          ADD      r0,r2,#0x58c
00000c  f8300011          LDRH     r0,[r0,r1,LSL #1]
000010  f4004000          AND      r0,r0,#0x8000
000014  b908              CBNZ     r0,|L4.26|
;;;233    	{
;;;234    	   return idx;
000016  4608              MOV      r0,r1
                  |L4.24|
;;;235    	} 
;;;236      }
;;;237      return HC_ERROR;
;;;238    }
000018  4770              BX       lr
                  |L4.26|
00001a  1c48              ADDS     r0,r1,#1              ;230
00001c  b2c1              UXTB     r1,r0                 ;230
                  |L4.30|
00001e  2908              CMP      r1,#8                 ;230
000020  dbf2              BLT      |L4.8|
000022  f64f70ff          MOV      r0,#0xffff            ;237
000026  e7f7              B        |L4.24|
;;;239    
                          ENDP


                          AREA ||i.USBH_Modify_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Modify_Channel PROC
;;;139      */
;;;140    uint8_t USBH_Modify_Channel (USB_OTG_CORE_HANDLE *pdev,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;141                                uint8_t hc_num,
;;;142                                uint8_t dev_address,
;;;143                                uint8_t speed,
;;;144                                uint8_t ep_type,
;;;145                                uint16_t mps)
;;;146    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  e9dd9808          LDRD     r9,r8,[sp,#0x20]
;;;147      
;;;148      if(dev_address != 0)
000010  b127              CBZ      r7,|L5.28|
;;;149      {
;;;150        pdev->host.hc[hc_num].dev_addr = dev_address;  
000012  f504706b          ADD      r0,r4,#0x3ac
000016  eb001045          ADD      r0,r0,r5,LSL #5
00001a  7007              STRB     r7,[r0,#0]
                  |L5.28|
;;;151      }
;;;152      
;;;153      if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
00001c  f504706b          ADD      r0,r4,#0x3ac
000020  eb001045          ADD      r0,r0,r5,LSL #5
000024  88c0              LDRH     r0,[r0,#6]
000026  4540              CMP      r0,r8
000028  d008              BEQ      |L5.60|
00002a  f1b80f00          CMP      r8,#0
00002e  d005              BEQ      |L5.60|
;;;154      {
;;;155        pdev->host.hc[hc_num].max_packet = mps; 
000030  f504706b          ADD      r0,r4,#0x3ac
000034  eb001045          ADD      r0,r0,r5,LSL #5
000038  f8a08006          STRH     r8,[r0,#6]
                  |L5.60|
;;;156      }
;;;157      
;;;158      if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
00003c  f504706b          ADD      r0,r4,#0x3ac
000040  eb001045          ADD      r0,r0,r5,LSL #5
000044  78c0              LDRB     r0,[r0,#3]
000046  42b0              CMP      r0,r6
000048  d005              BEQ      |L5.86|
00004a  b126              CBZ      r6,|L5.86|
;;;159      {
;;;160        pdev->host.hc[hc_num].speed = speed; 
00004c  f504706b          ADD      r0,r4,#0x3ac
000050  eb001045          ADD      r0,r0,r5,LSL #5
000054  70c6              STRB     r6,[r0,#3]
                  |L5.86|
;;;161      }
;;;162      
;;;163      USB_OTG_HC_Init(pdev, hc_num);
000056  4629              MOV      r1,r5
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       USB_OTG_HC_Init
;;;164      return HC_OK; 
00005e  2000              MOVS     r0,#0
;;;165    
;;;166    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;167    
                          ENDP


                          AREA ||i.USBH_Open_Channel||, CODE, READONLY, ALIGN=1

                  USBH_Open_Channel PROC
;;;101      */
;;;102    uint8_t USBH_Open_Channel  (USB_OTG_CORE_HANDLE *pdev,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;103                                uint8_t hc_num,
;;;104                                uint8_t dev_address,
;;;105                                uint8_t speed,
;;;106                                uint8_t ep_type,
;;;107                                uint16_t mps)
;;;108    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;109    
;;;110      pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
000010  f204508c          ADD      r0,r4,#0x58c
000014  f8100015          LDRB     r0,[r0,r5,LSL #1]
000018  f000017f          AND      r1,r0,#0x7f
00001c  f504706b          ADD      r0,r4,#0x3ac
000020  eb001045          ADD      r0,r0,r5,LSL #5
000024  7041              STRB     r1,[r0,#1]
;;;111      pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
000026  f204508c          ADD      r0,r4,#0x58c
00002a  f8100015          LDRB     r0,[r0,r5,LSL #1]
00002e  f3c011c0          UBFX     r1,r0,#7,#1
000032  f504706b          ADD      r0,r4,#0x3ac
000036  eb001045          ADD      r0,r0,r5,LSL #5
00003a  7081              STRB     r1,[r0,#2]
;;;112      pdev->host.hc[hc_num].dev_addr = dev_address;  
00003c  f504706b          ADD      r0,r4,#0x3ac
000040  eb001045          ADD      r0,r0,r5,LSL #5
000044  7007              STRB     r7,[r0,#0]
;;;113      pdev->host.hc[hc_num].ep_type = ep_type;  
000046  f504706b          ADD      r0,r4,#0x3ac
00004a  eb001045          ADD      r0,r0,r5,LSL #5
00004e  f8808005          STRB     r8,[r0,#5]
;;;114      pdev->host.hc[hc_num].max_packet = mps; 
000052  f504706b          ADD      r0,r4,#0x3ac
000056  eb001045          ADD      r0,r0,r5,LSL #5
00005a  f8a09006          STRH     r9,[r0,#6]
;;;115      pdev->host.hc[hc_num].speed = speed; 
00005e  f504706b          ADD      r0,r4,#0x3ac
000062  eb001045          ADD      r0,r0,r5,LSL #5
000066  70c6              STRB     r6,[r0,#3]
;;;116      pdev->host.hc[hc_num].toggle_in = 0; 
000068  2100              MOVS     r1,#0
00006a  f504706b          ADD      r0,r4,#0x3ac
00006e  eb001045          ADD      r0,r0,r5,LSL #5
000072  7601              STRB     r1,[r0,#0x18]
;;;117      pdev->host.hc[hc_num].toggle_out = 0;   
000074  f504706b          ADD      r0,r4,#0x3ac
000078  eb001045          ADD      r0,r0,r5,LSL #5
00007c  7641              STRB     r1,[r0,#0x19]
;;;118      if(speed == HPRT0_PRTSPD_HIGH_SPEED)
00007e  b92e              CBNZ     r6,|L6.140|
;;;119      {
;;;120        pdev->host.hc[hc_num].do_ping = 1;
000080  2101              MOVS     r1,#1
000082  f504706b          ADD      r0,r4,#0x3ac
000086  eb001045          ADD      r0,r0,r5,LSL #5
00008a  7101              STRB     r1,[r0,#4]
                  |L6.140|
;;;121      }
;;;122      
;;;123      USB_OTG_HC_Init(pdev, hc_num) ;
00008c  4629              MOV      r1,r5
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       USB_OTG_HC_Init
;;;124      
;;;125      return HC_OK; 
000094  2000              MOVS     r0,#0
;;;126    
;;;127    }
000096  e8bd87f0          POP      {r4-r10,pc}
;;;128    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_hcs.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usbh_hcs_c_cb343afe____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usbh_hcs_c_cb343afe____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usbh_hcs_c_cb343afe____REVSH|
#line 144
|__asm___10_usbh_hcs_c_cb343afe____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
