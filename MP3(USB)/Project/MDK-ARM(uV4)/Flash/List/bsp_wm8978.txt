; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_wm8978.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_wm8978.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\bsp_wm8978.crf ..\..\User\bsp_stm32f4xx\src\bsp_wm8978.c]
                          THUMB

                          AREA ||i.I2S_CODEC_Init||, CODE, READONLY, ALIGN=2

                  I2S_CODEC_Init PROC
;;;932    */
;;;933    void I2S_CODEC_Init(void)
000000  b510              PUSH     {r4,lr}
;;;934    {
;;;935    	/* 配置I2S中断通道 */
;;;936    	I2S_NVIC_Config();
000002  f7fffffe          BL       I2S_NVIC_Config
;;;937    
;;;938    	/* 配置I2S2 GPIO口线 */
;;;939    	I2S_GPIO_Config();
000006  f7fffffe          BL       I2S_GPIO_Config
;;;940    
;;;941    	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;942    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
00000a  2200              MOVS     r2,#0
00000c  2171              MOVS     r1,#0x71
00000e  4804              LDR      r0,|L1.32|
000010  f7fffffe          BL       SPI_I2S_ITConfig
;;;943    
;;;944    	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;945    	SPI_I2S_ITConfig(I2S2ext, SPI_I2S_IT_RXNE, DISABLE);
000014  2200              MOVS     r2,#0
000016  2160              MOVS     r1,#0x60
000018  4802              LDR      r0,|L1.36|
00001a  f7fffffe          BL       SPI_I2S_ITConfig
;;;946    }
00001e  bd10              POP      {r4,pc}
;;;947    
                          ENDP

                  |L1.32|
                          DCD      0x40003800
                  |L1.36|
                          DCD      0x40003400

                          AREA ||i.I2S_GPIO_Config||, CODE, READONLY, ALIGN=2

                  I2S_GPIO_Config PROC
;;;1019   */
;;;1020   static void I2S_GPIO_Config(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;1021   {
;;;1022   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1023   
;;;1024   	/*
;;;1025   		安富莱STM32-V5开发板--- I2S总线传输音频数据口线
;;;1026   		PB12/I2S2_WS
;;;1027   		PB13/I2S2_CK
;;;1028   		PI2/I2S2ext_SD
;;;1029   		PC3/I2S2_SD
;;;1030   		PC6/I2S2_MCK
;;;1031   	*/
;;;1032   	/* 使能SPI2时钟 */
;;;1033   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000002  2101              MOVS     r1,#1
000004  0388              LSLS     r0,r1,#14
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1034   
;;;1035   	/* Enable GPIOI, GPIOB, GPIOC clock */
;;;1036   	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOI, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  f44f7083          MOV      r0,#0x106
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1037   
;;;1038   	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000014  2002              MOVS     r0,#2
000016  f88d0004          STRB     r0,[sp,#4]
;;;1039   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  f88d0005          STRB     r0,[sp,#5]
;;;1040   	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001e  2000              MOVS     r0,#0
000020  f88d0006          STRB     r0,[sp,#6]
;;;1041   	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000024  f88d0007          STRB     r0,[sp,#7]
;;;1042   
;;;1043   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13;
000028  f44f5040          MOV      r0,#0x3000
00002c  9000              STR      r0,[sp,#0]
;;;1044   	GPIO_Init(GPIOB, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4814              LDR      r0,|L2.132|
000032  f7fffffe          BL       GPIO_Init
;;;1045   
;;;1046   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_6;
000036  2048              MOVS     r0,#0x48
000038  9000              STR      r0,[sp,#0]
;;;1047   	GPIO_Init(GPIOC, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4812              LDR      r0,|L2.136|
00003e  f7fffffe          BL       GPIO_Init
;;;1048   
;;;1049   	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000042  2004              MOVS     r0,#4
000044  9000              STR      r0,[sp,#0]
;;;1050   	GPIO_Init(GPIOI, &GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  4810              LDR      r0,|L2.140|
00004a  f7fffffe          BL       GPIO_Init
;;;1051   
;;;1052   	/* Connect pins to I2S peripheral  */
;;;1053   	GPIO_PinAFConfig(GPIOB, GPIO_PinSource12, GPIO_AF_SPI2);
00004e  2205              MOVS     r2,#5
000050  210c              MOVS     r1,#0xc
000052  480c              LDR      r0,|L2.132|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;1054   	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
000058  2205              MOVS     r2,#5
00005a  210d              MOVS     r1,#0xd
00005c  4809              LDR      r0,|L2.132|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;1055   	GPIO_PinAFConfig(GPIOI, GPIO_PinSource2, GPIO_AF_SPI3);	/* 注意： PI2连接设置需要是 SPI3 */
000062  2206              MOVS     r2,#6
000064  2102              MOVS     r1,#2
000066  4809              LDR      r0,|L2.140|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;1056   	GPIO_PinAFConfig(GPIOC, GPIO_PinSource3, GPIO_AF_SPI2);
00006c  2205              MOVS     r2,#5
00006e  2103              MOVS     r1,#3
000070  4805              LDR      r0,|L2.136|
000072  f7fffffe          BL       GPIO_PinAFConfig
;;;1057   	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_SPI2);
000076  2205              MOVS     r2,#5
000078  2106              MOVS     r1,#6
00007a  4803              LDR      r0,|L2.136|
00007c  f7fffffe          BL       GPIO_PinAFConfig
;;;1058   }
000080  bd1c              POP      {r2-r4,pc}
;;;1059   
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      0x40020400
                  |L2.136|
                          DCD      0x40020800
                  |L2.140|
                          DCD      0x40022000

                          AREA ||i.I2S_Mode_Config||, CODE, READONLY, ALIGN=2

                  I2S_Mode_Config PROC
;;;1073   */
;;;1074   static void I2S_Mode_Config(uint16_t _usStandard, uint16_t _usWordLen, uint32_t _uiAudioFreq, uint16_t _usMode)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;1075   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;1076   	I2S_InitTypeDef I2S_InitStructure;
;;;1077   
;;;1078   	if ((_usMode == I2S_Mode_SlaveTx) && (_usMode == I2S_Mode_SlaveRx))
00000c  b924              CBNZ     r4,|L3.24|
00000e  f5b47f80          CMP      r4,#0x100
000012  d101              BNE      |L3.24|
                  |L3.20|
;;;1079   	{
;;;1080   		/* 安富莱开发板不支持这2种模式 */
;;;1081   		return;
;;;1082   	}
;;;1083   
;;;1084   	/*
;;;1085   		For I2S mode, make sure that either:
;;;1086   			- I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S),
;;;1087   			RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
;;;1088   	*/
;;;1089   	{
;;;1090   		uint32_t n = 0;
;;;1091   		FlagStatus status = RESET;
;;;1092   
;;;1093   		RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S);
;;;1094   		RCC_PLLI2SCmd(ENABLE);
;;;1095   
;;;1096   		for (n = 0; n < 500; n++)
;;;1097   		{
;;;1098   			status = RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY);
;;;1099   			if (status == 1)
;;;1100   			{
;;;1101   				break;
;;;1102   			}
;;;1103   		}
;;;1104   	}
;;;1105   
;;;1106   	/* 打开 I2S2 APB1 时钟 */
;;;1107   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
;;;1108   
;;;1109   	/* 复位 SPI2 外设到缺省状态 */
;;;1110   	SPI_I2S_DeInit(SPI2);
;;;1111   
;;;1112   	/* I2S2 外设配置 */
;;;1113   	//if (_usMode == I2S_Mode_MasterTx)
;;;1114   	{
;;;1115   		I2S_StructInit(&I2S_InitStructure);
;;;1116   		I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;			/* 配置I2S工作模式 */
;;;1117   		I2S_InitStructure.I2S_Standard = _usStandard;			/* 接口标准 */
;;;1118   		I2S_InitStructure.I2S_DataFormat = _usWordLen;			/* 数据格式，16bit */
;;;1119   		I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;	/* 主时钟模式 */
;;;1120   		I2S_InitStructure.I2S_AudioFreq = _uiAudioFreq;			/* 音频采样频率 */
;;;1121   		I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
;;;1122   		I2S_Init(SPI2, &I2S_InitStructure);
;;;1123   
;;;1124   		/* Configure the I2Sx_ext (the second instance) in Slave Receiver Mode */
;;;1125   		I2S_FullDuplexConfig(I2S2ext, &I2S_InitStructure);
;;;1126   
;;;1127   		/* 使能 SPI2/I2S2 外设 */
;;;1128   		I2S_Cmd(SPI2, ENABLE);
;;;1129   
;;;1130   		/* Enable the I2Sx_ext peripheral for Full Duplex mode */
;;;1131   		I2S_Cmd(I2S2ext, ENABLE);
;;;1132   	}
;;;1133   
;;;1134   	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;1135   	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
;;;1136   
;;;1137   	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;1138   	SPI_I2S_ITConfig(I2S2ext, SPI_I2S_IT_RXNE, DISABLE);
;;;1139   
;;;1140   #if 0		/* 这一段代码用于测试I2S双向传输功能 */
;;;1141   	while (1)
;;;1142   	{
;;;1143   		static uint16_t usData;
;;;1144   
;;;1145   		if (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == SET)
;;;1146   		{
;;;1147   			SPI_I2S_SendData(SPI2, 0x55);
;;;1148   		}
;;;1149   
;;;1150   		if (SPI_I2S_GetFlagStatus(I2S2ext, SPI_I2S_FLAG_RXNE) == SET)
;;;1151   		{
;;;1152   			usData = SPI_I2S_ReceiveData(I2S2ext);
;;;1153   
;;;1154   			printf("%02X ", usData);
;;;1155   		}
;;;1156   	}
;;;1157   #endif
;;;1158   }
000014  e8bd87ff          POP      {r0-r10,pc}
                  |L3.24|
000018  f04f0800          MOV      r8,#0                 ;1090
00001c  46c1              MOV      r9,r8                 ;1091
00001e  2000              MOVS     r0,#0                 ;1093
000020  f7fffffe          BL       RCC_I2SCLKConfig
000024  2001              MOVS     r0,#1                 ;1094
000026  f7fffffe          BL       RCC_PLLI2SCmd
00002a  bf00              NOP                            ;1096
00002c  e009              B        |L3.66|
                  |L3.46|
00002e  203b              MOVS     r0,#0x3b              ;1098
000030  f7fffffe          BL       RCC_GetFlagStatus
000034  4681              MOV      r9,r0                 ;1098
000036  f1b90f01          CMP      r9,#1                 ;1099
00003a  d100              BNE      |L3.62|
00003c  e004              B        |L3.72|
                  |L3.62|
00003e  f1080801          ADD      r8,r8,#1              ;1096
                  |L3.66|
000042  f5b87ffa          CMP      r8,#0x1f4             ;1096
000046  d3f2              BCC      |L3.46|
                  |L3.72|
000048  bf00              NOP                            ;1101
00004a  2101              MOVS     r1,#1                 ;1107
00004c  0388              LSLS     r0,r1,#14             ;1107
00004e  f7fffffe          BL       RCC_APB1PeriphClockCmd
000052  4818              LDR      r0,|L3.180|
000054  f7fffffe          BL       SPI_I2S_DeInit
000058  4668              MOV      r0,sp                 ;1115
00005a  f7fffffe          BL       I2S_StructInit
00005e  f44f7000          MOV      r0,#0x200             ;1116
000062  f8ad0000          STRH     r0,[sp,#0]            ;1116
000066  f8ad5002          STRH     r5,[sp,#2]            ;1117
00006a  f8ad6004          STRH     r6,[sp,#4]            ;1118
00006e  f8ad0006          STRH     r0,[sp,#6]            ;1119
000072  9702              STR      r7,[sp,#8]            ;1120
000074  2000              MOVS     r0,#0                 ;1121
000076  f8ad000c          STRH     r0,[sp,#0xc]          ;1121
00007a  4669              MOV      r1,sp                 ;1122
00007c  480d              LDR      r0,|L3.180|
00007e  f7fffffe          BL       I2S_Init
000082  4669              MOV      r1,sp                 ;1125
000084  480c              LDR      r0,|L3.184|
000086  f7fffffe          BL       I2S_FullDuplexConfig
00008a  2101              MOVS     r1,#1                 ;1128
00008c  4809              LDR      r0,|L3.180|
00008e  f7fffffe          BL       I2S_Cmd
000092  2101              MOVS     r1,#1                 ;1131
000094  4808              LDR      r0,|L3.184|
000096  f7fffffe          BL       I2S_Cmd
00009a  2200              MOVS     r2,#0                 ;1135
00009c  2171              MOVS     r1,#0x71              ;1135
00009e  4805              LDR      r0,|L3.180|
0000a0  f7fffffe          BL       SPI_I2S_ITConfig
0000a4  2200              MOVS     r2,#0                 ;1138
0000a6  2160              MOVS     r1,#0x60              ;1138
0000a8  4803              LDR      r0,|L3.184|
0000aa  f7fffffe          BL       SPI_I2S_ITConfig
0000ae  bf00              NOP      
0000b0  e7b0              B        |L3.20|
;;;1159   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L3.180|
                          DCD      0x40003800
                  |L3.184|
                          DCD      0x40003400

                          AREA ||i.I2S_NVIC_Config||, CODE, READONLY, ALIGN=1

                  I2S_NVIC_Config PROC
;;;1167   */
;;;1168   static void I2S_NVIC_Config(void)
000000  b508              PUSH     {r3,lr}
;;;1169   {
;;;1170   	NVIC_InitTypeDef NVIC_InitStructure;
;;;1171   
;;;1172   	/* SPI2 IRQ 通道配置 */
;;;1173   	NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
000002  2024              MOVS     r0,#0x24
000004  f88d0000          STRB     r0,[sp,#0]
;;;1174   	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;1175   	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  f88d0002          STRB     r0,[sp,#2]
;;;1176   	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000012  2001              MOVS     r0,#1
000014  f88d0003          STRB     r0,[sp,#3]
;;;1177   	NVIC_Init(&NVIC_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;1178   }
00001e  bd08              POP      {r3,pc}
;;;1179   
                          ENDP


                          AREA ||i.I2S_StartPlay||, CODE, READONLY, ALIGN=2

                  I2S_StartPlay PROC
;;;958    */
;;;959    void I2S_StartPlay(uint16_t _usStandard, uint16_t _usWordLen,  uint32_t _uiAudioFreq)
000000  b570              PUSH     {r4-r6,lr}
;;;960    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;961    	/* 配置I2S为主发送模式，即STM32提供主时钟，I2S数据口是发送方向(放音) */
;;;962    	I2S_Mode_Config(_usStandard, _usWordLen, _uiAudioFreq, I2S_Mode_MasterTx);
000008  f44f7300          MOV      r3,#0x200
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2S_Mode_Config
;;;963    
;;;964    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, ENABLE);		/* 使能发送中断 */
000016  2201              MOVS     r2,#1
000018  2171              MOVS     r1,#0x71
00001a  4802              LDR      r0,|L5.36|
00001c  f7fffffe          BL       SPI_I2S_ITConfig
;;;965    }
000020  bd70              POP      {r4-r6,pc}
;;;966    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40003800

                          AREA ||i.I2S_StartRecord||, CODE, READONLY, ALIGN=2

                  I2S_StartRecord PROC
;;;977    */
;;;978    void I2S_StartRecord(uint16_t _usStandard, uint16_t _usWordLen, uint32_t _uiAudioFreq)
000000  b570              PUSH     {r4-r6,lr}
;;;979    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;980    	/* 配置I2S为主发送模式，即STM32提供主时钟，I2S数据口是发送方向(放音) */
;;;981    	I2S_Mode_Config(_usStandard, _usWordLen, _uiAudioFreq, I2S_Mode_MasterTx);
000008  f44f7300          MOV      r3,#0x200
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2S_Mode_Config
;;;982    	SPI_I2S_ITConfig(I2S2ext, SPI_I2S_IT_RXNE, ENABLE);		/* 使能接收中断 */
000016  2201              MOVS     r2,#1
000018  2160              MOVS     r1,#0x60
00001a  4806              LDR      r0,|L6.52|
00001c  f7fffffe          BL       SPI_I2S_ITConfig
;;;983    
;;;984    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, ENABLE);		/* 使能发送中断 */
000020  2201              MOVS     r2,#1
000022  2171              MOVS     r1,#0x71
000024  4804              LDR      r0,|L6.56|
000026  f7fffffe          BL       SPI_I2S_ITConfig
;;;985    	SPI_I2S_SendData(SPI2, 0);
00002a  2100              MOVS     r1,#0
00002c  4802              LDR      r0,|L6.56|
00002e  f7fffffe          BL       SPI_I2S_SendData
;;;986    }
000032  bd70              POP      {r4-r6,pc}
;;;987    
                          ENDP

                  |L6.52|
                          DCD      0x40003400
                  |L6.56|
                          DCD      0x40003800

                          AREA ||i.I2S_Stop||, CODE, READONLY, ALIGN=2

                  I2S_Stop PROC
;;;995    */
;;;996    void I2S_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;997    {
;;;998    	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;999    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
000002  2200              MOVS     r2,#0
000004  2171              MOVS     r1,#0x71
000006  4808              LDR      r0,|L7.40|
000008  f7fffffe          BL       SPI_I2S_ITConfig
;;;1000   
;;;1001   	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;1002   	SPI_I2S_ITConfig(I2S2ext, SPI_I2S_IT_RXNE, DISABLE);
00000c  2200              MOVS     r2,#0
00000e  2160              MOVS     r1,#0x60
000010  4806              LDR      r0,|L7.44|
000012  f7fffffe          BL       SPI_I2S_ITConfig
;;;1003   
;;;1004   	/* 禁能 SPI2/I2S2 外设 */
;;;1005   	I2S_Cmd(SPI2, DISABLE);
000016  2100              MOVS     r1,#0
000018  4803              LDR      r0,|L7.40|
00001a  f7fffffe          BL       I2S_Cmd
;;;1006   
;;;1007   	/* 关闭 I2S2 APB1 时钟 */
;;;1008   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0388              LSLS     r0,r1,#14
000022  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1009   }
000026  bd10              POP      {r4,pc}
;;;1010   
                          ENDP

                  |L7.40|
                          DCD      0x40003800
                  |L7.44|
                          DCD      0x40003400

                          AREA ||i.wm8978_CfgAudioIF||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioIF PROC
;;;331    */
;;;332    void wm8978_CfgAudioIF(uint16_t _usStandard, uint8_t _ucWordLen)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;334    	uint16_t usReg;
;;;335    
;;;336    	/* pdf 67页，寄存器列表 */
;;;337    
;;;338    	/*	REG R4, 音频接口控制寄存器
;;;339    		B8		BCP	 = X, BCLK极性，0表示正常，1表示反相
;;;340    		B7		LRCP = x, LRC时钟极性，0表示正常，1表示反相
;;;341    		B6:5	WL = x， 字长，00=16bit，01=20bit，10=24bit，11=32bit （右对齐模式只能操作在最大24bit)
;;;342    		B4:3	FMT = x，音频数据格式，00=右对齐，01=左对齐，10=I2S格式，11=PCM
;;;343    		B2		DACLRSWAP = x, 控制DAC数据出现在LRC时钟的左边还是右边
;;;344    		B1 		ADCLRSWAP = x，控制ADC数据出现在LRC时钟的左边还是右边
;;;345    		B0		MONO	= 0，0表示立体声，1表示单声道，仅左声道有效
;;;346    	*/
;;;347    	usReg = 0;
000006  2400              MOVS     r4,#0
;;;348    	if (_usStandard == I2S_Standard_Phillips)	/* I2S飞利浦标准 */
000008  b915              CBNZ     r5,|L8.16|
;;;349    	{
;;;350    		usReg |= (2 << 3);
00000a  f0440410          ORR      r4,r4,#0x10
00000e  e009              B        |L8.36|
                  |L8.16|
;;;351    	}
;;;352    	else if (_usStandard == I2S_Standard_MSB)	/* MSB对齐标准(左对齐) */
000010  2d10              CMP      r5,#0x10
000012  d102              BNE      |L8.26|
;;;353    	{
;;;354    		usReg |= (1 << 3);
000014  f0440408          ORR      r4,r4,#8
000018  e004              B        |L8.36|
                  |L8.26|
;;;355    	}
;;;356    	else if (_usStandard == I2S_Standard_LSB)	/* LSB对齐标准(右对齐) */
00001a  2d20              CMP      r5,#0x20
00001c  d100              BNE      |L8.32|
;;;357    	{
;;;358    		usReg |= (0 << 3);
00001e  e001              B        |L8.36|
                  |L8.32|
;;;359    	}
;;;360    	else	/* PCM标准(16位通道帧上带长或短帧同步或者16位数据帧扩展为32位通道帧) */
;;;361    	{
;;;362    		usReg |= (3 << 3);;
000020  f0440418          ORR      r4,r4,#0x18
                  |L8.36|
;;;363    	}
;;;364    
;;;365    	if (_ucWordLen == 24)
000024  2e18              CMP      r6,#0x18
000026  d102              BNE      |L8.46|
;;;366    	{
;;;367    		usReg |= (2 << 5);
000028  f0440440          ORR      r4,r4,#0x40
00002c  e005              B        |L8.58|
                  |L8.46|
;;;368    	}
;;;369    	else if (_ucWordLen == 32)
00002e  2e20              CMP      r6,#0x20
000030  d102              BNE      |L8.56|
;;;370    	{
;;;371    		usReg |= (3 << 5);
000032  f0440460          ORR      r4,r4,#0x60
000036  e000              B        |L8.58|
                  |L8.56|
;;;372    	}
;;;373    	else
;;;374    	{
;;;375    		usReg |= (0 << 5);		/* 16bit */
000038  bf00              NOP      
                  |L8.58|
;;;376    	}
;;;377    	wm8978_WriteReg(4, usReg);
00003a  4621              MOV      r1,r4
00003c  2004              MOVS     r0,#4
00003e  f7fffffe          BL       wm8978_WriteReg
;;;378    
;;;379    	/* R5  pdf 57页 */
;;;380    
;;;381    
;;;382    	/*
;;;383    		R6，时钟产生控制寄存器
;;;384    		MS = 0,  WM8978被动时钟，由MCU提供MCLK时钟
;;;385    	*/
;;;386    	wm8978_WriteReg(6, 0x000);
000042  2100              MOVS     r1,#0
000044  2006              MOVS     r0,#6
000046  f7fffffe          BL       wm8978_WriteReg
;;;387    }
00004a  bd70              POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.wm8978_CfgAudioPath||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioPath PROC
;;;464    */
;;;465    void wm8978_CfgAudioPath(uint16_t _InPath, uint16_t _OutPath)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;467    	uint16_t usReg;
;;;468    
;;;469    	/* 查看WM8978数据手册的 REGISTER MAP 章节， 第67页 */
;;;470    
;;;471    	if ((_InPath == IN_PATH_OFF) && (_OutPath == OUT_PATH_OFF))
000006  b91d              CBNZ     r5,|L9.16|
000008  b916              CBNZ     r6,|L9.16|
;;;472    	{
;;;473    		wm8978_PowerDown();
00000a  f7fffffe          BL       wm8978_PowerDown
                  |L9.14|
;;;474    		return;
;;;475    	}
;;;476    
;;;477    	/* --------------------------- 第1步：根据输入通道参数配置寄存器 -----------------------*/
;;;478    	/*
;;;479    		R1 寄存器 Power manage 1
;;;480    		Bit8    BUFDCOPEN,  Output stage 1.5xAVDD/2 driver enable
;;;481     		Bit7    OUT4MIXEN, OUT4 mixer enable
;;;482    		Bit6    OUT3MIXEN, OUT3 mixer enable
;;;483    		Bit5    PLLEN	.不用
;;;484    		Bit4    MICBEN	,Microphone Bias Enable (MIC偏置电路使能)
;;;485    		Bit3    BIASEN	,Analogue amplifier bias control 必须设置为1模拟放大器才工作
;;;486    		Bit2    BUFIOEN , Unused input/output tie off buffer enable
;;;487    		Bit1:0  VMIDSEL, 必须设置为非00值模拟放大器才工作
;;;488    	*/
;;;489    	usReg = (1 << 3) | (3 << 0);
;;;490    	if (_OutPath & OUT3_4_ON) 	/* OUT3和OUT4使能输出到GSM模块 */
;;;491    	{
;;;492    		usReg |= ((1 << 7) | (1 << 6));
;;;493    	}
;;;494    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
;;;495    	{
;;;496    		usReg |= (1 << 4);
;;;497    	}
;;;498    	wm8978_WriteReg(1, usReg);	/* 写寄存器 */
;;;499    
;;;500    	/*
;;;501    		R2 寄存器 Power manage 2
;;;502    		Bit8	ROUT1EN,	ROUT1 output enable 耳机右声道输出使能
;;;503    		Bit7	LOUT1EN,	LOUT1 output enable 耳机左声道输出使能
;;;504    		Bit6	SLEEP, 		0 = Normal device operation   1 = Residual current reduced in device standby mode
;;;505    		Bit5	BOOSTENR,	Right channel Input BOOST enable 输入通道自举电路使能. 用到PGA放大功能时必须使能
;;;506    		Bit4	BOOSTENL,	Left channel Input BOOST enable
;;;507    		Bit3	INPGAENR,	Right channel input PGA enable 右声道输入PGA使能
;;;508    		Bit2	INPGAENL,	Left channel input PGA enable
;;;509    		Bit1	ADCENR,		Enable ADC right channel
;;;510    		Bit0	ADCENL,		Enable ADC left channel
;;;511    	*/
;;;512    	usReg = 0;
;;;513    	if (_OutPath & EAR_LEFT_ON)
;;;514    	{
;;;515    		usReg |= (1 << 7);
;;;516    	}
;;;517    	if (_OutPath & EAR_RIGHT_ON)
;;;518    	{
;;;519    		usReg |= (1 << 8);
;;;520    	}
;;;521    	if (_InPath & MIC_LEFT_ON)
;;;522    	{
;;;523    		usReg |= ((1 << 4) | (1 << 2));
;;;524    	}
;;;525    	if (_InPath & MIC_RIGHT_ON)
;;;526    	{
;;;527    		usReg |= ((1 << 5) | (1 << 3));
;;;528    	}
;;;529    	if (_InPath & LINE_ON)
;;;530    	{
;;;531    		usReg |= ((1 << 4) | (1 << 5));
;;;532    	}
;;;533    	if (_InPath & MIC_RIGHT_ON)
;;;534    	{
;;;535    		usReg |= ((1 << 5) | (1 << 3));
;;;536    	}
;;;537    	if (_InPath & ADC_ON)
;;;538    	{
;;;539    		usReg |= ((1 << 1) | (1 << 0));
;;;540    	}
;;;541    	wm8978_WriteReg(2, usReg);	/* 写寄存器 */
;;;542    
;;;543    	/*
;;;544    		R3 寄存器 Power manage 3
;;;545    		Bit8	OUT4EN,		OUT4 enable
;;;546    		Bit7	OUT3EN,		OUT3 enable
;;;547    		Bit6	LOUT2EN,	LOUT2 output enable
;;;548    		Bit5	ROUT2EN,	ROUT2 output enable
;;;549    		Bit4	0,
;;;550    		Bit3	RMIXEN,		Right mixer enable
;;;551    		Bit2	LMIXEN,		Left mixer enable
;;;552    		Bit1	DACENR,		Right channel DAC enable
;;;553    		Bit0	DACENL,		Left channel DAC enable
;;;554    	*/
;;;555    	usReg = 0;
;;;556    	if (_OutPath & OUT3_4_ON)
;;;557    	{
;;;558    		usReg |= ((1 << 8) | (1 << 7));
;;;559    	}
;;;560    	if (_OutPath & SPK_ON)
;;;561    	{
;;;562    		usReg |= ((1 << 6) | (1 << 5));
;;;563    	}
;;;564    	if (_OutPath != OUT_PATH_OFF)
;;;565    	{
;;;566    		usReg |= ((1 << 3) | (1 << 2));
;;;567    	}
;;;568    	if (_InPath & DAC_ON)
;;;569    	{
;;;570    		usReg |= ((1 << 1) | (1 << 0));
;;;571    	}
;;;572    	wm8978_WriteReg(3, usReg);	/* 写寄存器 */
;;;573    
;;;574    	/*
;;;575    		R44 寄存器 Input ctrl
;;;576    
;;;577    		Bit8	MBVSEL, 		Microphone Bias Voltage Control   0 = 0.9 * AVDD   1 = 0.6 * AVDD
;;;578    		Bit7	0
;;;579    		Bit6	R2_2INPPGA,		Connect R2 pin to right channel input PGA positive terminal
;;;580    		Bit5	RIN2INPPGA,		Connect RIN pin to right channel input PGA negative terminal
;;;581    		Bit4	RIP2INPPGA,		Connect RIP pin to right channel input PGA amplifier positive terminal
;;;582    		Bit3	0
;;;583    		Bit2	L2_2INPPGA,		Connect L2 pin to left channel input PGA positive terminal
;;;584    		Bit1	LIN2INPPGA,		Connect LIN pin to left channel input PGA negative terminal
;;;585    		Bit0	LIP2INPPGA,		Connect LIP pin to left channel input PGA amplifier positive terminal
;;;586    	*/
;;;587    	usReg = 0 << 8;
;;;588    	if (_InPath & LINE_ON)
;;;589    	{
;;;590    		usReg |= ((1 << 6) | (1 << 2));
;;;591    	}
;;;592    	if (_InPath & MIC_RIGHT_ON)
;;;593    	{
;;;594    		usReg |= ((1 << 5) | (1 << 4));
;;;595    	}
;;;596    	if (_InPath & MIC_LEFT_ON)
;;;597    	{
;;;598    		usReg |= ((1 << 1) | (1 << 0));
;;;599    	}
;;;600    	wm8978_WriteReg(44, usReg);	/* 写寄存器 */
;;;601    
;;;602    
;;;603    	/*
;;;604    		R14 寄存器 ADC Control
;;;605    		设置高通滤波器（可选的） pdf 24、25页,
;;;606    		Bit8 	HPFEN,	High Pass Filter Enable高通滤波器使能，0表示禁止，1表示使能
;;;607    		BIt7 	HPFAPP,	Select audio mode or application mode 选择音频模式或应用模式，0表示音频模式，
;;;608    		Bit6:4	HPFCUT，Application mode cut-off frequency  000-111选择应用模式的截止频率
;;;609    		Bit3 	ADCOSR,	ADC oversample rate select: 0=64x (lower power) 1=128x (best performance)
;;;610    		Bit2   	0
;;;611    		Bit1 	ADC right channel polarity adjust:  0=normal  1=inverted
;;;612    		Bit0 	ADC left channel polarity adjust:  0=normal 1=inverted
;;;613    	*/
;;;614    	if (_InPath & ADC_ON)
;;;615    	{
;;;616    		usReg = (1 << 3) | (0 << 8) | (4 << 0);		/* 禁止ADC高通滤波器, 设置截至频率 */
;;;617    	}
;;;618    	else
;;;619    	{
;;;620    		usReg = 0;
;;;621    	}
;;;622    	wm8978_WriteReg(14, usReg);	/* 写寄存器 */
;;;623    
;;;624    	/* 设置陷波滤波器（notch filter），主要用于抑制话筒声波正反馈，避免啸叫.  暂时关闭
;;;625    		R27，R28，R29，R30 用于控制限波滤波器，pdf 26页
;;;626    		R7的 Bit7 NFEN = 0 表示禁止，1表示使能
;;;627    	*/
;;;628    	if (_InPath & ADC_ON)
;;;629    	{
;;;630    		usReg = (0 << 7);
;;;631    		wm8978_WriteReg(27, usReg);	/* 写寄存器 */
;;;632    		usReg = 0;
;;;633    		wm8978_WriteReg(28, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
;;;634    		wm8978_WriteReg(29, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
;;;635    		wm8978_WriteReg(30, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
;;;636    	}
;;;637    
;;;638    	/* 自动增益控制 ALC, R32  - 34  pdf 19页 */
;;;639    	{
;;;640    		usReg = 0;		/* 禁止自动增益控制 */
;;;641    		wm8978_WriteReg(32, usReg);
;;;642    		wm8978_WriteReg(33, usReg);
;;;643    		wm8978_WriteReg(34, usReg);
;;;644    	}
;;;645    
;;;646    	/*  R35  ALC Noise Gate Control
;;;647    		Bit3	NGATEN, Noise gate function enable
;;;648    		Bit2:0	Noise gate threshold:
;;;649    	*/
;;;650    	usReg = (3 << 1) | (7 << 0);		/* 禁止自动增益控制 */
;;;651    	wm8978_WriteReg(35, usReg);
;;;652    
;;;653    	/*
;;;654    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;655    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;656    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;657    	*/
;;;658    	/*	pdf 21页，R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;659    		R47 (R48定义与此相同)
;;;660    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;661    		B7		= 0， 保留
;;;662    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;663    		B3		= 0， 保留
;;;664    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;665    	*/
;;;666    	usReg = 0;
;;;667    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
;;;668    	{
;;;669    		usReg |= (1 << 8);	/* MIC增益取+20dB */
;;;670    	}
;;;671    	if (_InPath & AUX_ON)
;;;672    	{
;;;673    		usReg |= (3 << 0);	/* Aux增益固定取3，用户可以自行调整 */
;;;674    	}
;;;675    	if (_InPath & LINE_ON)
;;;676    	{
;;;677    		usReg |= (3 << 4);	/* Line增益固定取3，用户可以自行调整 */
;;;678    	}
;;;679    	wm8978_WriteReg(47, usReg);	/* 写左声道输入增益控制寄存器 */
;;;680    	wm8978_WriteReg(48, usReg);	/* 写右声道输入增益控制寄存器 */
;;;681    
;;;682    	/* 数字ADC音量控制，pdf 27页
;;;683    		R15 控制左声道ADC音量，R16控制右声道ADC音量
;;;684    		Bit8 	ADCVU  = 1 时才更新，用于同步更新左右声道的ADC音量
;;;685    		Bit7:0 	增益选择； 0000 0000 = 静音
;;;686    						   0000 0001 = -127dB
;;;687    						   0000 0010 = -12.5dB  （0.5dB 步长）
;;;688    						   1111 1111 = 0dB  （不衰减）
;;;689    	*/
;;;690    	usReg = 0xFF;
;;;691    	wm8978_WriteReg(15, usReg);	/* 选择0dB，先缓存左声道 */
;;;692    	usReg = 0x1FF;
;;;693    	wm8978_WriteReg(16, usReg);	/* 同步更新左右声道 */
;;;694    
;;;695    	/* 通过 wm8978_SetMicGain 函数设置mic PGA增益 */
;;;696    
;;;697    	/*	R43 寄存器  AUXR C ROUT2 BEEP Mixer Function
;;;698    		B8:6 = 0
;;;699    
;;;700    		B5	 MUTERPGA2INV,	Mute input to INVROUT2 mixer
;;;701    		B4	 INVROUT2,  Invert ROUT2 output 用于扬声器推挽输出
;;;702    		B3:1 BEEPVOL = 7;	AUXR input to ROUT2 inverter gain
;;;703    		B0	 BEEPEN = 1;	Enable AUXR beep input
;;;704    
;;;705    	*/
;;;706    	usReg = 0;
;;;707    	if (_OutPath & SPK_ON)
;;;708    	{
;;;709    		usReg |= (1 << 4);	/* ROUT2 反相, 用于驱动扬声器 */
;;;710    	}
;;;711    	if (_InPath & AUX_ON)
;;;712    	{
;;;713    		usReg |= ((7 << 1) | (1 << 0));
;;;714    	}
;;;715    	wm8978_WriteReg(43, usReg);
;;;716    
;;;717    	/* R49  Output ctrl
;;;718    		B8:7	0
;;;719    		B6		DACL2RMIX,	Left DAC output to right output mixer
;;;720    		B5		DACR2LMIX,	Right DAC output to left output
;;;721    		B4		OUT4BOOST,	0 = OUT4 output gain = -1; DC = AVDD / 2；1 = OUT4 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;722    		B3		OUT3BOOST,	0 = OUT3 output gain = -1; DC = AVDD / 2；1 = OUT3 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;723    		B2		SPKBOOST,	0 = Speaker gain = -1;  DC = AVDD / 2 ; 1 = Speaker gain = +1.5; DC = 1.5 x AVDD / 2
;;;724    		B1		TSDEN,   Thermal Shutdown Enable  扬声器热保护使能（缺省1）
;;;725    		B0		VROI,	Disabled Outputs to VREF Resistance
;;;726    	*/
;;;727    	usReg = 0;
;;;728    	if (_InPath & DAC_ON)
;;;729    	{
;;;730    		usReg |= ((1 << 6) | (1 << 5));
;;;731    	}
;;;732    	if (_OutPath & SPK_ON)
;;;733    	{
;;;734    		usReg |=  ((1 << 2) | (1 << 1));	/* SPK 1.5x增益,  热保护使能 */
;;;735    	}
;;;736    	if (_OutPath & OUT3_4_ON)
;;;737    	{
;;;738    		usReg |=  ((1 << 4) | (1 << 3));	/* BOOT3  BOOT4  1.5x增益 */
;;;739    	}
;;;740    	wm8978_WriteReg(49, usReg);
;;;741    
;;;742    	/*	REG 50    (50是左声道，51是右声道，配置寄存器功能一致) pdf 40页
;;;743    		B8:6	AUXLMIXVOL = 111	AUX用于FM收音机信号输入
;;;744    		B5		AUXL2LMIX = 1		Left Auxilliary input to left channel
;;;745    		B4:2	BYPLMIXVOL			音量
;;;746    		B1		BYPL2LMIX = 0;		Left bypass path (from the left channel input boost output) to left output mixer
;;;747    		B0		DACL2LMIX = 1;		Left DAC output to left output mixer
;;;748    	*/
;;;749    	usReg = 0;
;;;750    	if (_InPath & AUX_ON)
;;;751    	{
;;;752    		usReg |= ((7 << 6) | (1 << 5));
;;;753    	}
;;;754    	if ((_InPath & LINE_ON) || (_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
;;;755    	{
;;;756    		usReg |= ((7 << 2) | (1 << 1));
;;;757    	}
;;;758    	if (_InPath & DAC_ON)
;;;759    	{
;;;760    		usReg |= (1 << 0);
;;;761    	}
;;;762    	wm8978_WriteReg(50, usReg);
;;;763    	wm8978_WriteReg(51, usReg);
;;;764    
;;;765    	/*	R56 寄存器   OUT3 mixer ctrl
;;;766    		B8:7	0
;;;767    		B6		OUT3MUTE,  	0 = Output stage outputs OUT3 mixer;  1 = Output stage muted C drives out VMID.
;;;768    		B5:4	0
;;;769    		B3		BYPL2OUT3,	OUT4 mixer output to OUT3  (反相)
;;;770    		B4		0
;;;771    		B2		LMIX2OUT3,	Left ADC input to OUT3
;;;772    		B1		LDAC2OUT3,	Left DAC mixer to OUT3
;;;773    		B0		LDAC2OUT3,	Left DAC output to OUT3
;;;774    	*/
;;;775    	usReg = 0;
;;;776    	if (_OutPath & OUT3_4_ON)
;;;777    	{
;;;778    		usReg |= (1 << 3);
;;;779    	}
;;;780    	wm8978_WriteReg(56, usReg);
;;;781    
;;;782    	/* R57 寄存器		OUT4 (MONO) mixer ctrl
;;;783    		B8:7	0
;;;784    		B6		OUT4MUTE,	0 = Output stage outputs OUT4 mixer  1 = Output stage muted C drives outVMID.
;;;785    		B5		HALFSIG,	0 = OUT4 normal output	1 = OUT4 attenuated by 6dB
;;;786    		B4		LMIX2OUT4,	Left DAC mixer to OUT4
;;;787    		B3		LDAC2UT4,	Left DAC to OUT4
;;;788    		B2		BYPR2OUT4,	Right ADC input to OUT4
;;;789    		B1		RMIX2OUT4,	Right DAC mixer to OUT4
;;;790    		B0		RDAC2OUT4,	Right DAC output to OUT4
;;;791    	*/
;;;792    	usReg = 0;
;;;793    	if (_OutPath & OUT3_4_ON)
;;;794    	{
;;;795    		usReg |= ((1 << 4) |  (1 << 1));
;;;796    	}
;;;797    	wm8978_WriteReg(57, usReg);
;;;798    
;;;799    
;;;800    	/* R11, 12 寄存器 DAC数字音量
;;;801    		R11		Left DAC Digital Volume
;;;802    		R12		Right DAC Digital Volume
;;;803    	*/
;;;804    	if (_InPath & DAC_ON)
;;;805    	{
;;;806    		wm8978_WriteReg(11, 255);
;;;807    		wm8978_WriteReg(12, 255 | 0x100);
;;;808    	}
;;;809    	else
;;;810    	{
;;;811    		wm8978_WriteReg(11, 0);
;;;812    		wm8978_WriteReg(12, 0 | 0x100);
;;;813    	}
;;;814    
;;;815    	/*	R10 寄存器 DAC Control
;;;816    		B8	0
;;;817    		B7	0
;;;818    		B6	SOFTMUTE,	Softmute enable:
;;;819    		B5	0
;;;820    		B4	0
;;;821    		B3	DACOSR128,	DAC oversampling rate: 0=64x (lowest power) 1=128x (best performance)
;;;822    		B2	AMUTE,		Automute enable
;;;823    		B1	DACPOLR,	Right DAC output polarity
;;;824    		B0	DACPOLL,	Left DAC output polarity:
;;;825    	*/
;;;826    	if (_InPath & DAC_ON)
;;;827    	{
;;;828    		wm8978_WriteReg(10, 0);
;;;829    	}
;;;830    	;
;;;831    }
00000e  bd70              POP      {r4-r6,pc}
                  |L9.16|
000010  240b              MOVS     r4,#0xb               ;489
000012  f0060008          AND      r0,r6,#8              ;490
000016  b108              CBZ      r0,|L9.28|
000018  f04404c0          ORR      r4,r4,#0xc0           ;492
                  |L9.28|
00001c  f0050001          AND      r0,r5,#1              ;494
000020  b910              CBNZ     r0,|L9.40|
000022  f0050002          AND      r0,r5,#2              ;494
000026  b108              CBZ      r0,|L9.44|
                  |L9.40|
000028  f0440410          ORR      r4,r4,#0x10           ;496
                  |L9.44|
00002c  4621              MOV      r1,r4                 ;498
00002e  2001              MOVS     r0,#1                 ;498
000030  f7fffffe          BL       wm8978_WriteReg
000034  2400              MOVS     r4,#0                 ;512
000036  f0060001          AND      r0,r6,#1              ;513
00003a  b108              CBZ      r0,|L9.64|
00003c  f0440480          ORR      r4,r4,#0x80           ;515
                  |L9.64|
000040  f0060002          AND      r0,r6,#2              ;517
000044  b108              CBZ      r0,|L9.74|
000046  f4447480          ORR      r4,r4,#0x100          ;519
                  |L9.74|
00004a  f0050001          AND      r0,r5,#1              ;521
00004e  b108              CBZ      r0,|L9.84|
000050  f0440414          ORR      r4,r4,#0x14           ;523
                  |L9.84|
000054  f0050002          AND      r0,r5,#2              ;525
000058  b108              CBZ      r0,|L9.94|
00005a  f0440428          ORR      r4,r4,#0x28           ;527
                  |L9.94|
00005e  f0050004          AND      r0,r5,#4              ;529
000062  b108              CBZ      r0,|L9.104|
000064  f0440430          ORR      r4,r4,#0x30           ;531
                  |L9.104|
000068  f0050002          AND      r0,r5,#2              ;533
00006c  b108              CBZ      r0,|L9.114|
00006e  f0440428          ORR      r4,r4,#0x28           ;535
                  |L9.114|
000072  f0050020          AND      r0,r5,#0x20           ;537
000076  b108              CBZ      r0,|L9.124|
000078  f0440403          ORR      r4,r4,#3              ;539
                  |L9.124|
00007c  4621              MOV      r1,r4                 ;541
00007e  2002              MOVS     r0,#2                 ;541
000080  f7fffffe          BL       wm8978_WriteReg
000084  2400              MOVS     r4,#0                 ;555
000086  f0060008          AND      r0,r6,#8              ;556
00008a  b108              CBZ      r0,|L9.144|
00008c  f44474c0          ORR      r4,r4,#0x180          ;558
                  |L9.144|
000090  f0060004          AND      r0,r6,#4              ;560
000094  b108              CBZ      r0,|L9.154|
000096  f0440460          ORR      r4,r4,#0x60           ;562
                  |L9.154|
00009a  b10e              CBZ      r6,|L9.160|
00009c  f044040c          ORR      r4,r4,#0xc            ;566
                  |L9.160|
0000a0  f0050010          AND      r0,r5,#0x10           ;568
0000a4  b108              CBZ      r0,|L9.170|
0000a6  f0440403          ORR      r4,r4,#3              ;570
                  |L9.170|
0000aa  4621              MOV      r1,r4                 ;572
0000ac  2003              MOVS     r0,#3                 ;572
0000ae  f7fffffe          BL       wm8978_WriteReg
0000b2  2400              MOVS     r4,#0                 ;587
0000b4  f0050004          AND      r0,r5,#4              ;588
0000b8  b108              CBZ      r0,|L9.190|
0000ba  f0440444          ORR      r4,r4,#0x44           ;590
                  |L9.190|
0000be  f0050002          AND      r0,r5,#2              ;592
0000c2  b108              CBZ      r0,|L9.200|
0000c4  f0440430          ORR      r4,r4,#0x30           ;594
                  |L9.200|
0000c8  f0050001          AND      r0,r5,#1              ;596
0000cc  b108              CBZ      r0,|L9.210|
0000ce  f0440403          ORR      r4,r4,#3              ;598
                  |L9.210|
0000d2  4621              MOV      r1,r4                 ;600
0000d4  202c              MOVS     r0,#0x2c              ;600
0000d6  f7fffffe          BL       wm8978_WriteReg
0000da  f0050020          AND      r0,r5,#0x20           ;614
0000de  b108              CBZ      r0,|L9.228|
0000e0  240c              MOVS     r4,#0xc               ;616
0000e2  e000              B        |L9.230|
                  |L9.228|
0000e4  2400              MOVS     r4,#0                 ;620
                  |L9.230|
0000e6  4621              MOV      r1,r4                 ;622
0000e8  200e              MOVS     r0,#0xe               ;622
0000ea  f7fffffe          BL       wm8978_WriteReg
0000ee  f0050020          AND      r0,r5,#0x20           ;628
0000f2  b188              CBZ      r0,|L9.280|
0000f4  2400              MOVS     r4,#0                 ;630
0000f6  4621              MOV      r1,r4                 ;631
0000f8  201b              MOVS     r0,#0x1b              ;631
0000fa  f7fffffe          BL       wm8978_WriteReg
0000fe  bf00              NOP                            ;632
000100  4621              MOV      r1,r4                 ;633
000102  201c              MOVS     r0,#0x1c              ;633
000104  f7fffffe          BL       wm8978_WriteReg
000108  4621              MOV      r1,r4                 ;634
00010a  201d              MOVS     r0,#0x1d              ;634
00010c  f7fffffe          BL       wm8978_WriteReg
000110  4621              MOV      r1,r4                 ;635
000112  201e              MOVS     r0,#0x1e              ;635
000114  f7fffffe          BL       wm8978_WriteReg
                  |L9.280|
000118  2400              MOVS     r4,#0                 ;640
00011a  4621              MOV      r1,r4                 ;641
00011c  2020              MOVS     r0,#0x20              ;641
00011e  f7fffffe          BL       wm8978_WriteReg
000122  4621              MOV      r1,r4                 ;642
000124  2021              MOVS     r0,#0x21              ;642
000126  f7fffffe          BL       wm8978_WriteReg
00012a  4621              MOV      r1,r4                 ;643
00012c  2022              MOVS     r0,#0x22              ;643
00012e  f7fffffe          BL       wm8978_WriteReg
000132  2407              MOVS     r4,#7                 ;650
000134  4621              MOV      r1,r4                 ;651
000136  2023              MOVS     r0,#0x23              ;651
000138  f7fffffe          BL       wm8978_WriteReg
00013c  2400              MOVS     r4,#0                 ;666
00013e  f0050001          AND      r0,r5,#1              ;667
000142  b910              CBNZ     r0,|L9.330|
000144  f0050002          AND      r0,r5,#2              ;667
000148  b108              CBZ      r0,|L9.334|
                  |L9.330|
00014a  f4447480          ORR      r4,r4,#0x100          ;669
                  |L9.334|
00014e  f0050008          AND      r0,r5,#8              ;671
000152  b108              CBZ      r0,|L9.344|
000154  f0440403          ORR      r4,r4,#3              ;673
                  |L9.344|
000158  f0050004          AND      r0,r5,#4              ;675
00015c  b108              CBZ      r0,|L9.354|
00015e  f0440430          ORR      r4,r4,#0x30           ;677
                  |L9.354|
000162  4621              MOV      r1,r4                 ;679
000164  202f              MOVS     r0,#0x2f              ;679
000166  f7fffffe          BL       wm8978_WriteReg
00016a  4621              MOV      r1,r4                 ;680
00016c  2030              MOVS     r0,#0x30              ;680
00016e  f7fffffe          BL       wm8978_WriteReg
000172  24ff              MOVS     r4,#0xff              ;690
000174  4621              MOV      r1,r4                 ;691
000176  200f              MOVS     r0,#0xf               ;691
000178  f7fffffe          BL       wm8978_WriteReg
00017c  f24014ff          MOV      r4,#0x1ff             ;692
000180  4621              MOV      r1,r4                 ;693
000182  2010              MOVS     r0,#0x10              ;693
000184  f7fffffe          BL       wm8978_WriteReg
000188  2400              MOVS     r4,#0                 ;706
00018a  f0060004          AND      r0,r6,#4              ;707
00018e  b108              CBZ      r0,|L9.404|
000190  f0440410          ORR      r4,r4,#0x10           ;709
                  |L9.404|
000194  f0050008          AND      r0,r5,#8              ;711
000198  b108              CBZ      r0,|L9.414|
00019a  f044040f          ORR      r4,r4,#0xf            ;713
                  |L9.414|
00019e  4621              MOV      r1,r4                 ;715
0001a0  202b              MOVS     r0,#0x2b              ;715
0001a2  f7fffffe          BL       wm8978_WriteReg
0001a6  2400              MOVS     r4,#0                 ;727
0001a8  f0050010          AND      r0,r5,#0x10           ;728
0001ac  b108              CBZ      r0,|L9.434|
0001ae  f0440460          ORR      r4,r4,#0x60           ;730
                  |L9.434|
0001b2  f0060004          AND      r0,r6,#4              ;732
0001b6  b108              CBZ      r0,|L9.444|
0001b8  f0440406          ORR      r4,r4,#6              ;734
                  |L9.444|
0001bc  f0060008          AND      r0,r6,#8              ;736
0001c0  b108              CBZ      r0,|L9.454|
0001c2  f0440418          ORR      r4,r4,#0x18           ;738
                  |L9.454|
0001c6  4621              MOV      r1,r4                 ;740
0001c8  2031              MOVS     r0,#0x31              ;740
0001ca  f7fffffe          BL       wm8978_WriteReg
0001ce  2400              MOVS     r4,#0                 ;749
0001d0  f0050008          AND      r0,r5,#8              ;750
0001d4  b108              CBZ      r0,|L9.474|
0001d6  f44474f0          ORR      r4,r4,#0x1e0          ;752
                  |L9.474|
0001da  f0050004          AND      r0,r5,#4              ;754
0001de  b928              CBNZ     r0,|L9.492|
0001e0  f0050001          AND      r0,r5,#1              ;754
0001e4  b910              CBNZ     r0,|L9.492|
0001e6  f0050002          AND      r0,r5,#2              ;754
0001ea  b108              CBZ      r0,|L9.496|
                  |L9.492|
0001ec  f044041e          ORR      r4,r4,#0x1e           ;756
                  |L9.496|
0001f0  f0050010          AND      r0,r5,#0x10           ;758
0001f4  b108              CBZ      r0,|L9.506|
0001f6  f0440401          ORR      r4,r4,#1              ;760
                  |L9.506|
0001fa  4621              MOV      r1,r4                 ;762
0001fc  2032              MOVS     r0,#0x32              ;762
0001fe  f7fffffe          BL       wm8978_WriteReg
000202  4621              MOV      r1,r4                 ;763
000204  2033              MOVS     r0,#0x33              ;763
000206  f7fffffe          BL       wm8978_WriteReg
00020a  2400              MOVS     r4,#0                 ;775
00020c  f0060008          AND      r0,r6,#8              ;776
000210  b108              CBZ      r0,|L9.534|
000212  f0440408          ORR      r4,r4,#8              ;778
                  |L9.534|
000216  4621              MOV      r1,r4                 ;780
000218  2038              MOVS     r0,#0x38              ;780
00021a  f7fffffe          BL       wm8978_WriteReg
00021e  2400              MOVS     r4,#0                 ;792
000220  f0060008          AND      r0,r6,#8              ;793
000224  b108              CBZ      r0,|L9.554|
000226  f0440412          ORR      r4,r4,#0x12           ;795
                  |L9.554|
00022a  4621              MOV      r1,r4                 ;797
00022c  2039              MOVS     r0,#0x39              ;797
00022e  f7fffffe          BL       wm8978_WriteReg
000232  f0050010          AND      r0,r5,#0x10           ;804
000236  b148              CBZ      r0,|L9.588|
000238  21ff              MOVS     r1,#0xff              ;806
00023a  200b              MOVS     r0,#0xb               ;806
00023c  f7fffffe          BL       wm8978_WriteReg
000240  f24011ff          MOV      r1,#0x1ff             ;807
000244  200c              MOVS     r0,#0xc               ;807
000246  f7fffffe          BL       wm8978_WriteReg
00024a  e008              B        |L9.606|
                  |L9.588|
00024c  2100              MOVS     r1,#0                 ;811
00024e  200b              MOVS     r0,#0xb               ;811
000250  f7fffffe          BL       wm8978_WriteReg
000254  f44f7180          MOV      r1,#0x100             ;812
000258  200c              MOVS     r0,#0xc               ;812
00025a  f7fffffe          BL       wm8978_WriteReg
                  |L9.606|
00025e  f0050010          AND      r0,r5,#0x10           ;826
000262  b118              CBZ      r0,|L9.620|
000264  2100              MOVS     r1,#0                 ;828
000266  200a              MOVS     r0,#0xa               ;828
000268  f7fffffe          BL       wm8978_WriteReg
                  |L9.620|
00026c  bf00              NOP      
00026e  e6ce              B        |L9.14|
;;;832    
                          ENDP


                          AREA ||i.wm8978_CtrlGPIO1||, CODE, READONLY, ALIGN=1

                  wm8978_CtrlGPIO1 PROC
;;;871    */
;;;872    void wm8978_CtrlGPIO1(uint8_t _ucValue)
000000  b570              PUSH     {r4-r6,lr}
;;;873    {
000002  4605              MOV      r5,r0
;;;874    	uint16_t usRegValue;
;;;875    
;;;876    	/* R8， pdf 62页 */
;;;877    	if (_ucValue == 0) /* 输出0 */
000004  b90d              CBNZ     r5,|L10.10|
;;;878    	{
;;;879    		usRegValue = 6; /* B2:0 = 110 */
000006  2406              MOVS     r4,#6
000008  e000              B        |L10.12|
                  |L10.10|
;;;880    	}
;;;881    	else
;;;882    	{
;;;883    		usRegValue = 7; /* B2:0 = 111 */
00000a  2407              MOVS     r4,#7
                  |L10.12|
;;;884    	}
;;;885    	wm8978_WriteReg(8, usRegValue);
00000c  4621              MOV      r1,r4
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       wm8978_WriteReg
;;;886    }
000014  bd70              POP      {r4-r6,pc}
;;;887    
                          ENDP


                          AREA ||i.wm8978_Init||, CODE, READONLY, ALIGN=1

                  wm8978_Init PROC
;;;80     */
;;;81     uint8_t wm8978_Init(void)
000000  b510              PUSH     {r4,lr}
;;;82     {
;;;83     	uint8_t re;
;;;84     
;;;85     	if (i2c_CheckDevice(WM8978_SLAVE_ADDRESS) == 0)	/* 这个函数会配置STM32的GPIO用于软件模拟I2C时序 */
000002  2034              MOVS     r0,#0x34
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L11.14|
;;;86     	{
;;;87     		re = 1;
00000a  2401              MOVS     r4,#1
00000c  e000              B        |L11.16|
                  |L11.14|
;;;88     	}
;;;89     	else
;;;90     	{
;;;91     		re = 0;
00000e  2400              MOVS     r4,#0
                  |L11.16|
;;;92     	}
;;;93     	wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
000010  f7fffffe          BL       wm8978_Reset
;;;94     	return re;
000014  4620              MOV      r0,r4
;;;95     }
000016  bd10              POP      {r4,pc}
;;;96     
                          ENDP


                          AREA ||i.wm8978_NotchFilter||, CODE, READONLY, ALIGN=1

                  wm8978_NotchFilter PROC
;;;840    */
;;;841    void wm8978_NotchFilter(uint16_t _NFA0, uint16_t _NFA1)
000000  b570              PUSH     {r4-r6,lr}
;;;842    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;843    	uint16_t usReg;
;;;844    
;;;845    	/*  page 26
;;;846    		A programmable notch filter is provided. This filter has a variable centre frequency and bandwidth,
;;;847    		programmable via two coefficients, a0 and a1. a0 and a1 are represented by the register bits
;;;848    		NFA0[13:0] and NFA1[13:0]. Because these coefficient values require four register writes to setup
;;;849    		there is an NFU (Notch Filter Update) flag which should be set only when all four registers are setup.
;;;850    	*/
;;;851    	usReg = (1 << 7) | (_NFA0 & 0x3F);
000006  f004003f          AND      r0,r4,#0x3f
00000a  f0400680          ORR      r6,r0,#0x80
;;;852    	wm8978_WriteReg(27, usReg);	/* 写寄存器 */
00000e  4631              MOV      r1,r6
000010  201b              MOVS     r0,#0x1b
000012  f7fffffe          BL       wm8978_WriteReg
;;;853    
;;;854    	usReg = ((_NFA0 >> 7) & 0x3F);
000016  f3c416c5          UBFX     r6,r4,#7,#6
;;;855    	wm8978_WriteReg(28, usReg);	/* 写寄存器 */
00001a  4631              MOV      r1,r6
00001c  201c              MOVS     r0,#0x1c
00001e  f7fffffe          BL       wm8978_WriteReg
;;;856    
;;;857    	usReg = (_NFA1 & 0x3F);
000022  f005063f          AND      r6,r5,#0x3f
;;;858    	wm8978_WriteReg(29, usReg);	/* 写寄存器 */
000026  4631              MOV      r1,r6
000028  201d              MOVS     r0,#0x1d
00002a  f7fffffe          BL       wm8978_WriteReg
;;;859    
;;;860    	usReg = (1 << 8) | ((_NFA1 >> 7) & 0x3F);
00002e  f3c510c5          UBFX     r0,r5,#7,#6
000032  f4407680          ORR      r6,r0,#0x100
;;;861    	wm8978_WriteReg(30, usReg);	/* 写寄存器 */
000036  4631              MOV      r1,r6
000038  201e              MOVS     r0,#0x1e
00003a  f7fffffe          BL       wm8978_WriteReg
;;;862    }
00003e  bd70              POP      {r4-r6,pc}
;;;863    
                          ENDP


                          AREA ||i.wm8978_OutMute||, CODE, READONLY, ALIGN=1

                  wm8978_OutMute PROC
;;;196    */
;;;197    void wm8978_OutMute(uint8_t _ucMute)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  4605              MOV      r5,r0
;;;199    	uint16_t usRegValue;
;;;200    
;;;201    	if (_ucMute == 1) /* 静音 */
000004  2d01              CMP      r5,#1
000006  d128              BNE      |L13.90|
;;;202    	{
;;;203    		usRegValue = wm8978_ReadReg(52); /* Left Mixer Control */
000008  2034              MOVS     r0,#0x34
00000a  f7fffffe          BL       wm8978_ReadReg
00000e  4604              MOV      r4,r0
;;;204    		usRegValue |= (1u << 6);
000010  f0440440          ORR      r4,r4,#0x40
;;;205    		wm8978_WriteReg(52, usRegValue);
000014  4621              MOV      r1,r4
000016  2034              MOVS     r0,#0x34
000018  f7fffffe          BL       wm8978_WriteReg
;;;206    
;;;207    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
00001c  2035              MOVS     r0,#0x35
00001e  f7fffffe          BL       wm8978_ReadReg
000022  4604              MOV      r4,r0
;;;208    		usRegValue |= (1u << 6);
000024  f0440440          ORR      r4,r4,#0x40
;;;209    		wm8978_WriteReg(53, usRegValue);
000028  4621              MOV      r1,r4
00002a  2035              MOVS     r0,#0x35
00002c  f7fffffe          BL       wm8978_WriteReg
;;;210    
;;;211    		usRegValue = wm8978_ReadReg(54); /* Right Mixer Control */
000030  2036              MOVS     r0,#0x36
000032  f7fffffe          BL       wm8978_ReadReg
000036  4604              MOV      r4,r0
;;;212    		usRegValue |= (1u << 6);
000038  f0440440          ORR      r4,r4,#0x40
;;;213    		wm8978_WriteReg(54, usRegValue);
00003c  4621              MOV      r1,r4
00003e  2036              MOVS     r0,#0x36
000040  f7fffffe          BL       wm8978_WriteReg
;;;214    
;;;215    		usRegValue = wm8978_ReadReg(55); /* Right Mixer Control */
000044  2037              MOVS     r0,#0x37
000046  f7fffffe          BL       wm8978_ReadReg
00004a  4604              MOV      r4,r0
;;;216    		usRegValue |= (1u << 6);
00004c  f0440440          ORR      r4,r4,#0x40
;;;217    		wm8978_WriteReg(55, usRegValue);
000050  4621              MOV      r1,r4
000052  2037              MOVS     r0,#0x37
000054  f7fffffe          BL       wm8978_WriteReg
000058  e027              B        |L13.170|
                  |L13.90|
;;;218    	}
;;;219    	else	/* 取消静音 */
;;;220    	{
;;;221    		usRegValue = wm8978_ReadReg(52);
00005a  2034              MOVS     r0,#0x34
00005c  f7fffffe          BL       wm8978_ReadReg
000060  4604              MOV      r4,r0
;;;222    		usRegValue &= ~(1u << 6);
000062  f0240440          BIC      r4,r4,#0x40
;;;223    		wm8978_WriteReg(52, usRegValue);
000066  4621              MOV      r1,r4
000068  2034              MOVS     r0,#0x34
00006a  f7fffffe          BL       wm8978_WriteReg
;;;224    
;;;225    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
00006e  2035              MOVS     r0,#0x35
000070  f7fffffe          BL       wm8978_ReadReg
000074  4604              MOV      r4,r0
;;;226    		usRegValue &= ~(1u << 6);
000076  f0240440          BIC      r4,r4,#0x40
;;;227    		wm8978_WriteReg(53, usRegValue);
00007a  4621              MOV      r1,r4
00007c  2035              MOVS     r0,#0x35
00007e  f7fffffe          BL       wm8978_WriteReg
;;;228    
;;;229    		usRegValue = wm8978_ReadReg(54);
000082  2036              MOVS     r0,#0x36
000084  f7fffffe          BL       wm8978_ReadReg
000088  4604              MOV      r4,r0
;;;230    		usRegValue &= ~(1u << 6);
00008a  f0240440          BIC      r4,r4,#0x40
;;;231    		wm8978_WriteReg(54, usRegValue);
00008e  4621              MOV      r1,r4
000090  2036              MOVS     r0,#0x36
000092  f7fffffe          BL       wm8978_WriteReg
;;;232    
;;;233    		usRegValue = wm8978_ReadReg(55); /* Left Mixer Control */
000096  2037              MOVS     r0,#0x37
000098  f7fffffe          BL       wm8978_ReadReg
00009c  4604              MOV      r4,r0
;;;234    		usRegValue &= ~(1u << 6);
00009e  f0240440          BIC      r4,r4,#0x40
;;;235    		wm8978_WriteReg(55, usRegValue);
0000a2  4621              MOV      r1,r4
0000a4  2037              MOVS     r0,#0x37
0000a6  f7fffffe          BL       wm8978_WriteReg
                  |L13.170|
;;;236    	}
;;;237    }
0000aa  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP


                          AREA ||i.wm8978_PowerDown||, CODE, READONLY, ALIGN=1

                  wm8978_PowerDown PROC
;;;313    */
;;;314    void wm8978_PowerDown(void)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316    	wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
000002  f7fffffe          BL       wm8978_Reset
;;;317    }
000006  bd10              POP      {r4,pc}
;;;318    
                          ENDP


                          AREA ||i.wm8978_ReadEarVolume||, CODE, READONLY, ALIGN=1

                  wm8978_ReadEarVolume PROC
;;;170    */
;;;171    uint8_t wm8978_ReadEarVolume(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173    	return (uint8_t)(wm8978_ReadReg(52) & 0x3F );
000002  2034              MOVS     r0,#0x34
000004  f7fffffe          BL       wm8978_ReadReg
000008  f000003f          AND      r0,r0,#0x3f
;;;174    }
00000c  bd10              POP      {r4,pc}
;;;175    
                          ENDP


                          AREA ||i.wm8978_ReadReg||, CODE, READONLY, ALIGN=2

                  wm8978_ReadReg PROC
;;;396    */
;;;397    static uint16_t wm8978_ReadReg(uint8_t _ucRegAddr)
000000  4601              MOV      r1,r0
;;;398    {
;;;399    	return wm8978_RegCash[_ucRegAddr];
000002  4802              LDR      r0,|L16.12|
000004  f8300011          LDRH     r0,[r0,r1,LSL #1]
;;;400    }
000008  4770              BX       lr
;;;401    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      wm8978_RegCash

                          AREA ||i.wm8978_ReadSpkVolume||, CODE, READONLY, ALIGN=1

                  wm8978_ReadSpkVolume PROC
;;;183    */
;;;184    uint8_t wm8978_ReadSpkVolume(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186    	return (uint8_t)(wm8978_ReadReg(54) & 0x3F );
000002  2036              MOVS     r0,#0x36
000004  f7fffffe          BL       wm8978_ReadReg
000008  f000003f          AND      r0,r0,#0x3f
;;;187    }
00000c  bd10              POP      {r4,pc}
;;;188    
                          ENDP


                          AREA ||i.wm8978_Reset||, CODE, READONLY, ALIGN=2

                  wm8978_Reset PROC
;;;895    */
;;;896    static void wm8978_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;897    {
000002  b09e              SUB      sp,sp,#0x78
;;;898    	/* wm8978寄存器缺省值 */
;;;899    	const uint16_t reg_default[] = {
000004  2274              MOVS     r2,#0x74
000006  490b              LDR      r1,|L18.52|
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;900    	0x000, 0x000, 0x000, 0x000, 0x050, 0x000, 0x140, 0x000,
;;;901    	0x000, 0x000, 0x000, 0x0FF, 0x0FF, 0x000, 0x100, 0x0FF,
;;;902    	0x0FF, 0x000, 0x12C, 0x02C, 0x02C, 0x02C, 0x02C, 0x000,
;;;903    	0x032, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
;;;904    	0x038, 0x00B, 0x032, 0x000, 0x008, 0x00C, 0x093, 0x0E9,
;;;905    	0x000, 0x000, 0x000, 0x000, 0x003, 0x010, 0x010, 0x100,
;;;906    	0x100, 0x002, 0x001, 0x001, 0x039, 0x039, 0x039, 0x039,
;;;907    	0x001, 0x001
;;;908    	};
;;;909    	uint8_t i;
;;;910    
;;;911    	wm8978_WriteReg(0x00, 0);
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       wm8978_WriteReg
;;;912    
;;;913    	for (i = 0; i < sizeof(reg_default) / 2; i++)
000016  2400              MOVS     r4,#0
000018  e007              B        |L18.42|
                  |L18.26|
;;;914    	{
;;;915    		wm8978_RegCash[i] = reg_default[i];
00001a  a801              ADD      r0,sp,#4
00001c  f8300014          LDRH     r0,[r0,r4,LSL #1]
000020  4905              LDR      r1,|L18.56|
000022  f8210014          STRH     r0,[r1,r4,LSL #1]
000026  1c60              ADDS     r0,r4,#1              ;913
000028  b2c4              UXTB     r4,r0                 ;913
                  |L18.42|
00002a  2c3a              CMP      r4,#0x3a              ;913
00002c  d3f5              BCC      |L18.26|
;;;916    	}
;;;917    }
00002e  b01e              ADD      sp,sp,#0x78
000030  bd10              POP      {r4,pc}
;;;918    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      ||.constdata||
                  |L18.56|
                          DCD      wm8978_RegCash

                          AREA ||i.wm8978_SetEarVolume||, CODE, READONLY, ALIGN=1

                  wm8978_SetEarVolume PROC
;;;105    */
;;;106    void wm8978_SetEarVolume(uint8_t _ucVolume)
000000  b570              PUSH     {r4-r6,lr}
;;;107    {
000002  4604              MOV      r4,r0
;;;108    	uint16_t regL;
;;;109    	uint16_t regR;
;;;110    
;;;111    	if (_ucVolume > 0x3F)
000004  2c3f              CMP      r4,#0x3f
000006  dd00              BLE      |L19.10|
;;;112    	{
;;;113    		_ucVolume = 0x3F;
000008  243f              MOVS     r4,#0x3f
                  |L19.10|
;;;114    	}
;;;115    
;;;116    	regL = _ucVolume;
00000a  4625              MOV      r5,r4
;;;117    	regR = _ucVolume;
00000c  4626              MOV      r6,r4
;;;118    
;;;119    	/*
;;;120    		R52	LOUT1 Volume control
;;;121    		R53	ROUT1 Volume control
;;;122    	*/
;;;123    	/* 先更新左声道缓存值 */
;;;124    	wm8978_WriteReg(52, regL | 0x00);
00000e  4629              MOV      r1,r5
000010  2034              MOVS     r0,#0x34
000012  f7fffffe          BL       wm8978_WriteReg
;;;125    
;;;126    	/* 再同步更新左右声道的音量 */
;;;127    	wm8978_WriteReg(53, regR | 0x100);	/* 0x180表示 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000016  f4467180          ORR      r1,r6,#0x100
00001a  2035              MOVS     r0,#0x35
00001c  f7fffffe          BL       wm8978_WriteReg
;;;128    }
000020  bd70              POP      {r4-r6,pc}
;;;129    
                          ENDP


                          AREA ||i.wm8978_SetLineGain||, CODE, READONLY, ALIGN=1

                  wm8978_SetLineGain PROC
;;;271    */
;;;272    void wm8978_SetLineGain(uint8_t _ucGain)
000000  b570              PUSH     {r4-r6,lr}
;;;273    {
000002  4605              MOV      r5,r0
;;;274    	uint16_t usRegValue;
;;;275    
;;;276    	if (_ucGain > 7)
000004  2d07              CMP      r5,#7
000006  dd00              BLE      |L20.10|
;;;277    	{
;;;278    		_ucGain = 7;
000008  2507              MOVS     r5,#7
                  |L20.10|
;;;279    	}
;;;280    
;;;281    	/*
;;;282    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;283    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;284    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;285    	*/
;;;286    	/*	pdf 21页，R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;287    		R47 (R48定义与此相同)
;;;288    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;289    		B7		= 0， 保留
;;;290    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;291    		B3		= 0， 保留
;;;292    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;293    	*/
;;;294    
;;;295    	usRegValue = wm8978_ReadReg(47);
00000a  202f              MOVS     r0,#0x2f
00000c  f7fffffe          BL       wm8978_ReadReg
000010  4604              MOV      r4,r0
;;;296    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
000012  f004048f          AND      r4,r4,#0x8f
;;;297    	usRegValue |= (_ucGain << 4);
000016  ea441405          ORR      r4,r4,r5,LSL #4
;;;298    	wm8978_WriteReg(47, usRegValue);	/* 写左声道输入增益控制寄存器 */
00001a  4621              MOV      r1,r4
00001c  202f              MOVS     r0,#0x2f
00001e  f7fffffe          BL       wm8978_WriteReg
;;;299    
;;;300    	usRegValue = wm8978_ReadReg(48);
000022  2030              MOVS     r0,#0x30
000024  f7fffffe          BL       wm8978_ReadReg
000028  4604              MOV      r4,r0
;;;301    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
00002a  f004048f          AND      r4,r4,#0x8f
;;;302    	usRegValue |= (_ucGain << 4);
00002e  ea441405          ORR      r4,r4,r5,LSL #4
;;;303    	wm8978_WriteReg(48, usRegValue);	/* 写右声道输入增益控制寄存器 */
000032  4621              MOV      r1,r4
000034  2030              MOVS     r0,#0x30
000036  f7fffffe          BL       wm8978_WriteReg
;;;304    }
00003a  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP


                          AREA ||i.wm8978_SetMicGain||, CODE, READONLY, ALIGN=1

                  wm8978_SetMicGain PROC
;;;246    */
;;;247    void wm8978_SetMicGain(uint8_t _ucGain)
000000  b510              PUSH     {r4,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249    	if (_ucGain > GAIN_MAX)
000004  2c3f              CMP      r4,#0x3f
000006  dd00              BLE      |L21.10|
;;;250    	{
;;;251    		_ucGain = GAIN_MAX;
000008  243f              MOVS     r4,#0x3f
                  |L21.10|
;;;252    	}
;;;253    
;;;254    	/* PGA 音量控制  R45， R46   pdf 19页
;;;255    		Bit8	INPPGAUPDATE
;;;256    		Bit7	INPPGAZCL		过零再更改
;;;257    		Bit6	INPPGAMUTEL		PGA静音
;;;258    		Bit5:0	增益值，010000是0dB
;;;259    	*/
;;;260    	wm8978_WriteReg(45, _ucGain);
00000a  4621              MOV      r1,r4
00000c  202d              MOVS     r0,#0x2d
00000e  f7fffffe          BL       wm8978_WriteReg
;;;261    	wm8978_WriteReg(46, _ucGain | (1 << 8));
000012  f4447180          ORR      r1,r4,#0x100
000016  202e              MOVS     r0,#0x2e
000018  f7fffffe          BL       wm8978_WriteReg
;;;262    }
00001c  bd10              POP      {r4,pc}
;;;263    
                          ENDP


                          AREA ||i.wm8978_SetSpkVolume||, CODE, READONLY, ALIGN=1

                  wm8978_SetSpkVolume PROC
;;;138    */
;;;139    void wm8978_SetSpkVolume(uint8_t _ucVolume)
000000  b570              PUSH     {r4-r6,lr}
;;;140    {
000002  4604              MOV      r4,r0
;;;141    	uint16_t regL;
;;;142    	uint16_t regR;
;;;143    
;;;144    	if (_ucVolume > 0x3F)
000004  2c3f              CMP      r4,#0x3f
000006  dd00              BLE      |L22.10|
;;;145    	{
;;;146    		_ucVolume = 0x3F;
000008  243f              MOVS     r4,#0x3f
                  |L22.10|
;;;147    	}
;;;148    
;;;149    	regL = _ucVolume;
00000a  4625              MOV      r5,r4
;;;150    	regR = _ucVolume;
00000c  4626              MOV      r6,r4
;;;151    
;;;152    	/*
;;;153    		R54	LOUT2 (SPK) Volume control
;;;154    		R55	ROUT2 (SPK) Volume control
;;;155    	*/
;;;156    	/* 先更新左声道缓存值 */
;;;157    	wm8978_WriteReg(54, regL | 0x00);
00000e  4629              MOV      r1,r5
000010  2036              MOVS     r0,#0x36
000012  f7fffffe          BL       wm8978_WriteReg
;;;158    
;;;159    	/* 再同步更新左右声道的音量 */
;;;160    	wm8978_WriteReg(55, regR | 0x100);	/* 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000016  f4467180          ORR      r1,r6,#0x100
00001a  2037              MOVS     r0,#0x37
00001c  f7fffffe          BL       wm8978_WriteReg
;;;161    }
000020  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP


                          AREA ||i.wm8978_WriteReg||, CODE, READONLY, ALIGN=2

                  wm8978_WriteReg PROC
;;;410    */
;;;411    static uint8_t wm8978_WriteReg(uint8_t _ucRegAddr, uint16_t _usValue)
000000  b570              PUSH     {r4-r6,lr}
;;;412    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;413    	uint8_t ucAck;
;;;414    
;;;415    	/* 发送起始位 */
;;;416    	i2c_Start();
000006  f7fffffe          BL       i2c_Start
;;;417    
;;;418    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;419    	i2c_SendByte(WM8978_SLAVE_ADDRESS | I2C_WR);
00000a  2034              MOVS     r0,#0x34
00000c  f7fffffe          BL       i2c_SendByte
;;;420    
;;;421    	/* 检测ACK */
;;;422    	ucAck = i2c_WaitAck();
000010  f7fffffe          BL       i2c_WaitAck
000014  4606              MOV      r6,r0
;;;423    	if (ucAck == 1)
000016  2e01              CMP      r6,#1
000018  d101              BNE      |L23.30|
;;;424    	{
;;;425    		return 0;
00001a  2000              MOVS     r0,#0
                  |L23.28|
;;;426    	}
;;;427    
;;;428    	/* 发送控制字节1 */
;;;429    	i2c_SendByte(((_ucRegAddr << 1) & 0xFE) | ((_usValue >> 8) & 0x1));
;;;430    
;;;431    	/* 检测ACK */
;;;432    	ucAck = i2c_WaitAck();
;;;433    	if (ucAck == 1)
;;;434    	{
;;;435    		return 0;
;;;436    	}
;;;437    
;;;438    	/* 发送控制字节2 */
;;;439    	i2c_SendByte(_usValue & 0xFF);
;;;440    
;;;441    	/* 检测ACK */
;;;442    	ucAck = i2c_WaitAck();
;;;443    	if (ucAck == 1)
;;;444    	{
;;;445    		return 0;
;;;446    	}
;;;447    
;;;448    	/* 发送STOP */
;;;449    	i2c_Stop();
;;;450    
;;;451    	wm8978_RegCash[_ucRegAddr] = _usValue;
;;;452    	return 1;
;;;453    }
00001c  bd70              POP      {r4-r6,pc}
                  |L23.30|
00001e  21fe              MOVS     r1,#0xfe              ;429
000020  ea010145          AND      r1,r1,r5,LSL #1       ;429
000024  f3c42200          UBFX     r2,r4,#8,#1           ;429
000028  ea410002          ORR      r0,r1,r2              ;429
00002c  f7fffffe          BL       i2c_SendByte
000030  f7fffffe          BL       i2c_WaitAck
000034  4606              MOV      r6,r0                 ;432
000036  2e01              CMP      r6,#1                 ;433
000038  d101              BNE      |L23.62|
00003a  2000              MOVS     r0,#0                 ;435
00003c  e7ee              B        |L23.28|
                  |L23.62|
00003e  b2e0              UXTB     r0,r4                 ;439
000040  f7fffffe          BL       i2c_SendByte
000044  f7fffffe          BL       i2c_WaitAck
000048  4606              MOV      r6,r0                 ;442
00004a  2e01              CMP      r6,#1                 ;443
00004c  d101              BNE      |L23.82|
00004e  2000              MOVS     r0,#0                 ;445
000050  e7e4              B        |L23.28|
                  |L23.82|
000052  f7fffffe          BL       i2c_Stop
000056  4802              LDR      r0,|L23.96|
000058  f8204015          STRH     r4,[r0,r5,LSL #1]     ;451
00005c  2001              MOVS     r0,#1                 ;452
00005e  e7dd              B        |L23.28|
;;;454    
                          ENDP

                  |L23.96|
                          DCD      wm8978_RegCash

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000
000008  00500000          DCW      0x0050,0x0000
00000c  01400000          DCW      0x0140,0x0000
000010  00000000          DCW      0x0000,0x0000
000014  000000ff          DCW      0x0000,0x00ff
000018  00ff0000          DCW      0x00ff,0x0000
00001c  010000ff          DCW      0x0100,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  012c002c          DCW      0x012c,0x002c
000028  002c002c          DCW      0x002c,0x002c
00002c  002c0000          DCW      0x002c,0x0000
000030  00320000          DCW      0x0032,0x0000
000034  00000000          DCW      0x0000,0x0000
000038  00000000          DCW      0x0000,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  0038000b          DCW      0x0038,0x000b
000044  00320000          DCW      0x0032,0x0000
000048  0008000c          DCW      0x0008,0x000c
00004c  009300e9          DCW      0x0093,0x00e9
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00030010          DCW      0x0003,0x0010
00005c  00100100          DCW      0x0010,0x0100
000060  01000002          DCW      0x0100,0x0002
000064  00010001          DCW      0x0001,0x0001
000068  00390039          DCW      0x0039,0x0039
00006c  00390039          DCW      0x0039,0x0039
000070  00010001          DCW      0x0001,0x0001

                          AREA ||.data||, DATA, ALIGN=1

                  wm8978_RegCash
000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000
000008  00500000          DCW      0x0050,0x0000
00000c  01400000          DCW      0x0140,0x0000
000010  00000000          DCW      0x0000,0x0000
000014  000000ff          DCW      0x0000,0x00ff
000018  00ff0000          DCW      0x00ff,0x0000
00001c  010000ff          DCW      0x0100,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  012c002c          DCW      0x012c,0x002c
000028  002c002c          DCW      0x002c,0x002c
00002c  002c0000          DCW      0x002c,0x0000
000030  00320000          DCW      0x0032,0x0000
000034  00000000          DCW      0x0000,0x0000
000038  00000000          DCW      0x0000,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  0038000b          DCW      0x0038,0x000b
000044  00320000          DCW      0x0032,0x0000
000048  0008000c          DCW      0x0008,0x000c
00004c  009300e9          DCW      0x0093,0x00e9
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00030010          DCW      0x0003,0x0010
00005c  00100100          DCW      0x0010,0x0100
000060  01000002          DCW      0x0100,0x0002
000064  00010001          DCW      0x0001,0x0001
000068  00390039          DCW      0x0039,0x0039
00006c  00390039          DCW      0x0039,0x0039
000070  00010001          DCW      0x0001,0x0001

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_wm8978.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_wm8978_c_ef408190____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REVSH|
#line 144
|__asm___12_bsp_wm8978_c_ef408190____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
