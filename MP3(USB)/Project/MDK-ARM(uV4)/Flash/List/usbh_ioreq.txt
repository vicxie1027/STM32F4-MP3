; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usbh_ioreq.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usbh_ioreq.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usbh_ioreq.crf ..\..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_ioreq.c]
                          THUMB

                          AREA ||i.USBH_BulkReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_BulkReceiveData PROC
;;;277      */
;;;278    USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;279                                    uint8_t *buff, 
;;;280                                    uint16_t length,
;;;281                                    uint8_t hc_num)
;;;282    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;283      pdev->host.hc[hc_num].ep_is_in = 1;   
00000c  2101              MOVS     r1,#1
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;284      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;285      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;286      
;;;287    
;;;288      if( pdev->host.hc[hc_num].toggle_in == 0)
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  7e00              LDRB     r0,[r0,#0x18]
000036  b930              CBNZ     r0,|L1.70|
;;;289      {
;;;290        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
000038  2100              MOVS     r1,#0
00003a  f505706b          ADD      r0,r5,#0x3ac
00003e  eb001044          ADD      r0,r0,r4,LSL #5
000042  7201              STRB     r1,[r0,#8]
000044  e005              B        |L1.82|
                  |L1.70|
;;;291      }
;;;292      else
;;;293      {
;;;294        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000046  2102              MOVS     r1,#2
000048  f505706b          ADD      r0,r5,#0x3ac
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  7201              STRB     r1,[r0,#8]
                  |L1.82|
;;;295      }
;;;296    
;;;297      HCD_SubmitRequest (pdev , hc_num);  
000052  4621              MOV      r1,r4
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       HCD_SubmitRequest
;;;298      return USBH_OK;
00005a  2000              MOVS     r0,#0
;;;299    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;300    
                          ENDP


                          AREA ||i.USBH_BulkSendData||, CODE, READONLY, ALIGN=1

                  USBH_BulkSendData PROC
;;;244      */
;;;245    USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;246                                    uint8_t *buff, 
;;;247                                    uint16_t length,
;;;248                                    uint8_t hc_num)
;;;249    { 
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;250      pdev->host.hc[hc_num].ep_is_in = 0;
00000c  2100              MOVS     r1,#0
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;251      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;252      pdev->host.hc[hc_num].xfer_len = length;  
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;253    
;;;254     /* Set the Data Toggle bit as per the Flag */
;;;255      if ( pdev->host.hc[hc_num].toggle_out == 0)
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  7e40              LDRB     r0,[r0,#0x19]
000036  b928              CBNZ     r0,|L2.68|
;;;256      { /* Put the PID 0 */
;;;257          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
000038  f505706b          ADD      r0,r5,#0x3ac
00003c  eb001044          ADD      r0,r0,r4,LSL #5
000040  7201              STRB     r1,[r0,#8]
000042  e005              B        |L2.80|
                  |L2.68|
;;;258      }
;;;259     else
;;;260     { /* Put the PID 1 */
;;;261          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
000044  2102              MOVS     r1,#2
000046  f505706b          ADD      r0,r5,#0x3ac
00004a  eb001044          ADD      r0,r0,r4,LSL #5
00004e  7201              STRB     r1,[r0,#8]
                  |L2.80|
;;;262     }
;;;263    
;;;264      HCD_SubmitRequest (pdev , hc_num);   
000050  4621              MOV      r1,r4
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       HCD_SubmitRequest
;;;265      return USBH_OK;
000058  2000              MOVS     r0,#0
;;;266    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;267    
                          ENDP


                          AREA ||i.USBH_CtlReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_CtlReceiveData PROC
;;;217      */
;;;218    USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;219                                    uint8_t* buff, 
;;;220                                    uint16_t length,
;;;221                                    uint8_t hc_num)
;;;222    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;223    
;;;224      pdev->host.hc[hc_num].ep_is_in = 1;
00000c  2101              MOVS     r1,#1
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;225      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000018  2102              MOVS     r1,#2
00001a  f505706b          ADD      r0,r5,#0x3ac
00001e  eb001044          ADD      r0,r0,r4,LSL #5
000022  7201              STRB     r1,[r0,#8]
;;;226      pdev->host.hc[hc_num].xfer_buff = buff;
000024  f505706b          ADD      r0,r5,#0x3ac
000028  eb001044          ADD      r0,r0,r4,LSL #5
00002c  60c6              STR      r6,[r0,#0xc]
;;;227      pdev->host.hc[hc_num].xfer_len = length;  
00002e  f505706b          ADD      r0,r5,#0x3ac
000032  eb001044          ADD      r0,r0,r4,LSL #5
000036  6107              STR      r7,[r0,#0x10]
;;;228    
;;;229      HCD_SubmitRequest (pdev , hc_num);   
000038  4621              MOV      r1,r4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       HCD_SubmitRequest
;;;230      
;;;231      return USBH_OK;
000040  2000              MOVS     r0,#0
;;;232      
;;;233    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;234    
                          ENDP


                          AREA ||i.USBH_CtlReq||, CODE, READONLY, ALIGN=1

                  USBH_CtlReq PROC
;;;104      */
;;;105    USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106                                 USBH_HOST           *phost, 
;;;107                                 uint8_t             *buff,
;;;108                                 uint16_t            length)
;;;109    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;110      USBH_Status status;
;;;111      status = USBH_BUSY;
00000c  2701              MOVS     r7,#1
;;;112      
;;;113      switch (phost->RequestState)
00000e  78e0              LDRB     r0,[r4,#3]
000010  2801              CMP      r0,#1
000012  d002              BEQ      |L4.26|
000014  2802              CMP      r0,#2
000016  d120              BNE      |L4.90|
000018  e008              B        |L4.44|
                  |L4.26|
;;;114      {
;;;115      case CMD_SEND:
;;;116        /* Start a SETUP transfer */
;;;117        USBH_SubmitSetupRequest(phost, buff, length);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       USBH_SubmitSetupRequest
;;;118        phost->RequestState = CMD_WAIT;
000024  2002              MOVS     r0,#2
000026  70e0              STRB     r0,[r4,#3]
;;;119        status = USBH_BUSY;
000028  2701              MOVS     r7,#1
;;;120        break;
00002a  e017              B        |L4.92|
                  |L4.44|
;;;121        
;;;122      case CMD_WAIT:
;;;123         if (phost->Control.state == CTRL_COMPLETE ) 
00002c  7f20              LDRB     r0,[r4,#0x1c]
00002e  280d              CMP      r0,#0xd
000030  d105              BNE      |L4.62|
;;;124        {
;;;125          /* Commands successfully sent and Response Received  */       
;;;126          phost->RequestState = CMD_SEND;
000032  2001              MOVS     r0,#1
000034  70e0              STRB     r0,[r4,#3]
;;;127          phost->Control.state =CTRL_IDLE;  
000036  2100              MOVS     r1,#0
000038  7721              STRB     r1,[r4,#0x1c]
;;;128          status = USBH_OK;      
00003a  2700              MOVS     r7,#0
00003c  e00c              B        |L4.88|
                  |L4.62|
;;;129        }
;;;130        else if  (phost->Control.state == CTRL_ERROR)
00003e  7f20              LDRB     r0,[r4,#0x1c]
000040  280b              CMP      r0,#0xb
000042  d103              BNE      |L4.76|
;;;131        {
;;;132          /* Failure Mode */
;;;133          phost->RequestState = CMD_SEND;
000044  2001              MOVS     r0,#1
000046  70e0              STRB     r0,[r4,#3]
;;;134          status = USBH_FAIL;
000048  2702              MOVS     r7,#2
00004a  e005              B        |L4.88|
                  |L4.76|
;;;135        }   
;;;136         else if  (phost->Control.state == CTRL_STALLED )
00004c  7f20              LDRB     r0,[r4,#0x1c]
00004e  280c              CMP      r0,#0xc
000050  d102              BNE      |L4.88|
;;;137        {
;;;138          /* Commands successfully sent and Response Received  */       
;;;139          phost->RequestState = CMD_SEND;
000052  2001              MOVS     r0,#1
000054  70e0              STRB     r0,[r4,#3]
;;;140          status = USBH_NOT_SUPPORTED;
000056  2703              MOVS     r7,#3
                  |L4.88|
;;;141        }
;;;142        break;
000058  e000              B        |L4.92|
                  |L4.90|
;;;143        
;;;144      default:
;;;145        break; 
00005a  bf00              NOP      
                  |L4.92|
00005c  bf00              NOP                            ;120
;;;146      }
;;;147      return status;
00005e  4638              MOV      r0,r7
;;;148    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;149    
                          ENDP


                          AREA ||i.USBH_CtlSendData||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendData PROC
;;;178      */
;;;179    USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;180                                    uint8_t *buff, 
;;;181                                    uint16_t length,
;;;182                                    uint8_t hc_num)
;;;183    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;184      pdev->host.hc[hc_num].ep_is_in = 0;
00000c  2100              MOVS     r1,#0
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;185      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c7              STR      r7,[r0,#0xc]
;;;186      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6106              STR      r6,[r0,#0x10]
;;;187     
;;;188      if ( length == 0 )
00002c  b92e              CBNZ     r6,|L5.58|
;;;189      { /* For Status OUT stage, Length==0, Status Out PID = 1 */
;;;190        pdev->host.hc[hc_num].toggle_out = 1;   
00002e  2101              MOVS     r1,#1
000030  f505706b          ADD      r0,r5,#0x3ac
000034  eb001044          ADD      r0,r0,r4,LSL #5
000038  7641              STRB     r1,[r0,#0x19]
                  |L5.58|
;;;191      }
;;;192     
;;;193     /* Set the Data Toggle bit as per the Flag */
;;;194      if ( pdev->host.hc[hc_num].toggle_out == 0)
00003a  f505706b          ADD      r0,r5,#0x3ac
00003e  eb001044          ADD      r0,r0,r4,LSL #5
000042  7e40              LDRB     r0,[r0,#0x19]
000044  b930              CBNZ     r0,|L5.84|
;;;195      { /* Put the PID 0 */
;;;196          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
000046  2100              MOVS     r1,#0
000048  f505706b          ADD      r0,r5,#0x3ac
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  7201              STRB     r1,[r0,#8]
000052  e005              B        |L5.96|
                  |L5.84|
;;;197      }
;;;198     else
;;;199     { /* Put the PID 1 */
;;;200          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
000054  2102              MOVS     r1,#2
000056  f505706b          ADD      r0,r5,#0x3ac
00005a  eb001044          ADD      r0,r0,r4,LSL #5
00005e  7201              STRB     r1,[r0,#8]
                  |L5.96|
;;;201     }
;;;202    
;;;203      HCD_SubmitRequest (pdev , hc_num);   
000060  4621              MOV      r1,r4
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       HCD_SubmitRequest
;;;204       
;;;205      return USBH_OK;
000068  2000              MOVS     r0,#0
;;;206    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;207    
                          ENDP


                          AREA ||i.USBH_CtlSendSetup||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendSetup PROC
;;;157      */
;;;158    USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;159                                    uint8_t *buff, 
;;;160                                    uint8_t hc_num){
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;161      pdev->host.hc[hc_num].ep_is_in = 0;
000008  2100              MOVS     r1,#0
00000a  f505706b          ADD      r0,r5,#0x3ac
00000e  eb001044          ADD      r0,r0,r4,LSL #5
000012  7081              STRB     r1,[r0,#2]
;;;162      pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
000014  2103              MOVS     r1,#3
000016  f505706b          ADD      r0,r5,#0x3ac
00001a  eb001044          ADD      r0,r0,r4,LSL #5
00001e  7201              STRB     r1,[r0,#8]
;;;163      pdev->host.hc[hc_num].xfer_buff = buff;
000020  f505706b          ADD      r0,r5,#0x3ac
000024  eb001044          ADD      r0,r0,r4,LSL #5
000028  60c6              STR      r6,[r0,#0xc]
;;;164      pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
00002a  2108              MOVS     r1,#8
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  6101              STR      r1,[r0,#0x10]
;;;165    
;;;166      return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       HCD_SubmitRequest
00003e  b2c0              UXTB     r0,r0
;;;167    }
000040  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP


                          AREA ||i.USBH_InterruptReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptReceiveData PROC
;;;310      */
;;;311    USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;312                                    uint8_t *buff, 
;;;313                                    uint8_t length,
;;;314                                    uint8_t hc_num)
;;;315    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;316    
;;;317      pdev->host.hc[hc_num].ep_is_in = 1;  
00000c  2101              MOVS     r1,#1
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;318      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;319      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;320      
;;;321    
;;;322      
;;;323      if(pdev->host.hc[hc_num].toggle_in == 0)
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  7e00              LDRB     r0,[r0,#0x18]
000036  b930              CBNZ     r0,|L7.70|
;;;324      {
;;;325        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
000038  2100              MOVS     r1,#0
00003a  f505706b          ADD      r0,r5,#0x3ac
00003e  eb001044          ADD      r0,r0,r4,LSL #5
000042  7201              STRB     r1,[r0,#8]
000044  e005              B        |L7.82|
                  |L7.70|
;;;326      }
;;;327      else
;;;328      {
;;;329        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000046  2102              MOVS     r1,#2
000048  f505706b          ADD      r0,r5,#0x3ac
00004c  eb001044          ADD      r0,r0,r4,LSL #5
000050  7201              STRB     r1,[r0,#8]
                  |L7.82|
;;;330      }
;;;331    
;;;332      /* toggle DATA PID */
;;;333      pdev->host.hc[hc_num].toggle_in ^= 1;  
000052  f505706b          ADD      r0,r5,#0x3ac
000056  eb001044          ADD      r0,r0,r4,LSL #5
00005a  7e00              LDRB     r0,[r0,#0x18]
00005c  f0800101          EOR      r1,r0,#1
000060  f505706b          ADD      r0,r5,#0x3ac
000064  eb001044          ADD      r0,r0,r4,LSL #5
000068  7601              STRB     r1,[r0,#0x18]
;;;334      
;;;335      HCD_SubmitRequest (pdev , hc_num);  
00006a  4621              MOV      r1,r4
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       HCD_SubmitRequest
;;;336      
;;;337      return USBH_OK;
000072  2000              MOVS     r0,#0
;;;338    }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;339    
                          ENDP


                          AREA ||i.USBH_InterruptSendData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptSendData PROC
;;;348      */
;;;349    USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;350                                    uint8_t *buff, 
;;;351                                    uint8_t length,
;;;352                                    uint8_t hc_num)
;;;353    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;354    
;;;355      pdev->host.hc[hc_num].ep_is_in = 0;  
00000c  2100              MOVS     r1,#0
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;356      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;357      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;358      
;;;359      if(pdev->host.hc[hc_num].toggle_in == 0)
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  7e00              LDRB     r0,[r0,#0x18]
000036  b928              CBNZ     r0,|L8.68|
;;;360      {
;;;361        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
000038  f505706b          ADD      r0,r5,#0x3ac
00003c  eb001044          ADD      r0,r0,r4,LSL #5
000040  7201              STRB     r1,[r0,#8]
000042  e005              B        |L8.80|
                  |L8.68|
;;;362      }
;;;363      else
;;;364      {
;;;365        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000044  2102              MOVS     r1,#2
000046  f505706b          ADD      r0,r5,#0x3ac
00004a  eb001044          ADD      r0,r0,r4,LSL #5
00004e  7201              STRB     r1,[r0,#8]
                  |L8.80|
;;;366      }
;;;367    
;;;368      pdev->host.hc[hc_num].toggle_in ^= 1;  
000050  f505706b          ADD      r0,r5,#0x3ac
000054  eb001044          ADD      r0,r0,r4,LSL #5
000058  7e00              LDRB     r0,[r0,#0x18]
00005a  f0800101          EOR      r1,r0,#1
00005e  f505706b          ADD      r0,r5,#0x3ac
000062  eb001044          ADD      r0,r0,r4,LSL #5
000066  7601              STRB     r1,[r0,#0x18]
;;;369      
;;;370      HCD_SubmitRequest (pdev , hc_num);  
000068  4621              MOV      r1,r4
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       HCD_SubmitRequest
;;;371      
;;;372      return USBH_OK;
000070  2000              MOVS     r0,#0
;;;373    }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;374    
                          ENDP


                          AREA ||i.USBH_IsocReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_IsocReceiveData PROC
;;;412      */
;;;413    USBH_Status USBH_IsocReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414                                    uint8_t *buff, 
;;;415                                    uint32_t length,
;;;416                                    uint8_t hc_num)
;;;417    {    
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;418      
;;;419      pdev->host.hc[hc_num].ep_is_in = 1;  
00000c  2101              MOVS     r1,#1
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;420      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;421      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;422      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
00002c  2100              MOVS     r1,#0
00002e  f505706b          ADD      r0,r5,#0x3ac
000032  eb001044          ADD      r0,r0,r4,LSL #5
000036  7201              STRB     r1,[r0,#8]
;;;423      
;;;424    
;;;425      HCD_SubmitRequest (pdev , hc_num);  
000038  4621              MOV      r1,r4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       HCD_SubmitRequest
;;;426      
;;;427      return USBH_OK;
000040  2000              MOVS     r0,#0
;;;428    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;429    
                          ENDP


                          AREA ||i.USBH_IsocSendData||, CODE, READONLY, ALIGN=1

                  USBH_IsocSendData PROC
;;;438      */
;;;439    USBH_Status USBH_IsocSendData( USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;440                                    uint8_t *buff, 
;;;441                                    uint32_t length,
;;;442                                    uint8_t hc_num)
;;;443    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;444      
;;;445      pdev->host.hc[hc_num].ep_is_in = 0;  
00000c  2100              MOVS     r1,#0
00000e  f505706b          ADD      r0,r5,#0x3ac
000012  eb001044          ADD      r0,r0,r4,LSL #5
000016  7081              STRB     r1,[r0,#2]
;;;446      pdev->host.hc[hc_num].xfer_buff = buff;
000018  f505706b          ADD      r0,r5,#0x3ac
00001c  eb001044          ADD      r0,r0,r4,LSL #5
000020  60c6              STR      r6,[r0,#0xc]
;;;447      pdev->host.hc[hc_num].xfer_len = length;
000022  f505706b          ADD      r0,r5,#0x3ac
000026  eb001044          ADD      r0,r0,r4,LSL #5
00002a  6107              STR      r7,[r0,#0x10]
;;;448      pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
00002c  f505706b          ADD      r0,r5,#0x3ac
000030  eb001044          ADD      r0,r0,r4,LSL #5
000034  7201              STRB     r1,[r0,#8]
;;;449      
;;;450      HCD_SubmitRequest (pdev , hc_num);  
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       HCD_SubmitRequest
;;;451      
;;;452      return USBH_OK;
00003e  2000              MOVS     r0,#0
;;;453    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;454    
                          ENDP


                          AREA ||i.USBH_SubmitSetupRequest||, CODE, READONLY, ALIGN=1

                  USBH_SubmitSetupRequest PROC
;;;385    */
;;;386    static USBH_Status USBH_SubmitSetupRequest(USBH_HOST *phost,
000000  b510              PUSH     {r4,lr}
;;;387                                               uint8_t* buff, 
;;;388                                               uint16_t length)
;;;389    {
000002  4603              MOV      r3,r0
;;;390      
;;;391      /* Save Global State */
;;;392      phost->gStateBkp =   phost->gState; 
000004  7818              LDRB     r0,[r3,#0]
000006  7058              STRB     r0,[r3,#1]
;;;393      
;;;394      /* Prepare the Transactions */
;;;395      phost->gState = HOST_CTRL_XFER;
000008  2007              MOVS     r0,#7
00000a  7018              STRB     r0,[r3,#0]
;;;396      phost->Control.buff = buff; 
00000c  6099              STR      r1,[r3,#8]
;;;397      phost->Control.length = length;
00000e  819a              STRH     r2,[r3,#0xc]
;;;398      phost->Control.state = CTRL_SETUP;  
000010  2401              MOVS     r4,#1
000012  771c              STRB     r4,[r3,#0x1c]
;;;399    
;;;400      return USBH_OK;  
000014  2000              MOVS     r0,#0
;;;401    }
000016  bd10              POP      {r4,pc}
;;;402    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_ioreq.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_usbh_ioreq_c_4b12c4a6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REVSH|
#line 144
|__asm___12_usbh_ioreq_c_4b12c4a6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
