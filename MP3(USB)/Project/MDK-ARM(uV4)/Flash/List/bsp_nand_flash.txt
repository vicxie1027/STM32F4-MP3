; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_nand_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_nand_flash.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\bsp_nand_flash.crf ..\..\User\bsp_stm32f4xx\src\bsp_nand_flash.c]
                          THUMB

                          AREA ||i.FSMC_NAND_EraseBlock||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_EraseBlock PROC
;;;607    */
;;;608    static uint8_t FSMC_NAND_EraseBlock(uint32_t _ulBlockNo)
000000  b510              PUSH     {r4,lr}
;;;609    {
000002  4604              MOV      r4,r0
;;;610    	/* 发送擦除命令 */
;;;611    	NAND_CMD_AREA = NAND_CMD_ERASE0;
000004  2060              MOVS     r0,#0x60
000006  4906              LDR      r1,|L1.32|
000008  7008              STRB     r0,[r1,#0]
;;;612    
;;;613    	_ulBlockNo <<= 6;	/* 块号转换为页编号 */
00000a  01a4              LSLS     r4,r4,#6
;;;614    	NAND_ADDR_AREA = _ulBlockNo;
00000c  4905              LDR      r1,|L1.36|
00000e  700c              STRB     r4,[r1,#0]
;;;615    	NAND_ADDR_AREA = _ulBlockNo >> 8;
000010  0a20              LSRS     r0,r4,#8
000012  7008              STRB     r0,[r1,#0]
;;;616    
;;;617    	NAND_CMD_AREA = NAND_CMD_ERASE1;
000014  20d0              MOVS     r0,#0xd0
000016  4902              LDR      r1,|L1.32|
000018  7008              STRB     r0,[r1,#0]
;;;618    
;;;619    	return (FSMC_NAND_GetStatus());
00001a  f7fffffe          BL       FSMC_NAND_GetStatus
;;;620    }
00001e  bd10              POP      {r4,pc}
;;;621    
                          ENDP

                  |L1.32|
                          DCD      0x70010000
                  |L1.36|
                          DCD      0x70020000

                          AREA ||i.FSMC_NAND_GetStatus||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_GetStatus PROC
;;;688    */
;;;689    static uint8_t FSMC_NAND_GetStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;690    {
;;;691    	uint32_t ulTimeout = 0x10000;
000002  f44f3480          MOV      r4,#0x10000
;;;692    	uint8_t ucStatus = NAND_READY;
000006  2540              MOVS     r5,#0x40
;;;693    
;;;694    	ucStatus = FSMC_NAND_ReadStatus();
000008  f7fffffe          BL       FSMC_NAND_ReadStatus
00000c  4605              MOV      r5,r0
;;;695    
;;;696    	/* 等待NAND操作结束，超时后会退出 */
;;;697    	while ((ucStatus != NAND_READY) &&( ulTimeout != 0x00))
00000e  e003              B        |L2.24|
                  |L2.16|
;;;698    	{
;;;699    		ucStatus = FSMC_NAND_ReadStatus();
000010  f7fffffe          BL       FSMC_NAND_ReadStatus
000014  4605              MOV      r5,r0
;;;700    		ulTimeout--;
000016  1e64              SUBS     r4,r4,#1
                  |L2.24|
000018  2d40              CMP      r5,#0x40              ;697
00001a  d001              BEQ      |L2.32|
00001c  2c00              CMP      r4,#0                 ;697
00001e  d1f7              BNE      |L2.16|
                  |L2.32|
;;;701    	}
;;;702    
;;;703    	if(ulTimeout == 0x00)
000020  b904              CBNZ     r4,|L2.36|
;;;704    	{
;;;705    		ucStatus =  NAND_TIMEOUT_ERROR;
000022  2580              MOVS     r5,#0x80
                  |L2.36|
;;;706    	}
;;;707    
;;;708    	/* 返回操作状态 */
;;;709    	return (ucStatus);
000024  4628              MOV      r0,r5
;;;710    }
000026  bd70              POP      {r4-r6,pc}
;;;711    
                          ENDP


                          AREA ||i.FSMC_NAND_Init||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_Init PROC
;;;120    */
;;;121    static void FSMC_NAND_Init(void)
000000  b500              PUSH     {lr}
;;;122    {
000002  b08f              SUB      sp,sp,#0x3c
;;;123    	GPIO_InitTypeDef GPIO_InitStructure;
;;;124    	FSMC_NANDInitTypeDef  FSMC_NANDInitStructure;
;;;125    	FSMC_NAND_PCCARDTimingInitTypeDef  p;
;;;126    
;;;127    
;;;128    	/*--NAND Flash GPIOs 配置  ------
;;;129    		PD0/FSMC_D2
;;;130    		PD1/FSMC_D3
;;;131    		PD4/FSMC_NOE
;;;132    		PD5/FSMC_NWE
;;;133    		PD7/FSMC_NCE2
;;;134    		PD11/FSMC_A16
;;;135    		PD12/FSMC_A17
;;;136    		PD14/FSMC_D0
;;;137    		PD15/FSMC_D1
;;;138    
;;;139    		PE7/FSMC_D4
;;;140    		PE8/FSMC_D5
;;;141    		PE9/FSMC_D6
;;;142    		PE10/FSMC_D7
;;;143    
;;;144    		PG6/FSMC_INT2	(本例程用查询方式判忙，此口线作为普通GPIO输入功能使用)
;;;145    	*/
;;;146    
;;;147    	/* 使能 GPIO 时钟 */
;;;148    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
000004  2101              MOVS     r1,#1
000006  2058              MOVS     r0,#0x58
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;149    
;;;150    	/* 使能 FSMC 时钟 */
;;;151    	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;152    
;;;153    	/*  配置GPIOD */
;;;154    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
000014  220c              MOVS     r2,#0xc
000016  2100              MOVS     r1,#0
000018  484a              LDR      r0,|L3.324|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;155    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
00001e  220c              MOVS     r2,#0xc
000020  2101              MOVS     r1,#1
000022  4848              LDR      r0,|L3.324|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;156    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000028  220c              MOVS     r2,#0xc
00002a  2104              MOVS     r1,#4
00002c  4845              LDR      r0,|L3.324|
00002e  f7fffffe          BL       GPIO_PinAFConfig
;;;157    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
000032  220c              MOVS     r2,#0xc
000034  2105              MOVS     r1,#5
000036  4843              LDR      r0,|L3.324|
000038  f7fffffe          BL       GPIO_PinAFConfig
;;;158    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
00003c  220c              MOVS     r2,#0xc
00003e  2107              MOVS     r1,#7
000040  4840              LDR      r0,|L3.324|
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;159    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
000046  220c              MOVS     r2,#0xc
000048  210b              MOVS     r1,#0xb
00004a  483e              LDR      r0,|L3.324|
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;160    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
000050  220c              MOVS     r2,#0xc
000052  4611              MOV      r1,r2
000054  483b              LDR      r0,|L3.324|
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;161    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
00005a  220c              MOVS     r2,#0xc
00005c  210e              MOVS     r1,#0xe
00005e  4839              LDR      r0,|L3.324|
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;162    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
000064  220c              MOVS     r2,#0xc
000066  210f              MOVS     r1,#0xf
000068  4836              LDR      r0,|L3.324|
00006a  f7fffffe          BL       GPIO_PinAFConfig
;;;163    
;;;164    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
00006e  f64d00b3          MOV      r0,#0xd8b3
000072  900d              STR      r0,[sp,#0x34]
;;;165    	                            GPIO_Pin_7 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_14 | GPIO_Pin_15;
;;;166    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000074  2002              MOVS     r0,#2
000076  f88d0038          STRB     r0,[sp,#0x38]
;;;167    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00007a  2003              MOVS     r0,#3
00007c  f88d0039          STRB     r0,[sp,#0x39]
;;;168    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000080  2000              MOVS     r0,#0
000082  f88d003a          STRB     r0,[sp,#0x3a]
;;;169    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000086  f88d003b          STRB     r0,[sp,#0x3b]
;;;170    
;;;171    	GPIO_Init(GPIOD, &GPIO_InitStructure);
00008a  a90d              ADD      r1,sp,#0x34
00008c  482d              LDR      r0,|L3.324|
00008e  f7fffffe          BL       GPIO_Init
;;;172    
;;;173    	/*  配置GPIOE */
;;;174    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_FSMC);
000092  220c              MOVS     r2,#0xc
000094  2107              MOVS     r1,#7
000096  482c              LDR      r0,|L3.328|
000098  f7fffffe          BL       GPIO_PinAFConfig
;;;175    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_FSMC);
00009c  220c              MOVS     r2,#0xc
00009e  2108              MOVS     r1,#8
0000a0  4829              LDR      r0,|L3.328|
0000a2  f7fffffe          BL       GPIO_PinAFConfig
;;;176    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_FSMC);
0000a6  220c              MOVS     r2,#0xc
0000a8  2109              MOVS     r1,#9
0000aa  4827              LDR      r0,|L3.328|
0000ac  f7fffffe          BL       GPIO_PinAFConfig
;;;177    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
0000b0  220c              MOVS     r2,#0xc
0000b2  210a              MOVS     r1,#0xa
0000b4  4824              LDR      r0,|L3.328|
0000b6  f7fffffe          BL       GPIO_PinAFConfig
;;;178    
;;;179    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
0000ba  f44f60f0          MOV      r0,#0x780
0000be  900d              STR      r0,[sp,#0x34]
;;;180    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000c0  2002              MOVS     r0,#2
0000c2  f88d0038          STRB     r0,[sp,#0x38]
;;;181    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000c6  2003              MOVS     r0,#3
0000c8  f88d0039          STRB     r0,[sp,#0x39]
;;;182    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000cc  2000              MOVS     r0,#0
0000ce  f88d003a          STRB     r0,[sp,#0x3a]
;;;183    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000d2  f88d003b          STRB     r0,[sp,#0x3b]
;;;184    	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000d6  a90d              ADD      r1,sp,#0x34
0000d8  481b              LDR      r0,|L3.328|
0000da  f7fffffe          BL       GPIO_Init
;;;185    
;;;186    	/*  配置GPIOG, PG6作为忙信息，配置为输入 */
;;;187    
;;;188    	/* INT2 引脚配置为内部上来输入，用于忙信号 */
;;;189    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
0000de  2040              MOVS     r0,#0x40
0000e0  900d              STR      r0,[sp,#0x34]
;;;190    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
0000e2  2000              MOVS     r0,#0
0000e4  f88d0038          STRB     r0,[sp,#0x38]
;;;191    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
0000e8  2003              MOVS     r0,#3
0000ea  f88d0039          STRB     r0,[sp,#0x39]
;;;192    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
0000ee  2001              MOVS     r0,#1
0000f0  f88d003a          STRB     r0,[sp,#0x3a]
;;;193    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
0000f4  f88d003b          STRB     r0,[sp,#0x3b]
;;;194    	GPIO_Init(GPIOG, &GPIO_InitStructure);
0000f8  a90d              ADD      r1,sp,#0x34
0000fa  4814              LDR      r0,|L3.332|
0000fc  f7fffffe          BL       GPIO_Init
;;;195    
;;;196    	/* 配置 FSMC 时序 */
;;;197    	/*
;;;198    		Defines the number of HCLK cycles to setup address before the command assertion for NAND-Flash
;;;199    		read or write access  to common/Attribute or I/O memory space (depending on the memory space
;;;200    		timing to be configured).This parameter can be a value between 0 and 0xFF.
;;;201    	*/
;;;202      	//p.FSMC_SetupTime = 0x01;
;;;203      	p.FSMC_SetupTime = 0x1;
000100  2001              MOVS     r0,#1
000102  9000              STR      r0,[sp,#0]
;;;204    
;;;205    	/*
;;;206    		Defines the minimum number of HCLK cycles to assert the command for NAND-Flash read or write
;;;207    		access to common/Attribute or I/O memory space (depending on the memory space timing to be
;;;208    		configured). This parameter can be a number between 0x00 and 0xFF
;;;209    	*/
;;;210    	//p.FSMC_WaitSetupTime = 0x03;
;;;211    	p.FSMC_WaitSetupTime = 0x3;
000104  2003              MOVS     r0,#3
000106  9001              STR      r0,[sp,#4]
;;;212    
;;;213    	/*
;;;214    		Defines the number of HCLK clock cycles to hold address (and data for write access) after the
;;;215    		command deassertion for NAND-Flash read or write access to common/Attribute or I/O memory space
;;;216    		 (depending on the memory space timing to be configured).
;;;217    		This parameter can be a number between 0x00 and 0xFF
;;;218    	*/
;;;219    	//p.FSMC_HoldSetupTime = 0x02;
;;;220    	p.FSMC_HoldSetupTime = 0x2;
000108  2002              MOVS     r0,#2
00010a  9002              STR      r0,[sp,#8]
;;;221    
;;;222    	/*
;;;223    		Defines the number of HCLK clock cycles during which the databus is kept in HiZ after the start
;;;224    		of a NAND-Flash  write access to common/Attribute or I/O memory space (depending on the memory
;;;225    		space timing to be configured). This parameter can be a number between 0x00 and 0xFF
;;;226    	*/
;;;227    	//p.FSMC_HiZSetupTime = 0x01;
;;;228    	p.FSMC_HiZSetupTime = 0x1;
00010c  2001              MOVS     r0,#1
00010e  9003              STR      r0,[sp,#0xc]
;;;229    
;;;230    
;;;231    	FSMC_NANDInitStructure.FSMC_Bank = FSMC_Bank2_NAND;  					/* 定义FSMC NAND BANK 号 */
000110  2010              MOVS     r0,#0x10
000112  9004              STR      r0,[sp,#0x10]
;;;232    	FSMC_NANDInitStructure.FSMC_Waitfeature = FSMC_Waitfeature_Disable;		/* 插入等待时序使能 */
000114  2000              MOVS     r0,#0
000116  9005              STR      r0,[sp,#0x14]
;;;233    	FSMC_NANDInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;	/* 数据宽度 8bit */
000118  9006              STR      r0,[sp,#0x18]
;;;234    	FSMC_NANDInitStructure.FSMC_ECC = FSMC_ECC_Enable; 						/* ECC错误检查和纠正功能使能 */
00011a  2040              MOVS     r0,#0x40
00011c  9007              STR      r0,[sp,#0x1c]
;;;235    	FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_2048Bytes;	/* ECC 页面大小 */
00011e  f44f20c0          MOV      r0,#0x60000
000122  9008              STR      r0,[sp,#0x20]
;;;236    	FSMC_NANDInitStructure.FSMC_TCLRSetupTime = 0x01;						/* CLE低和RE低之间的延迟，HCLK周期数 */
000124  2001              MOVS     r0,#1
000126  9009              STR      r0,[sp,#0x24]
;;;237    	FSMC_NANDInitStructure.FSMC_TARSetupTime = 0x01;						/* ALE低和RE低之间的延迟，HCLK周期数 */
000128  900a              STR      r0,[sp,#0x28]
;;;238    	FSMC_NANDInitStructure.FSMC_CommonSpaceTimingStruct = &p;				/* FSMC Common Space Timing */
00012a  f8cdd02c          STR      sp,[sp,#0x2c]
;;;239    	FSMC_NANDInitStructure.FSMC_AttributeSpaceTimingStruct = &p;			/* FSMC Attribute Space Timing */
00012e  f8cdd030          STR      sp,[sp,#0x30]
;;;240    
;;;241    	FSMC_NANDInit(&FSMC_NANDInitStructure);
000132  a804              ADD      r0,sp,#0x10
000134  f7fffffe          BL       FSMC_NANDInit
;;;242    
;;;243    	/* FSMC NAND Bank 使能 */
;;;244    	FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
000138  2101              MOVS     r1,#1
00013a  2010              MOVS     r0,#0x10
00013c  f7fffffe          BL       FSMC_NANDCmd
;;;245    }
000140  b00f              ADD      sp,sp,#0x3c
000142  bd00              POP      {pc}
;;;246    
                          ENDP

                  |L3.324|
                          DCD      0x40020c00
                  |L3.328|
                          DCD      0x40021000
                  |L3.332|
                          DCD      0x40021800

                          AREA ||i.FSMC_NAND_PageCopyBack||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_PageCopyBack PROC
;;;285    */
;;;286    static uint8_t FSMC_NAND_PageCopyBack(uint32_t _ulSrcPageNo, uint32_t _ulTarPageNo)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;288    	uint8_t i;
;;;289    
;;;290    	NAND_CMD_AREA = NAND_CMD_COPYBACK_A;
000006  2000              MOVS     r0,#0
000008  4916              LDR      r1,|L4.100|
00000a  7008              STRB     r0,[r1,#0]
;;;291    
;;;292    	/* 发送源页地址 ， 对于 HY27UF081G2A
;;;293    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;294    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;295    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;296    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;297    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;298    	*/
;;;299    	NAND_ADDR_AREA = 0;
00000c  4916              LDR      r1,|L4.104|
00000e  7008              STRB     r0,[r1,#0]
;;;300    	NAND_ADDR_AREA = 0;
000010  7008              STRB     r0,[r1,#0]
;;;301    	NAND_ADDR_AREA = _ulSrcPageNo;
000012  700c              STRB     r4,[r1,#0]
;;;302    	NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF00) >> 8;
000014  0a20              LSRS     r0,r4,#8
000016  7008              STRB     r0,[r1,#0]
;;;303    
;;;304    	NAND_CMD_AREA = NAND_CMD_COPYBACK_B;
000018  2035              MOVS     r0,#0x35
00001a  4912              LDR      r1,|L4.100|
00001c  7008              STRB     r0,[r1,#0]
;;;305    
;;;306    	/* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;307    	for (i = 0; i < 20; i++);
00001e  2600              MOVS     r6,#0
000020  e001              B        |L4.38|
                  |L4.34|
000022  1c70              ADDS     r0,r6,#1
000024  b2c6              UXTB     r6,r0
                  |L4.38|
000026  2e14              CMP      r6,#0x14
000028  dbfb              BLT      |L4.34|
;;;308    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
00002a  bf00              NOP      
                  |L4.44|
00002c  2140              MOVS     r1,#0x40
00002e  480f              LDR      r0,|L4.108|
000030  f7fffffe          BL       GPIO_ReadInputDataBit
000034  2800              CMP      r0,#0
000036  d0f9              BEQ      |L4.44|
;;;309    
;;;310    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
000038  2085              MOVS     r0,#0x85
00003a  490a              LDR      r1,|L4.100|
00003c  7008              STRB     r0,[r1,#0]
;;;311    
;;;312    	/* 发送目标页地址 ， 对于 HY27UF081G2A
;;;313    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;314    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;315    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;316    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;317    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;318    	*/
;;;319    	NAND_ADDR_AREA = 0;
00003e  2000              MOVS     r0,#0
000040  4909              LDR      r1,|L4.104|
000042  7008              STRB     r0,[r1,#0]
;;;320    	NAND_ADDR_AREA = 0;
000044  7008              STRB     r0,[r1,#0]
;;;321    	NAND_ADDR_AREA = _ulTarPageNo;
000046  700d              STRB     r5,[r1,#0]
;;;322    	NAND_ADDR_AREA = (_ulTarPageNo & 0xFF00) >> 8;
000048  0a28              LSRS     r0,r5,#8
00004a  7008              STRB     r0,[r1,#0]
;;;323    
;;;324    	NAND_CMD_AREA = NAND_CMD_COPYBACK_D;
00004c  2010              MOVS     r0,#0x10
00004e  4905              LDR      r1,|L4.100|
000050  7008              STRB     r0,[r1,#0]
;;;325    
;;;326    	/* 检查操作状态 */
;;;327    	if (FSMC_NAND_GetStatus() == NAND_READY)
000052  f7fffffe          BL       FSMC_NAND_GetStatus
000056  2840              CMP      r0,#0x40
000058  d101              BNE      |L4.94|
;;;328    	{
;;;329    		return NAND_OK;
00005a  2000              MOVS     r0,#0
                  |L4.92|
;;;330    	}
;;;331    	return NAND_FAIL;
;;;332    }
00005c  bd70              POP      {r4-r6,pc}
                  |L4.94|
00005e  2001              MOVS     r0,#1                 ;331
000060  e7fc              B        |L4.92|
;;;333    
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      0x70010000
                  |L4.104|
                          DCD      0x70020000
                  |L4.108|
                          DCD      0x40021800

                          AREA ||i.FSMC_NAND_PageCopyBackEx||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_PageCopyBackEx PROC
;;;350    */
;;;351    static uint8_t FSMC_NAND_PageCopyBackEx(uint32_t _ulSrcPageNo, uint32_t _ulTarPageNo, uint8_t *_pBuf, uint16_t _usOffset, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;352    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461f              MOV      r7,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;353    	uint16_t i;
;;;354    
;;;355    	NAND_CMD_AREA = NAND_CMD_COPYBACK_A;
000010  2000              MOVS     r0,#0
000012  4920              LDR      r1,|L5.148|
000014  7008              STRB     r0,[r1,#0]
;;;356    
;;;357    	/* 发送源页地址 ， 对于 HY27UF081G2A
;;;358    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;359    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;360    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;361    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;362    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;363    	*/
;;;364    	NAND_ADDR_AREA = 0;
000016  4920              LDR      r1,|L5.152|
000018  7008              STRB     r0,[r1,#0]
;;;365    	NAND_ADDR_AREA = 0;
00001a  7008              STRB     r0,[r1,#0]
;;;366    	NAND_ADDR_AREA = _ulSrcPageNo;
00001c  700d              STRB     r5,[r1,#0]
;;;367    	NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF00) >> 8;
00001e  0a28              LSRS     r0,r5,#8
000020  7008              STRB     r0,[r1,#0]
;;;368    
;;;369    	NAND_CMD_AREA = NAND_CMD_COPYBACK_B;
000022  2035              MOVS     r0,#0x35
000024  491b              LDR      r1,|L5.148|
000026  7008              STRB     r0,[r1,#0]
;;;370    
;;;371    	/* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;372    	for (i = 0; i < 20; i++);
000028  2400              MOVS     r4,#0
00002a  e001              B        |L5.48|
                  |L5.44|
00002c  1c60              ADDS     r0,r4,#1
00002e  b284              UXTH     r4,r0
                  |L5.48|
000030  2c14              CMP      r4,#0x14
000032  dbfb              BLT      |L5.44|
;;;373    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
000034  bf00              NOP      
                  |L5.54|
000036  2140              MOVS     r1,#0x40
000038  4818              LDR      r0,|L5.156|
00003a  f7fffffe          BL       GPIO_ReadInputDataBit
00003e  2800              CMP      r0,#0
000040  d0f9              BEQ      |L5.54|
;;;374    
;;;375    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
000042  2085              MOVS     r0,#0x85
000044  4913              LDR      r1,|L5.148|
000046  7008              STRB     r0,[r1,#0]
;;;376    
;;;377    	/* 发送目标页地址 ， 对于 HY27UF081G2A
;;;378    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;379    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;380    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;381    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;382    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;383    	*/
;;;384    	NAND_ADDR_AREA = 0;
000048  2000              MOVS     r0,#0
00004a  4913              LDR      r1,|L5.152|
00004c  7008              STRB     r0,[r1,#0]
;;;385    	NAND_ADDR_AREA = 0;
00004e  7008              STRB     r0,[r1,#0]
;;;386    	NAND_ADDR_AREA = _ulTarPageNo;
000050  700e              STRB     r6,[r1,#0]
;;;387    	NAND_ADDR_AREA = (_ulTarPageNo & 0xFF00) >> 8;
000052  0a30              LSRS     r0,r6,#8
000054  7008              STRB     r0,[r1,#0]
;;;388    
;;;389    	/* 中间无需带数据, 也无需等待 */
;;;390    
;;;391    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
000056  2085              MOVS     r0,#0x85
000058  490e              LDR      r1,|L5.148|
00005a  7008              STRB     r0,[r1,#0]
;;;392    
;;;393    	NAND_ADDR_AREA = _usOffset;
00005c  490e              LDR      r1,|L5.152|
00005e  700f              STRB     r7,[r1,#0]
;;;394    	NAND_ADDR_AREA = _usOffset >> 8;
000060  1238              ASRS     r0,r7,#8
000062  7008              STRB     r0,[r1,#0]
;;;395    
;;;396    	/* 发送数据 */
;;;397    	for(i = 0; i < _usSize; i++)
000064  2400              MOVS     r4,#0
000066  e006              B        |L5.118|
                  |L5.104|
;;;398    	{
;;;399    		NAND_DATA_AREA = _pBuf[i];
000068  f8180004          LDRB     r0,[r8,r4]
00006c  f04f41e0          MOV      r1,#0x70000000
000070  7008              STRB     r0,[r1,#0]
000072  1c60              ADDS     r0,r4,#1              ;397
000074  b284              UXTH     r4,r0                 ;397
                  |L5.118|
000076  454c              CMP      r4,r9                 ;397
000078  dbf6              BLT      |L5.104|
;;;400    	}
;;;401    
;;;402    	NAND_CMD_AREA = NAND_CMD_COPYBACK_D;
00007a  2010              MOVS     r0,#0x10
00007c  4905              LDR      r1,|L5.148|
00007e  7008              STRB     r0,[r1,#0]
;;;403    
;;;404    	/* 检查操作状态 */
;;;405    	if (FSMC_NAND_GetStatus() == NAND_READY)
000080  f7fffffe          BL       FSMC_NAND_GetStatus
000084  2840              CMP      r0,#0x40
000086  d102              BNE      |L5.142|
;;;406    	{
;;;407    		return NAND_OK;
000088  2000              MOVS     r0,#0
                  |L5.138|
;;;408    	}
;;;409    	return NAND_FAIL;
;;;410    }
00008a  e8bd87f0          POP      {r4-r10,pc}
                  |L5.142|
00008e  2001              MOVS     r0,#1                 ;409
000090  e7fb              B        |L5.138|
;;;411    
                          ENDP

000092  0000              DCW      0x0000
                  |L5.148|
                          DCD      0x70010000
                  |L5.152|
                          DCD      0x70020000
                  |L5.156|
                          DCD      0x40021800

                          AREA ||i.FSMC_NAND_ReadData||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_ReadData PROC
;;;587    */
;;;588    static uint8_t FSMC_NAND_ReadData(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;589    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;590    	if (_usByteCount > NAND_PAGE_SIZE)
00000c  f5b46f00          CMP      r4,#0x800
000010  dd02              BLE      |L6.24|
;;;591    	{
;;;592    		return NAND_FAIL;
000012  2001              MOVS     r0,#1
                  |L6.20|
;;;593    	}
;;;594    
;;;595    	return FSMC_NAND_ReadPage(_pBuffer, _ulPageNo, _usAddrInPage, _usByteCount);
;;;596    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L6.24|
000018  4623              MOV      r3,r4                 ;595
00001a  463a              MOV      r2,r7                 ;595
00001c  4631              MOV      r1,r6                 ;595
00001e  4628              MOV      r0,r5                 ;595
000020  f7fffffe          BL       FSMC_NAND_ReadPage
000024  e7f6              B        |L6.20|
;;;597    
                          ENDP


                          AREA ||i.FSMC_NAND_ReadPage||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_ReadPage PROC
;;;471    */
;;;472    static uint8_t FSMC_NAND_ReadPage(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;473    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
;;;474    	uint16_t i;
;;;475    
;;;476        /* 发送页面读命令 */
;;;477        NAND_CMD_AREA = NAND_CMD_AREA_A;
00000c  2000              MOVS     r0,#0
00000e  4913              LDR      r1,|L7.92|
000010  7008              STRB     r0,[r1,#0]
;;;478    
;;;479    	/* 发送页内地址 ， 对于 HY27UF081G2A
;;;480    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;481    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;482    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;483    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;484    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;485    	*/
;;;486    	NAND_ADDR_AREA = _usAddrInPage;
000012  4913              LDR      r1,|L7.96|
000014  700e              STRB     r6,[r1,#0]
;;;487    	NAND_ADDR_AREA = _usAddrInPage >> 8;
000016  1230              ASRS     r0,r6,#8
000018  7008              STRB     r0,[r1,#0]
;;;488    	NAND_ADDR_AREA = _ulPageNo;
00001a  700d              STRB     r5,[r1,#0]
;;;489    	NAND_ADDR_AREA = (_ulPageNo & 0xFF00) >> 8;
00001c  0a28              LSRS     r0,r5,#8
00001e  7008              STRB     r0,[r1,#0]
;;;490    
;;;491    	NAND_CMD_AREA = NAND_CMD_AREA_TRUE1;
000020  2030              MOVS     r0,#0x30
000022  490e              LDR      r1,|L7.92|
000024  7008              STRB     r0,[r1,#0]
;;;492    
;;;493    	 /* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;494    	for (i = 0; i < 20; i++);
000026  2400              MOVS     r4,#0
000028  e001              B        |L7.46|
                  |L7.42|
00002a  1c60              ADDS     r0,r4,#1
00002c  b284              UXTH     r4,r0
                  |L7.46|
00002e  2c14              CMP      r4,#0x14
000030  dbfb              BLT      |L7.42|
;;;495    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0);
000032  bf00              NOP      
                  |L7.52|
000034  2140              MOVS     r1,#0x40
000036  480b              LDR      r0,|L7.100|
000038  f7fffffe          BL       GPIO_ReadInputDataBit
00003c  2800              CMP      r0,#0
00003e  d0f9              BEQ      |L7.52|
;;;496    
;;;497    	/* 读数据到缓冲区pBuffer */
;;;498    	for(i = 0; i < _usByteCount; i++)
000040  2400              MOVS     r4,#0
000042  e005              B        |L7.80|
                  |L7.68|
;;;499    	{
;;;500    		_pBuffer[i] = NAND_DATA_AREA;
000044  f04f40e0          MOV      r0,#0x70000000
000048  7800              LDRB     r0,[r0,#0]
00004a  5538              STRB     r0,[r7,r4]
00004c  1c60              ADDS     r0,r4,#1              ;498
00004e  b284              UXTH     r4,r0                 ;498
                  |L7.80|
000050  4544              CMP      r4,r8                 ;498
000052  dbf7              BLT      |L7.68|
;;;501    	}
;;;502    
;;;503    	return NAND_OK;
000054  2000              MOVS     r0,#0
;;;504    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;505    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      0x70010000
                  |L7.96|
                          DCD      0x70020000
                  |L7.100|
                          DCD      0x40021800

                          AREA ||i.FSMC_NAND_ReadSpare||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_ReadSpare PROC
;;;541    */
;;;542    static uint8_t FSMC_NAND_ReadSpare(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInSpare, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;543    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;544    	if (_usByteCount > NAND_SPARE_AREA_SIZE)
00000c  2d40              CMP      r5,#0x40
00000e  dd02              BLE      |L8.22|
;;;545    	{
;;;546    		return NAND_FAIL;
000010  2001              MOVS     r0,#1
                  |L8.18|
;;;547    	}
;;;548    
;;;549    	return FSMC_NAND_ReadPage(_pBuffer, _ulPageNo, NAND_PAGE_SIZE + _usAddrInSpare, _usByteCount);
;;;550    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L8.22|
000016  f5046000          ADD      r0,r4,#0x800          ;549
00001a  b282              UXTH     r2,r0                 ;549
00001c  462b              MOV      r3,r5                 ;549
00001e  4639              MOV      r1,r7                 ;549
000020  4630              MOV      r0,r6                 ;549
000022  f7fffffe          BL       FSMC_NAND_ReadPage
000026  e7f4              B        |L8.18|
;;;551    
                          ENDP


                          AREA ||i.FSMC_NAND_ReadStatus||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_ReadStatus PROC
;;;653    */
;;;654    static uint8_t FSMC_NAND_ReadStatus(void)
000000  2000              MOVS     r0,#0
;;;655    {
;;;656    	uint8_t ucData;
;;;657    	uint8_t ucStatus = NAND_BUSY;
;;;658    
;;;659    	/* 读状态操作 */
;;;660    	NAND_CMD_AREA = NAND_CMD_STATUS;
000002  2270              MOVS     r2,#0x70
000004  4b08              LDR      r3,|L9.40|
000006  701a              STRB     r2,[r3,#0]
;;;661    	ucData = *(__IO uint8_t *)(Bank_NAND_ADDR);
000008  0612              LSLS     r2,r2,#24
00000a  7811              LDRB     r1,[r2,#0]
;;;662    
;;;663    	if((ucData & NAND_ERROR) == NAND_ERROR)
00000c  f0010201          AND      r2,r1,#1
000010  b10a              CBZ      r2,|L9.22|
;;;664    	{
;;;665    		ucStatus = NAND_ERROR;
000012  2001              MOVS     r0,#1
000014  e006              B        |L9.36|
                  |L9.22|
;;;666    	}
;;;667    	else if((ucData & NAND_READY) == NAND_READY)
000016  f0010240          AND      r2,r1,#0x40
00001a  2a40              CMP      r2,#0x40
00001c  d101              BNE      |L9.34|
;;;668    	{
;;;669    		ucStatus = NAND_READY;
00001e  2040              MOVS     r0,#0x40
000020  e000              B        |L9.36|
                  |L9.34|
;;;670    	}
;;;671    	else
;;;672    	{
;;;673    		ucStatus = NAND_BUSY;
000022  2000              MOVS     r0,#0
                  |L9.36|
;;;674    	}
;;;675    
;;;676    	return (ucStatus);
;;;677    }
000024  4770              BX       lr
;;;678    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0x70010000

                          AREA ||i.FSMC_NAND_Reset||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_Reset PROC
;;;629    */
;;;630    static uint8_t FSMC_NAND_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;631    {
;;;632    	NAND_CMD_AREA = NAND_CMD_RESET;
000002  20ff              MOVS     r0,#0xff
000004  4904              LDR      r1,|L10.24|
000006  7008              STRB     r0,[r1,#0]
;;;633    
;;;634    		/* 检查操作状态 */
;;;635    	if (FSMC_NAND_GetStatus() == NAND_READY)
000008  f7fffffe          BL       FSMC_NAND_GetStatus
00000c  2840              CMP      r0,#0x40
00000e  d101              BNE      |L10.20|
;;;636    	{
;;;637    		return NAND_OK;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;638    	}
;;;639    
;;;640    	return NAND_FAIL;
;;;641    }
000012  bd10              POP      {r4,pc}
                  |L10.20|
000014  2001              MOVS     r0,#1                 ;640
000016  e7fc              B        |L10.18|
;;;642    
                          ENDP

                  |L10.24|
                          DCD      0x70010000

                          AREA ||i.FSMC_NAND_WriteData||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_WriteData PROC
;;;564    */
;;;565    static uint8_t FSMC_NAND_WriteData(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;566    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;567    	if (_usByteCount > NAND_PAGE_SIZE)
00000c  f5b46f00          CMP      r4,#0x800
000010  dd02              BLE      |L11.24|
;;;568    	{
;;;569    		return NAND_FAIL;
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;570    	}
;;;571    
;;;572    	return FSMC_NAND_WritePage(_pBuffer, _ulPageNo, _usAddrInPage, _usByteCount);
;;;573    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L11.24|
000018  4623              MOV      r3,r4                 ;572
00001a  463a              MOV      r2,r7                 ;572
00001c  4631              MOV      r1,r6                 ;572
00001e  4628              MOV      r0,r5                 ;572
000020  f7fffffe          BL       FSMC_NAND_WritePage
000024  e7f6              B        |L11.20|
;;;574    
                          ENDP


                          AREA ||i.FSMC_NAND_WritePage||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_WritePage PROC
;;;424    */
;;;425    static uint8_t FSMC_NAND_WritePage(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;426    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;427    	uint16_t i;
;;;428    
;;;429    	/* 发送页写命令 */
;;;430    	NAND_CMD_AREA = NAND_CMD_WRITE0;
00000c  2080              MOVS     r0,#0x80
00000e  490f              LDR      r1,|L12.76|
000010  7008              STRB     r0,[r1,#0]
;;;431    
;;;432    	/* 发送页内地址 ， 对于 HY27UF081G2A
;;;433    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;434    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;435    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;436    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;437    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;438    	*/
;;;439    	NAND_ADDR_AREA = _usAddrInPage;
000012  490f              LDR      r1,|L12.80|
000014  700d              STRB     r5,[r1,#0]
;;;440    	NAND_ADDR_AREA = _usAddrInPage >> 8;
000016  1228              ASRS     r0,r5,#8
000018  7008              STRB     r0,[r1,#0]
;;;441    	NAND_ADDR_AREA = _ulPageNo;
00001a  700c              STRB     r4,[r1,#0]
;;;442    	NAND_ADDR_AREA = (_ulPageNo & 0xFF00) >> 8;
00001c  0a20              LSRS     r0,r4,#8
00001e  7008              STRB     r0,[r1,#0]
;;;443    
;;;444    	/* 写数据 */
;;;445    	for(i = 0; i < _usByteCount; i++)
000020  2600              MOVS     r6,#0
000022  e005              B        |L12.48|
                  |L12.36|
;;;446    	{
;;;447    		NAND_DATA_AREA = _pBuffer[i];
000024  5db8              LDRB     r0,[r7,r6]
000026  f04f41e0          MOV      r1,#0x70000000
00002a  7008              STRB     r0,[r1,#0]
00002c  1c70              ADDS     r0,r6,#1              ;445
00002e  b286              UXTH     r6,r0                 ;445
                  |L12.48|
000030  4546              CMP      r6,r8                 ;445
000032  dbf7              BLT      |L12.36|
;;;448    	}
;;;449    	NAND_CMD_AREA = NAND_CMD_WRITE_TRUE1;
000034  2010              MOVS     r0,#0x10
000036  4905              LDR      r1,|L12.76|
000038  7008              STRB     r0,[r1,#0]
;;;450    
;;;451    	/* 检查操作状态 */
;;;452    	if (FSMC_NAND_GetStatus() == NAND_READY)
00003a  f7fffffe          BL       FSMC_NAND_GetStatus
00003e  2840              CMP      r0,#0x40
000040  d102              BNE      |L12.72|
;;;453    	{
;;;454    		return NAND_OK;
000042  2000              MOVS     r0,#0
                  |L12.68|
;;;455    	}
;;;456    	return NAND_FAIL;
;;;457    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L12.72|
000048  2001              MOVS     r0,#1                 ;456
00004a  e7fb              B        |L12.68|
;;;458    
                          ENDP

                  |L12.76|
                          DCD      0x70010000
                  |L12.80|
                          DCD      0x70020000

                          AREA ||i.FSMC_NAND_WriteSpare||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_WriteSpare PROC
;;;518    */
;;;519    static uint8_t FSMC_NAND_WriteSpare(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInSpare, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;520    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;521    	if (_usByteCount > NAND_SPARE_AREA_SIZE)
00000c  2d40              CMP      r5,#0x40
00000e  dd02              BLE      |L13.22|
;;;522    	{
;;;523    		return NAND_FAIL;
000010  2001              MOVS     r0,#1
                  |L13.18|
;;;524    	}
;;;525    
;;;526    	return FSMC_NAND_WritePage(_pBuffer, _ulPageNo, NAND_PAGE_SIZE + _usAddrInSpare, _usByteCount);
;;;527    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L13.22|
000016  f5046000          ADD      r0,r4,#0x800          ;526
00001a  b282              UXTH     r2,r0                 ;526
00001c  462b              MOV      r3,r5                 ;526
00001e  4639              MOV      r1,r7                 ;526
000020  4630              MOV      r0,r6                 ;526
000022  f7fffffe          BL       FSMC_NAND_WritePage
000026  e7f4              B        |L13.18|
;;;528    
                          ENDP


                          AREA ||i.NAND_AddrToPhyBlockNo||, CODE, READONLY, ALIGN=2

                  NAND_AddrToPhyBlockNo PROC
;;;1156   */
;;;1157   static uint16_t NAND_AddrToPhyBlockNo(uint32_t _ulMemAddr)
000000  4601              MOV      r1,r0
;;;1158   {
;;;1159   	uint16_t usLBN;		/* 逻辑块号 */
;;;1160   	uint16_t usPBN;		/* 物理块号 */
;;;1161   
;;;1162   	usLBN = _ulMemAddr / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);	/* 计算逻辑块号 */
000002  f64f70ff          MOV      r0,#0xffff
000006  ea004251          AND      r2,r0,r1,LSR #17
;;;1163   	/* 如果逻辑块号大于有效的数据块个数则固定返回0xFFFF, 调用该函数的代码应该检查出这种错误 */
;;;1164   	if (usLBN >= s_usValidDataBlockCount)
00000a  4806              LDR      r0,|L14.36|
00000c  8800              LDRH     r0,[r0,#0]  ; s_usValidDataBlockCount
00000e  4282              CMP      r2,r0
000010  db02              BLT      |L14.24|
;;;1165   	{
;;;1166   		return 0xFFFF;
000012  f64f70ff          MOV      r0,#0xffff
                  |L14.22|
;;;1167   	}
;;;1168   	/* 查询LUT表，获得物理块号 */
;;;1169   	usPBN = s_usLUT[usLBN];
;;;1170   	return usPBN;
;;;1171   }
000016  4770              BX       lr
                  |L14.24|
000018  4803              LDR      r0,|L14.40|
00001a  f8303012          LDRH     r3,[r0,r2,LSL #1]     ;1169
00001e  4618              MOV      r0,r3                 ;1170
000020  e7f9              B        |L14.22|
;;;1172   
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      s_usValidDataBlockCount
                  |L14.40|
                          DCD      s_usLUT

                          AREA ||i.NAND_BuildLUT||, CODE, READONLY, ALIGN=2

                  NAND_BuildLUT PROC
;;;1089   */
;;;1090   static uint8_t NAND_BuildLUT(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1091   {
;;;1092   	uint16_t i;
;;;1093   	uint8_t buf[VALID_SPARE_SIZE];
;;;1094   	uint16_t usLBN;	/* 逻辑块号 */
;;;1095   
;;;1096   	/* */
;;;1097   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e006              B        |L15.20|
                  |L15.6|
;;;1098   	{
;;;1099   		s_usLUT[i] = 0xFFFF;	/* 填充无效值，用于重建LUT后，判断LUT是否合理 */
000006  f64f70ff          MOV      r0,#0xffff
00000a  492c              LDR      r1,|L15.188|
00000c  f8210014          STRH     r0,[r1,r4,LSL #1]
000010  1c60              ADDS     r0,r4,#1              ;1097
000012  b284              UXTH     r4,r0                 ;1097
                  |L15.20|
000014  f5b46f80          CMP      r4,#0x400             ;1097
000018  dbf5              BLT      |L15.6|
;;;1100   	}
;;;1101   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
00001a  2400              MOVS     r4,#0
00001c  e021              B        |L15.98|
                  |L15.30|
;;;1102   	{
;;;1103   		/* 读每个块的第1个PAGE，偏移地址为LBN0_OFFSET的数据 */
;;;1104   		FSMC_NAND_ReadSpare(buf, i * NAND_BLOCK_SIZE, 0, VALID_SPARE_SIZE);
00001e  01a1              LSLS     r1,r4,#6
000020  2304              MOVS     r3,#4
000022  2200              MOVS     r2,#0
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1105   
;;;1106   		/* 如果是好块，则记录LBN0 LBN1 */
;;;1107   		if (buf[BI_OFFSET] == 0xFF)
00002a  f89d0000          LDRB     r0,[sp,#0]
00002e  28ff              CMP      r0,#0xff
000030  d115              BNE      |L15.94|
;;;1108   		{
;;;1109   			usLBN = buf[LBN0_OFFSET] + buf[LBN1_OFFSET] * 256;	/* 计算读出的逻辑块号 */
000032  f89d1002          LDRB     r1,[sp,#2]
000036  f89d0003          LDRB     r0,[sp,#3]
00003a  eb012000          ADD      r0,r1,r0,LSL #8
00003e  b285              UXTH     r5,r0
;;;1110   			if (usLBN < NAND_BLOCK_COUNT)
000040  f5b56f80          CMP      r5,#0x400
000044  da0b              BGE      |L15.94|
;;;1111   			{
;;;1112   				/* 如果已经登记过了，则判定为异常 */
;;;1113   				if (s_usLUT[usLBN] != 0xFFFF)
000046  481d              LDR      r0,|L15.188|
000048  f8300015          LDRH     r0,[r0,r5,LSL #1]
00004c  f64f71ff          MOV      r1,#0xffff
000050  4288              CMP      r0,r1
000052  d001              BEQ      |L15.88|
;;;1114   				{
;;;1115   					return NAND_FAIL;
000054  2001              MOVS     r0,#1
                  |L15.86|
;;;1116   				}
;;;1117   
;;;1118   				s_usLUT[usLBN] = i;	/* 更新LUT表 */
;;;1119   			}
;;;1120   		}
;;;1121   	}
;;;1122   
;;;1123   	/* LUT建立完毕，检查是否合理 */
;;;1124   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
;;;1125   	{
;;;1126   		if (s_usLUT[i] >= NAND_BLOCK_COUNT)
;;;1127   		{
;;;1128   			s_usValidDataBlockCount = i;
;;;1129   			break;
;;;1130   		}
;;;1131   	}
;;;1132   	if (s_usValidDataBlockCount < 100)
;;;1133   	{
;;;1134   		/* 错误： 最大的有效逻辑块号小于100。可能是没有格式化 */
;;;1135   		return NAND_FAIL;
;;;1136   	}
;;;1137   	for (; i < s_usValidDataBlockCount; i++)
;;;1138   	{
;;;1139   		if (s_usLUT[i] != 0xFFFF)
;;;1140   		{
;;;1141   			return NAND_FAIL;	/* 错误：LUT表逻辑块号存在跳跃现象，可能是没有格式化 */
;;;1142   		}
;;;1143   	}
;;;1144   
;;;1145   	/* 重建LUT正常 */
;;;1146   	return NAND_OK;
;;;1147   }
000056  bd38              POP      {r3-r5,pc}
                  |L15.88|
000058  4818              LDR      r0,|L15.188|
00005a  f8204015          STRH     r4,[r0,r5,LSL #1]     ;1118
                  |L15.94|
00005e  1c60              ADDS     r0,r4,#1              ;1101
000060  b284              UXTH     r4,r0                 ;1101
                  |L15.98|
000062  f5b46f80          CMP      r4,#0x400             ;1101
000066  dbda              BLT      |L15.30|
000068  2400              MOVS     r4,#0                 ;1124
00006a  e00a              B        |L15.130|
                  |L15.108|
00006c  4813              LDR      r0,|L15.188|
00006e  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;1126
000072  f5b06f80          CMP      r0,#0x400             ;1126
000076  db02              BLT      |L15.126|
000078  4811              LDR      r0,|L15.192|
00007a  8004              STRH     r4,[r0,#0]            ;1128
00007c  e004              B        |L15.136|
                  |L15.126|
00007e  1c60              ADDS     r0,r4,#1              ;1124
000080  b284              UXTH     r4,r0                 ;1124
                  |L15.130|
000082  f5b46f80          CMP      r4,#0x400             ;1124
000086  dbf1              BLT      |L15.108|
                  |L15.136|
000088  bf00              NOP                            ;1129
00008a  480d              LDR      r0,|L15.192|
00008c  8800              LDRH     r0,[r0,#0]            ;1132  ; s_usValidDataBlockCount
00008e  2864              CMP      r0,#0x64              ;1132
000090  da01              BGE      |L15.150|
000092  2001              MOVS     r0,#1                 ;1135
000094  e7df              B        |L15.86|
                  |L15.150|
000096  e00a              B        |L15.174|
                  |L15.152|
000098  4808              LDR      r0,|L15.188|
00009a  f8300014          LDRH     r0,[r0,r4,LSL #1]     ;1139
00009e  f64f71ff          MOV      r1,#0xffff            ;1139
0000a2  4288              CMP      r0,r1                 ;1139
0000a4  d001              BEQ      |L15.170|
0000a6  2001              MOVS     r0,#1                 ;1141
0000a8  e7d5              B        |L15.86|
                  |L15.170|
0000aa  1c60              ADDS     r0,r4,#1              ;1137
0000ac  b284              UXTH     r4,r0                 ;1137
                  |L15.174|
0000ae  4804              LDR      r0,|L15.192|
0000b0  8800              LDRH     r0,[r0,#0]            ;1137  ; s_usValidDataBlockCount
0000b2  4284              CMP      r4,r0                 ;1137
0000b4  dbf0              BLT      |L15.152|
0000b6  2000              MOVS     r0,#0                 ;1146
0000b8  e7cd              B        |L15.86|
;;;1148   
                          ENDP

0000ba  0000              DCW      0x0000
                  |L15.188|
                          DCD      s_usLUT
                  |L15.192|
                          DCD      s_usValidDataBlockCount

                          AREA ||i.NAND_DispBadBlockInfo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_DispBadBlockInfo PROC
;;;1532   */
;;;1533   void NAND_DispBadBlockInfo(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1534   {
;;;1535   	uint32_t id;
;;;1536   	uint32_t i;
;;;1537   	uint32_t n;
;;;1538   
;;;1539   	FSMC_NAND_Init();	/* 初始化FSMC */
000002  f7fffffe          BL       FSMC_NAND_Init
;;;1540   
;;;1541   	id = NAND_ReadID();
000006  f7fffffe          BL       NAND_ReadID
00000a  4605              MOV      r5,r0
;;;1542   
;;;1543   	printf("NAND Flash ID = 0x%04X, Type = ", id);
00000c  4629              MOV      r1,r5
00000e  a023              ADR      r0,|L16.156|
000010  f7fffffe          BL       __2printf
;;;1544   	if (id == HY27UF081G2A)
000014  4829              LDR      r0,|L16.188|
000016  4285              CMP      r5,r0
000018  d103              BNE      |L16.34|
;;;1545   	{
;;;1546   		printf("HY27UF081G2A\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
00001a  4829              LDR      r0,|L16.192|
00001c  f7fffffe          BL       __2printf
000020  e011              B        |L16.70|
                  |L16.34|
;;;1547   	}
;;;1548   	else if (id == K9F1G08U0A)
000022  4828              LDR      r0,|L16.196|
000024  4285              CMP      r5,r0
000026  d103              BNE      |L16.48|
;;;1549   	{
;;;1550   		printf("K9F1G08U0A\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
000028  4827              LDR      r0,|L16.200|
00002a  f7fffffe          BL       __2printf
00002e  e00a              B        |L16.70|
                  |L16.48|
;;;1551   	}
;;;1552   	else if (id == K9F1G08U0B)
000030  4826              LDR      r0,|L16.204|
000032  4285              CMP      r5,r0
000034  d103              BNE      |L16.62|
;;;1553   	{
;;;1554   		printf("K9F1G08U0B\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
000036  4826              LDR      r0,|L16.208|
000038  f7fffffe          BL       __2printf
00003c  e003              B        |L16.70|
                  |L16.62|
;;;1555   	}
;;;1556   	else
;;;1557   	{
;;;1558   		printf("unkonow\r\n");
00003e  a025              ADR      r0,|L16.212|
000040  f7fffffe          BL       __2printf
                  |L16.68|
;;;1559   		return;
;;;1560   	}
;;;1561   
;;;1562   	printf("Block Info : 0 is OK, * is Bad\r\n");
;;;1563   	n = 0;	/* 坏块统计 */
;;;1564   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
;;;1565   	{
;;;1566   		if (NAND_IsBadBlock(i))
;;;1567   		{
;;;1568   			printf("*");
;;;1569   			n++;
;;;1570   		}
;;;1571   		else
;;;1572   		{
;;;1573   			printf("0");
;;;1574   		}
;;;1575   
;;;1576   		if (((i + 1) % 8) == 0)
;;;1577   		{
;;;1578   			printf(" ");
;;;1579   		}
;;;1580   
;;;1581   		if (((i + 1) % 64) == 0)
;;;1582   		{
;;;1583   			printf("\r\n");
;;;1584   		}
;;;1585   	}
;;;1586   	printf("Bad Block Count = %d\r\n", n);
;;;1587   }
000044  bd70              POP      {r4-r6,pc}
                  |L16.70|
000046  a026              ADR      r0,|L16.224|
000048  f7fffffe          BL       __2printf
00004c  2600              MOVS     r6,#0                 ;1563
00004e  2400              MOVS     r4,#0                 ;1564
000050  e01a              B        |L16.136|
                  |L16.82|
000052  4620              MOV      r0,r4                 ;1566
000054  f7fffffe          BL       NAND_IsBadBlock
000058  b120              CBZ      r0,|L16.100|
00005a  a02a              ADR      r0,|L16.260|
00005c  f7fffffe          BL       __2printf
000060  1c76              ADDS     r6,r6,#1              ;1569
000062  e002              B        |L16.106|
                  |L16.100|
000064  a028              ADR      r0,|L16.264|
000066  f7fffffe          BL       __2printf
                  |L16.106|
00006a  1c60              ADDS     r0,r4,#1              ;1576
00006c  f0000007          AND      r0,r0,#7              ;1576
000070  b910              CBNZ     r0,|L16.120|
000072  a026              ADR      r0,|L16.268|
000074  f7fffffe          BL       __2printf
                  |L16.120|
000078  1c60              ADDS     r0,r4,#1              ;1581
00007a  f000003f          AND      r0,r0,#0x3f           ;1581
00007e  b910              CBNZ     r0,|L16.134|
000080  a023              ADR      r0,|L16.272|
000082  f7fffffe          BL       __2printf
                  |L16.134|
000086  1c64              ADDS     r4,r4,#1              ;1564
                  |L16.136|
000088  f5b46f80          CMP      r4,#0x400             ;1564
00008c  d3e1              BCC      |L16.82|
00008e  4631              MOV      r1,r6                 ;1586
000090  a020              ADR      r0,|L16.276|
000092  f7fffffe          BL       __2printf
000096  bf00              NOP      
000098  e7d4              B        |L16.68|
;;;1588   
                          ENDP

00009a  0000              DCW      0x0000
                  |L16.156|
00009c  4e414e44          DCB      "NAND Flash ID = 0x%04X, Type = ",0
0000a0  20466c61
0000a4  73682049
0000a8  44203d20
0000ac  30782530
0000b0  34582c20
0000b4  54797065
0000b8  203d2000
                  |L16.188|
                          DCD      0xadf1801d
                  |L16.192|
                          DCD      ||.conststring||
                  |L16.196|
                          DCD      0xecf18015
                  |L16.200|
                          DCD      ||.conststring||+0x4c
                  |L16.204|
                          DCD      0xecf10095
                  |L16.208|
                          DCD      ||.conststring||+0x98
                  |L16.212|
0000d4  756e6b6f          DCB      "unkonow\r\n",0
0000d8  6e6f770d
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L16.224|
0000e0  426c6f63          DCB      "Block Info : 0 is OK, * is Bad\r\n",0
0000e4  6b20496e
0000e8  666f203a
0000ec  20302069
0000f0  73204f4b
0000f4  2c202a20
0000f8  69732042
0000fc  61640d0a
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L16.260|
000104  2a00              DCB      "*",0
000106  00                DCB      0
000107  00                DCB      0
                  |L16.264|
000108  3000              DCB      "0",0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L16.268|
00010c  2000              DCB      " ",0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L16.272|
000110  0d0a00            DCB      "\r\n",0
000113  00                DCB      0
                  |L16.276|
000114  42616420          DCB      "Bad Block Count = %d\r\n",0
000118  426c6f63
00011c  6b20436f
000120  756e7420
000124  3d202564
000128  0d0a00  
00012b  00                DCB      0

                          AREA ||i.NAND_DispLogicPageData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_DispLogicPageData PROC
;;;1652   */
;;;1653   void NAND_DispLogicPageData(uint32_t _uiLogicPageNo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1654   {
000004  4604              MOV      r4,r0
;;;1655   	uint32_t uiPhyPageNo;
;;;1656   	uint16_t usLBN;	/* 逻辑块号 */
;;;1657   	uint16_t usPBN;	/* 物理块号 */
;;;1658   
;;;1659   	usLBN = _uiLogicPageNo / NAND_BLOCK_SIZE;
000006  f3c4178f          UBFX     r7,r4,#6,#16
;;;1660   	usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       NAND_LBNtoPBN
000010  4605              MOV      r5,r0
;;;1661   	if (usPBN >= NAND_BLOCK_COUNT)
000012  f5b56f80          CMP      r5,#0x400
000016  db01              BLT      |L17.28|
                  |L17.24|
;;;1662   	{
;;;1663   		/* 没有格式化，usPBN = 0xFFFF */
;;;1664   		return;
;;;1665   	}
;;;1666   
;;;1667   	printf("LogicBlock = %d, PhyBlock = %d\r\n", _uiLogicPageNo, usPBN);
;;;1668   
;;;1669   	/* 计算物理页号 */
;;;1670   	uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + _uiLogicPageNo % NAND_BLOCK_SIZE;
;;;1671   	NAND_DispPhyPageData(uiPhyPageNo);	/* 显示指定页数据 */
;;;1672   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L17.28|
00001c  462a              MOV      r2,r5                 ;1667
00001e  4621              MOV      r1,r4                 ;1667
000020  a005              ADR      r0,|L17.56|
000022  f7fffffe          BL       __2printf
000026  f004003f          AND      r0,r4,#0x3f           ;1670
00002a  eb001685          ADD      r6,r0,r5,LSL #6       ;1670
00002e  4630              MOV      r0,r6                 ;1671
000030  f7fffffe          BL       NAND_DispPhyPageData
000034  bf00              NOP      
000036  e7ef              B        |L17.24|
;;;1673   
                          ENDP

                  |L17.56|
000038  4c6f6769          DCB      "LogicBlock = %d, PhyBlock = %d\r\n",0
00003c  63426c6f
000040  636b203d
000044  2025642c
000048  20506879
00004c  426c6f63
000050  6b203d20
000054  25640d0a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.NAND_DispPhyPageData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  NAND_DispPhyPageData PROC
;;;1596   */
;;;1597   void NAND_DispPhyPageData(uint32_t _uiPhyPageNo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1598   {
000004  4606              MOV      r6,r0
;;;1599   	uint32_t i, n;
;;;1600   	uint32_t ulBlockNo;
;;;1601   	uint16_t usOffsetPageNo;
;;;1602   
;;;1603   	ulBlockNo = _uiPhyPageNo / NAND_BLOCK_SIZE;		/* 根据物理页号反推块号 */
000006  09b7              LSRS     r7,r6,#6
;;;1604   	usOffsetPageNo = _uiPhyPageNo % NAND_BLOCK_SIZE;	/* 根据物理页号计算物理页号在块内偏移页号 */
000008  f006083f          AND      r8,r6,#0x3f
;;;1605   
;;;1606   	if (NAND_OK != FSMC_NAND_ReadPage(s_ucTempBuf, _uiPhyPageNo, 0, NAND_PAGE_TOTAL_SIZE))
00000c  f44f6304          MOV      r3,#0x840
000010  2200              MOVS     r2,#0
000012  4631              MOV      r1,r6
000014  4823              LDR      r0,|L18.164|
000016  f7fffffe          BL       FSMC_NAND_ReadPage
00001a  b120              CBZ      r0,|L18.38|
;;;1607   	{
;;;1608   		printf("FSMC_NAND_ReadPage Failed() \r\n");
00001c  a022              ADR      r0,|L18.168|
00001e  f7fffffe          BL       __2printf
                  |L18.34|
;;;1609   		return;
;;;1610   	}
;;;1611   
;;;1612   	printf("Block = %d, Page = %d\r\n", ulBlockNo, usOffsetPageNo);
;;;1613   
;;;1614   	/* 打印前面 2048字节数据，每512字节空一行 */
;;;1615   	for (n = 0; n < 4; n++)
;;;1616   	{
;;;1617   		for (i = 0; i < 512; i++)
;;;1618   		{
;;;1619   			printf(" %02X", s_ucTempBuf[i + n * 512]);
;;;1620   
;;;1621   			if ((i & 31) == 31)
;;;1622   			{
;;;1623   				printf("\r\n");	/* 每行显示32字节数据 */
;;;1624   			}
;;;1625   			else if ((i & 31) == 15)
;;;1626   			{
;;;1627   				printf(" - ");
;;;1628   			}
;;;1629   		}
;;;1630   		printf("\r\n");
;;;1631   	}
;;;1632   
;;;1633   	/* 打印前面 2048字节数据，每512字节空一行 */
;;;1634   	for (i = 0; i < 64; i++)
;;;1635   	{
;;;1636   		printf(" %02X", s_ucTempBuf[i + 2048]);
;;;1637   
;;;1638   		if ((i & 15) == 15)
;;;1639   		{
;;;1640   			printf("\r\n");	/* 每行显示32字节数据 */
;;;1641   		}
;;;1642   	}
;;;1643   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L18.38|
000026  4642              MOV      r2,r8                 ;1612
000028  4639              MOV      r1,r7                 ;1612
00002a  a027              ADR      r0,|L18.200|
00002c  f7fffffe          BL       __2printf
000030  2500              MOVS     r5,#0                 ;1615
000032  e01f              B        |L18.116|
                  |L18.52|
000034  2400              MOVS     r4,#0                 ;1617
000036  e016              B        |L18.102|
                  |L18.56|
000038  eb042045          ADD      r0,r4,r5,LSL #9       ;1619
00003c  4a19              LDR      r2,|L18.164|
00003e  5c11              LDRB     r1,[r2,r0]            ;1619
000040  a027              ADR      r0,|L18.224|
000042  f7fffffe          BL       __2printf
000046  f004001f          AND      r0,r4,#0x1f           ;1621
00004a  281f              CMP      r0,#0x1f              ;1621
00004c  d103              BNE      |L18.86|
00004e  a01d              ADR      r0,|L18.196|
000050  f7fffffe          BL       __2printf
000054  e006              B        |L18.100|
                  |L18.86|
000056  f004001f          AND      r0,r4,#0x1f           ;1625
00005a  280f              CMP      r0,#0xf               ;1625
00005c  d102              BNE      |L18.100|
00005e  a022              ADR      r0,|L18.232|
000060  f7fffffe          BL       __2printf
                  |L18.100|
000064  1c64              ADDS     r4,r4,#1              ;1617
                  |L18.102|
000066  f5b47f00          CMP      r4,#0x200             ;1617
00006a  d3e5              BCC      |L18.56|
00006c  a015              ADR      r0,|L18.196|
00006e  f7fffffe          BL       __2printf
000072  1c6d              ADDS     r5,r5,#1              ;1615
                  |L18.116|
000074  2d04              CMP      r5,#4                 ;1615
000076  d3dd              BCC      |L18.52|
000078  2400              MOVS     r4,#0                 ;1634
00007a  e00e              B        |L18.154|
                  |L18.124|
00007c  4a09              LDR      r2,|L18.164|
00007e  f5046000          ADD      r0,r4,#0x800          ;1636
000082  5c11              LDRB     r1,[r2,r0]            ;1636
000084  a016              ADR      r0,|L18.224|
000086  f7fffffe          BL       __2printf
00008a  f004000f          AND      r0,r4,#0xf            ;1638
00008e  280f              CMP      r0,#0xf               ;1638
000090  d102              BNE      |L18.152|
000092  a00c              ADR      r0,|L18.196|
000094  f7fffffe          BL       __2printf
                  |L18.152|
000098  1c64              ADDS     r4,r4,#1              ;1634
                  |L18.154|
00009a  2c40              CMP      r4,#0x40              ;1634
00009c  d3ee              BCC      |L18.124|
00009e  bf00              NOP      
0000a0  e7bf              B        |L18.34|
;;;1644   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L18.164|
                          DCD      s_ucTempBuf
                  |L18.168|
0000a8  46534d43          DCB      "FSMC_NAND_ReadPage Failed() "
0000ac  5f4e414e
0000b0  445f5265
0000b4  61645061
0000b8  67652046
0000bc  61696c65
0000c0  64282920
                  |L18.196|
0000c4  0d0a00            DCB      "\r\n",0
0000c7  00                DCB      0
                  |L18.200|
0000c8  426c6f63          DCB      "Block = %d, Page = %d\r\n",0
0000cc  6b203d20
0000d0  25642c20
0000d4  50616765
0000d8  203d2025
0000dc  640d0a00
                  |L18.224|
0000e0  20253032          DCB      " %02X",0
0000e4  5800    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L18.232|
0000e8  202d2000          DCB      " - ",0

                          AREA ||i.NAND_FindFreeBlock||, CODE, READONLY, ALIGN=1

                  NAND_FindFreeBlock PROC
;;;1202   */
;;;1203   static uint16_t NAND_FindFreeBlock (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1204   {
;;;1205   	uint16_t i;
;;;1206   	uint16_t n;
;;;1207   
;;;1208   	n = NAND_BLOCK_COUNT - 1;
000002  f24035ff          MOV      r5,#0x3ff
;;;1209   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
000006  2400              MOVS     r4,#0
000008  e009              B        |L19.30|
                  |L19.10|
;;;1210   	{
;;;1211   		if (NAND_IsFreeBlock(n))
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       NAND_IsFreeBlock
000010  b108              CBZ      r0,|L19.22|
;;;1212   		{
;;;1213   			return n;
000012  4628              MOV      r0,r5
                  |L19.20|
;;;1214   		}
;;;1215   		n--;
;;;1216   	}
;;;1217   	return 0xFFFF;
;;;1218   }
000014  bd70              POP      {r4-r6,pc}
                  |L19.22|
000016  1e68              SUBS     r0,r5,#1              ;1215
000018  b285              UXTH     r5,r0                 ;1215
00001a  1c60              ADDS     r0,r4,#1              ;1209
00001c  b284              UXTH     r4,r0                 ;1209
                  |L19.30|
00001e  f5b46f80          CMP      r4,#0x400             ;1209
000022  dbf2              BLT      |L19.10|
000024  f64f70ff          MOV      r0,#0xffff            ;1217
000028  e7f4              B        |L19.20|
;;;1219   
                          ENDP


                          AREA ||i.NAND_Format||, CODE, READONLY, ALIGN=1

                  NAND_Format PROC
;;;1458   */
;;;1459   uint8_t NAND_Format(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1460   {
;;;1461   	uint16_t i, n;
;;;1462   	uint16_t usGoodBlockCount;
;;;1463   
;;;1464   	/* 擦除每个块 */
;;;1465   	usGoodBlockCount = 0;
000002  2500              MOVS     r5,#0
;;;1466   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
000004  2400              MOVS     r4,#0
000006  e00a              B        |L20.30|
                  |L20.8|
;;;1467   	{
;;;1468   		/* 如果是好块，则擦除 */
;;;1469   		if (!NAND_IsBadBlock(i))
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       NAND_IsBadBlock
00000e  b920              CBNZ     r0,|L20.26|
;;;1470   		{
;;;1471   			FSMC_NAND_EraseBlock(i);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       FSMC_NAND_EraseBlock
;;;1472   			usGoodBlockCount++;
000016  1c68              ADDS     r0,r5,#1
000018  b285              UXTH     r5,r0
                  |L20.26|
00001a  1c60              ADDS     r0,r4,#1              ;1466
00001c  b284              UXTH     r4,r0                 ;1466
                  |L20.30|
00001e  f5b46f80          CMP      r4,#0x400             ;1466
000022  dbf1              BLT      |L20.8|
;;;1473   		}
;;;1474   	}
;;;1475   
;;;1476   	/* 如果好块的数量少于100，则NAND Flash报废 */
;;;1477   	if (usGoodBlockCount < 100)
000024  2d64              CMP      r5,#0x64
000026  da01              BGE      |L20.44|
;;;1478   	{
;;;1479   		return NAND_FAIL;
000028  2001              MOVS     r0,#1
                  |L20.42|
;;;1480   	}
;;;1481   
;;;1482   	usGoodBlockCount = (usGoodBlockCount * 98) / 100;	/* 98%的好块用于存储数据 */
;;;1483   
;;;1484   	/* 重新搜索一次 */
;;;1485   	n = 0; /* 统计已标注的好块 */
;;;1486   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
;;;1487   	{
;;;1488   		if (!NAND_IsBadBlock(i))
;;;1489   		{
;;;1490   			/* 如果是好块，则在该块的第1个PAGE的LBN0 LBN1处写入n值 (前面已经执行了块擦除） */
;;;1491   			FSMC_NAND_WriteSpare((uint8_t *)&n, i * NAND_BLOCK_SIZE, LBN0_OFFSET, 2);
;;;1492   			n++;
;;;1493   
;;;1494   			/* 计算并写入每个扇区的ECC值 （暂时未作）*/
;;;1495   
;;;1496   			if (n == usGoodBlockCount)
;;;1497   			{
;;;1498   				break;
;;;1499   			}
;;;1500   		}
;;;1501   	}
;;;1502   
;;;1503   	NAND_BuildLUT();	/* 初始化LUT表 */
;;;1504   	return NAND_OK;
;;;1505   }
00002a  bd38              POP      {r3-r5,pc}
                  |L20.44|
00002c  2062              MOVS     r0,#0x62              ;1482
00002e  4368              MULS     r0,r5,r0              ;1482
000030  2164              MOVS     r1,#0x64              ;1482
000032  fb90f0f1          SDIV     r0,r0,r1              ;1482
000036  b285              UXTH     r5,r0                 ;1482
000038  2000              MOVS     r0,#0                 ;1485
00003a  9000              STR      r0,[sp,#0]            ;1485
00003c  2400              MOVS     r4,#0                 ;1486
00003e  e015              B        |L20.108|
                  |L20.64|
000040  4620              MOV      r0,r4                 ;1488
000042  f7fffffe          BL       NAND_IsBadBlock
000046  b978              CBNZ     r0,|L20.104|
000048  01a1              LSLS     r1,r4,#6              ;1491
00004a  2302              MOVS     r3,#2                 ;1491
00004c  461a              MOV      r2,r3                 ;1491
00004e  4668              MOV      r0,sp                 ;1491
000050  f7fffffe          BL       FSMC_NAND_WriteSpare
000054  f8bd0000          LDRH     r0,[sp,#0]            ;1492
000058  1c40              ADDS     r0,r0,#1              ;1492
00005a  b280              UXTH     r0,r0                 ;1492
00005c  9000              STR      r0,[sp,#0]            ;1492
00005e  f8bd0000          LDRH     r0,[sp,#0]            ;1496
000062  42a8              CMP      r0,r5                 ;1496
000064  d100              BNE      |L20.104|
000066  e004              B        |L20.114|
                  |L20.104|
000068  1c60              ADDS     r0,r4,#1              ;1486
00006a  b284              UXTH     r4,r0                 ;1486
                  |L20.108|
00006c  f5b46f80          CMP      r4,#0x400             ;1486
000070  dbe6              BLT      |L20.64|
                  |L20.114|
000072  bf00              NOP                            ;1498
000074  f7fffffe          BL       NAND_BuildLUT
000078  2000              MOVS     r0,#0                 ;1504
00007a  e7d6              B        |L20.42|
;;;1506   
                          ENDP


                          AREA ||i.NAND_FormatCapacity||, CODE, READONLY, ALIGN=2

                  NAND_FormatCapacity PROC
;;;1514   */
;;;1515   uint32_t NAND_FormatCapacity(void)
000000  4804              LDR      r0,|L21.20|
;;;1516   {
;;;1517   	uint16_t usCount;
;;;1518   
;;;1519   	/* 计算用于存储数据的数据块个数，按照总有效块数的98%来计算 */
;;;1520   	usCount = (s_usValidDataBlockCount * DATA_BLOCK_PERCENT) / 100;
000002  8800              LDRH     r0,[r0,#0]  ; s_usValidDataBlockCount
000004  2262              MOVS     r2,#0x62
000006  4350              MULS     r0,r2,r0
000008  2264              MOVS     r2,#0x64
00000a  fb90f1f2          SDIV     r1,r0,r2
;;;1521   
;;;1522   	return (usCount * NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
00000e  0448              LSLS     r0,r1,#17
;;;1523   }
000010  4770              BX       lr
;;;1524   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      s_usValidDataBlockCount

                          AREA ||i.NAND_Init||, CODE, READONLY, ALIGN=1

                  NAND_Init PROC
;;;721    */
;;;722    uint8_t NAND_Init(void)
000000  b510              PUSH     {r4,lr}
;;;723    {
;;;724    	uint8_t Status;
;;;725    
;;;726    	FSMC_NAND_Init();			/* 配置FSMC和GPIO用于NAND Flash接口 */
000002  f7fffffe          BL       FSMC_NAND_Init
;;;727    
;;;728    	FSMC_NAND_Reset();			/* 通过复位命令复位NAND Flash到读状态 */
000006  f7fffffe          BL       FSMC_NAND_Reset
;;;729    
;;;730    	Status = NAND_BuildLUT();	/* 建立块管理表 LUT = Look up table */
00000a  f7fffffe          BL       NAND_BuildLUT
00000e  4604              MOV      r4,r0
;;;731    	return Status;
000010  4620              MOV      r0,r4
;;;732    }
000012  bd10              POP      {r4,pc}
;;;733    
                          ENDP


                          AREA ||i.NAND_IsBadBlock||, CODE, READONLY, ALIGN=1

                  NAND_IsBadBlock PROC
;;;1252   */
;;;1253    uint8_t NAND_IsBadBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1254   {
000002  4604              MOV      r4,r0
;;;1255   	uint8_t ucFlag;
;;;1256   
;;;1257   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1258   	FSMC_NAND_ReadSpare(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE, BI_OFFSET, 1);
000004  01a1              LSLS     r1,r4,#6
000006  2301              MOVS     r3,#1
000008  2200              MOVS     r2,#0
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1259   	if (ucFlag != 0xFF)
000010  f89d0000          LDRB     r0,[sp,#0]
000014  28ff              CMP      r0,#0xff
000016  d001              BEQ      |L23.28|
;;;1260   	{
;;;1261   		return 1;
000018  2001              MOVS     r0,#1
                  |L23.26|
;;;1262   	}
;;;1263   
;;;1264   	FSMC_NAND_ReadSpare(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE + 1, BI_OFFSET, 1);
;;;1265   	if (ucFlag != 0xFF)
;;;1266   	{
;;;1267   		return 1;
;;;1268   	}
;;;1269   	return 0;	/* 是好块 */
;;;1270   }
00001a  bd38              POP      {r3-r5,pc}
                  |L23.28|
00001c  2001              MOVS     r0,#1                 ;1264
00001e  eb001184          ADD      r1,r0,r4,LSL #6       ;1264
000022  4603              MOV      r3,r0                 ;1264
000024  2200              MOVS     r2,#0                 ;1264
000026  4668              MOV      r0,sp                 ;1264
000028  f7fffffe          BL       FSMC_NAND_ReadSpare
00002c  f89d0000          LDRB     r0,[sp,#0]            ;1265
000030  28ff              CMP      r0,#0xff              ;1265
000032  d001              BEQ      |L23.56|
000034  2001              MOVS     r0,#1                 ;1267
000036  e7f0              B        |L23.26|
                  |L23.56|
000038  2000              MOVS     r0,#0                 ;1269
00003a  e7ee              B        |L23.26|
;;;1271   
                          ENDP


                          AREA ||i.NAND_IsBufOk||, CODE, READONLY, ALIGN=1

                  NAND_IsBufOk PROC
;;;1229   */
;;;1230   static uint8_t NAND_IsBufOk(uint8_t *_pBuf, uint32_t _ulLen, uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;1231   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1232   	uint32_t i;
;;;1233   
;;;1234   	for (i = 0; i < _ulLen; i++)
000006  2100              MOVS     r1,#0
000008  e005              B        |L24.22|
                  |L24.10|
;;;1235   	{
;;;1236   		if (_pBuf[i] != _ucValue)
00000a  5c58              LDRB     r0,[r3,r1]
00000c  4290              CMP      r0,r2
00000e  d001              BEQ      |L24.20|
;;;1237   		{
;;;1238   			return 0;
000010  2000              MOVS     r0,#0
                  |L24.18|
;;;1239   		}
;;;1240   	}
;;;1241   
;;;1242   	return 1;
;;;1243   }
000012  bd10              POP      {r4,pc}
                  |L24.20|
000014  1c49              ADDS     r1,r1,#1              ;1234
                  |L24.22|
000016  42a1              CMP      r1,r4                 ;1234
000018  d3f7              BCC      |L24.10|
00001a  2001              MOVS     r0,#1                 ;1242
00001c  e7f9              B        |L24.18|
;;;1244   
                          ENDP


                          AREA ||i.NAND_IsFreeBlock||, CODE, READONLY, ALIGN=1

                  NAND_IsFreeBlock PROC
;;;1279   */
;;;1280   static uint8_t NAND_IsFreeBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1281   {
000002  4604              MOV      r4,r0
;;;1282   	uint8_t ucFlag;
;;;1283   
;;;1284   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1285   	if (NAND_IsBadBlock(_ulBlockNo))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       NAND_IsBadBlock
00000a  b108              CBZ      r0,|L25.16|
;;;1286   	{
;;;1287   		return 0;
00000c  2000              MOVS     r0,#0
                  |L25.14|
;;;1288   	}
;;;1289   
;;;1290   	FSMC_NAND_ReadPage(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE, USED_OFFSET, 1);
;;;1291   	if (ucFlag == 0xFF)
;;;1292   	{
;;;1293   		return 1;
;;;1294   	}
;;;1295   	return 0;
;;;1296   }
00000e  bd38              POP      {r3-r5,pc}
                  |L25.16|
000010  01a1              LSLS     r1,r4,#6              ;1290
000012  2301              MOVS     r3,#1                 ;1290
000014  461a              MOV      r2,r3                 ;1290
000016  4668              MOV      r0,sp                 ;1290
000018  f7fffffe          BL       FSMC_NAND_ReadPage
00001c  f89d0000          LDRB     r0,[sp,#0]            ;1291
000020  28ff              CMP      r0,#0xff              ;1291
000022  d101              BNE      |L25.40|
000024  2001              MOVS     r0,#1                 ;1293
000026  e7f2              B        |L25.14|
                  |L25.40|
000028  2000              MOVS     r0,#0                 ;1295
00002a  e7f0              B        |L25.14|
;;;1297   
                          ENDP


                          AREA ||i.NAND_LBNtoPBN||, CODE, READONLY, ALIGN=2

                  NAND_LBNtoPBN PROC
;;;1180   */
;;;1181   static uint16_t NAND_LBNtoPBN(uint32_t _uiLBN)
000000  4601              MOV      r1,r0
;;;1182   {
;;;1183   	uint16_t usPBN;		/* 物理块号 */
;;;1184   
;;;1185   	/* 如果逻辑块号大于有效的数据块个数则固定返回0xFFFF, 调用该函数的代码应该检查出这种错误 */
;;;1186   	if (_uiLBN >= s_usValidDataBlockCount)
000002  4806              LDR      r0,|L26.28|
000004  8800              LDRH     r0,[r0,#0]  ; s_usValidDataBlockCount
000006  4281              CMP      r1,r0
000008  d302              BCC      |L26.16|
;;;1187   	{
;;;1188   		return 0xFFFF;
00000a  f64f70ff          MOV      r0,#0xffff
                  |L26.14|
;;;1189   	}
;;;1190   	/* 查询LUT表，获得物理块号 */
;;;1191   	usPBN = s_usLUT[_uiLBN];
;;;1192   	return usPBN;
;;;1193   }
00000e  4770              BX       lr
                  |L26.16|
000010  4803              LDR      r0,|L26.32|
000012  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;1191
000016  4610              MOV      r0,r2                 ;1192
000018  e7f9              B        |L26.14|
;;;1194   
                          ENDP

00001a  0000              DCW      0x0000
                  |L26.28|
                          DCD      s_usValidDataBlockCount
                  |L26.32|
                          DCD      s_usLUT

                          AREA ||i.NAND_MarkBadBlock||, CODE, READONLY, ALIGN=1

                  NAND_MarkBadBlock PROC
;;;1433   */
;;;1434   static void NAND_MarkBadBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436   	uint32_t ulPageNo;
;;;1437   	uint8_t ucFlag;
;;;1438   
;;;1439   	/* 计算块的第1个页号 */
;;;1440   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
000004  01a5              LSLS     r5,r4,#6
;;;1441   
;;;1442   	/* 块内第1个page备用区的第6个字节写入非0xFF数据表示坏块 */
;;;1443   	ucFlag = NAND_BAD_BLOCK_FLAG;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1444   	if (FSMC_NAND_WriteSpare(&ucFlag, ulPageNo, BI_OFFSET, 1) == NAND_FAIL)
00000a  2301              MOVS     r3,#1
00000c  2200              MOVS     r2,#0
00000e  4629              MOV      r1,r5
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       FSMC_NAND_WriteSpare
000016  2801              CMP      r0,#1
000018  d105              BNE      |L27.38|
;;;1445   	{
;;;1446   		/* 如果第1个页标记失败，则在第2个页标记 */
;;;1447   		FSMC_NAND_WriteSpare(&ucFlag, ulPageNo + 1, BI_OFFSET, 1);
00001a  2301              MOVS     r3,#1
00001c  2200              MOVS     r2,#0
00001e  1c69              ADDS     r1,r5,#1
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       FSMC_NAND_WriteSpare
                  |L27.38|
;;;1448   	}
;;;1449   }
000026  bd38              POP      {r3-r5,pc}
;;;1450   
                          ENDP


                          AREA ||i.NAND_MarkUsedBlock||, CODE, READONLY, ALIGN=1

                  NAND_MarkUsedBlock PROC
;;;1407   */
;;;1408   static uint8_t NAND_MarkUsedBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1409   {
000002  4604              MOV      r4,r0
;;;1410   	uint32_t ulPageNo;
;;;1411   	uint8_t ucFlag;
;;;1412   
;;;1413   	/* 计算块的第1个页号 */
;;;1414   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
000004  01a5              LSLS     r5,r4,#6
;;;1415   
;;;1416   	/* 块内第1个page备用区的第6个字节写入非0xFF数据表示坏块 */
;;;1417   	ucFlag = NAND_USED_BLOCK_FLAG;
000006  20f0              MOVS     r0,#0xf0
000008  9000              STR      r0,[sp,#0]
;;;1418   	if (FSMC_NAND_WriteSpare(&ucFlag, ulPageNo, USED_OFFSET, 1) == NAND_FAIL)
00000a  2301              MOVS     r3,#1
00000c  461a              MOV      r2,r3
00000e  4629              MOV      r1,r5
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       FSMC_NAND_WriteSpare
000016  2801              CMP      r0,#1
000018  d100              BNE      |L28.28|
                  |L28.26|
;;;1419   	{
;;;1420   		/* 如果标记失败，则需要标注这个块为坏块 */
;;;1421   		return NAND_FAIL;
;;;1422   	}
;;;1423   	return NAND_OK;
;;;1424   }
00001a  bd38              POP      {r3-r5,pc}
                  |L28.28|
00001c  2000              MOVS     r0,#0                 ;1423
00001e  e7fc              B        |L28.26|
;;;1425   
                          ENDP


                          AREA ||i.NAND_Read||, CODE, READONLY, ALIGN=1

                  NAND_Read PROC
;;;892    */
;;;893    uint8_t NAND_Read(uint32_t _ulMemAddr, uint32_t *_pReadBuf, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;894    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;895    	uint16_t usPBN;			/* 物理块号 */
;;;896    	uint32_t ulPhyPageNo;	/* 物理页号 */
;;;897    	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;898    	uint32_t ulTemp;
;;;899    
;;;900    	/* 数据长度必须是4字节整数倍 */
;;;901    	if ((_usSize % 4) != 0)
00000a  17e1              ASRS     r1,r4,#31
00000c  eb047191          ADD      r1,r4,r1,LSR #30
000010  1089              ASRS     r1,r1,#2
000012  eba40181          SUB      r1,r4,r1,LSL #2
000016  b111              CBZ      r1,|L29.30|
;;;902    	{
;;;903    		return NAND_FAIL;
000018  2001              MOVS     r0,#1
                  |L29.26|
;;;904    	}
;;;905    
;;;906    	usPBN = NAND_AddrToPhyBlockNo(_ulMemAddr);	/* 查询LUT表获得物理块号 */
;;;907    	if (usPBN >= NAND_BLOCK_COUNT)
;;;908    	{
;;;909    		/* 没有格式化，usPBN = 0xFFFF */
;;;910    		return NAND_FAIL;
;;;911    	}
;;;912    
;;;913    	ulTemp = _ulMemAddr % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;914    	ulPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;915    	usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;916    
;;;917    	if (FSMC_NAND_ReadData((uint8_t *)_pReadBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;918    	{
;;;919    		return NAND_FAIL;	/* 读NAND Flash失败 */
;;;920    	}
;;;921    
;;;922    	/* 成功 */
;;;923    	return NAND_OK;
;;;924    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L29.30|
00001e  4638              MOV      r0,r7                 ;906
000020  f7fffffe          BL       NAND_AddrToPhyBlockNo
000024  4605              MOV      r5,r0                 ;906
000026  f5b56f80          CMP      r5,#0x400             ;907
00002a  db01              BLT      |L29.48|
00002c  2001              MOVS     r0,#1                 ;910
00002e  e7f4              B        |L29.26|
                  |L29.48|
000030  f3c70610          UBFX     r6,r7,#0,#17          ;913
000034  01a8              LSLS     r0,r5,#6              ;914
000036  eb0029d6          ADD      r9,r0,r6,LSR #11      ;914
00003a  f3c60a0a          UBFX     r10,r6,#0,#11         ;915
00003e  4623              MOV      r3,r4                 ;917
000040  4652              MOV      r2,r10                ;917
000042  4649              MOV      r1,r9                 ;917
000044  4640              MOV      r0,r8                 ;917
000046  f7fffffe          BL       FSMC_NAND_ReadData
00004a  2801              CMP      r0,#1                 ;917
00004c  d100              BNE      |L29.80|
00004e  e7e4              B        |L29.26|
                  |L29.80|
000050  2000              MOVS     r0,#0                 ;923
000052  e7e2              B        |L29.26|
;;;925    
                          ENDP


                          AREA ||i.NAND_ReadID||, CODE, READONLY, ALIGN=2

                  NAND_ReadID PROC
;;;254    */
;;;255    uint32_t NAND_ReadID(void)
000000  2000              MOVS     r0,#0
;;;256    {
;;;257    	uint32_t data = 0;
;;;258    
;;;259    	/* 发送命令 Command to the command area */
;;;260    	NAND_CMD_AREA = 0x90;
000002  2190              MOVS     r1,#0x90
000004  4a0c              LDR      r2,|L30.56|
000006  7011              STRB     r1,[r2,#0]
;;;261    	NAND_ADDR_AREA = 0x00;
000008  2100              MOVS     r1,#0
00000a  4a0c              LDR      r2,|L30.60|
00000c  7011              STRB     r1,[r2,#0]
;;;262    
;;;263    	/* 顺序读取NAND Flash的ID */
;;;264    	data = *(__IO uint32_t *)(Bank_NAND_ADDR | DATA_AREA);
00000e  f04f41e0          MOV      r1,#0x70000000
000012  6808              LDR      r0,[r1,#0]
;;;265    	data =  ((data << 24) & 0xFF000000) |
000014  f04f417f          MOV      r1,#0xff000000
000018  ea016100          AND      r1,r1,r0,LSL #24
00001c  f44f027f          MOV      r2,#0xff0000
000020  ea022200          AND      r2,r2,r0,LSL #8
000024  4311              ORRS     r1,r1,r2
000026  f44f427f          MOV      r2,#0xff00
00002a  ea022210          AND      r2,r2,r0,LSR #8
00002e  4311              ORRS     r1,r1,r2
000030  ea416010          ORR      r0,r1,r0,LSR #24
;;;266    			((data << 8 ) & 0x00FF0000) |
;;;267    			((data >> 8 ) & 0x0000FF00) |
;;;268    			((data >> 24) & 0x000000FF) ;
;;;269    	return data;
;;;270    }
000034  4770              BX       lr
;;;271    
                          ENDP

000036  0000              DCW      0x0000
                  |L30.56|
                          DCD      0x70010000
                  |L30.60|
                          DCD      0x70020000

                          AREA ||i.NAND_ReadMultiSectors||, CODE, READONLY, ALIGN=1

                  NAND_ReadMultiSectors PROC
;;;1038   */
;;;1039   uint8_t NAND_ReadMultiSectors(uint8_t *_pBuf, uint32_t _SectorNo, uint16_t _SectorSize, uint32_t _SectorCount)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1040   {
000004  4681              MOV      r9,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  469a              MOV      r10,r3
;;;1041   	uint32_t i;
;;;1042   	uint32_t usLBN;			/* 逻辑块号 */
;;;1043   	uint32_t usPBN;			/* 物理块号 */
;;;1044   	uint32_t uiPhyPageNo;	/* 物理页号 */
;;;1045   	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;1046   	uint32_t ulTemp;
;;;1047   
;;;1048   	/*
;;;1049   		HY27UF081G2A = 128M Flash.  有 1024个BLOCK, 每个BLOCK包含64个PAGE， 每个PAGE包含2048+64字节，
;;;1050   		擦除最小单位是BLOCK， 编程最小单位是字节。
;;;1051   
;;;1052   		每个PAGE在逻辑上可以分为4个512字节扇区。
;;;1053   	*/
;;;1054   
;;;1055   	for (i = 0; i < _SectorCount; i++)
00000c  2500              MOVS     r5,#0
00000e  e031              B        |L31.116|
                  |L31.16|
;;;1056   	{
;;;1057   		/* 根据逻辑扇区号和扇区大小计算逻辑块号 */
;;;1058   		//usLBN = (_SectorNo * _SectorSize) / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1059   		/* (_SectorNo * _SectorSize) 乘积可能大于32位，因此换下面这种写法 */
;;;1060   		usLBN = (_SectorNo + i) / (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize));
000010  f44f6000          MOV      r0,#0x800
000014  fb90f0f4          SDIV     r0,r0,r4
000018  0180              LSLS     r0,r0,#6
00001a  1979              ADDS     r1,r7,r5
00001c  fbb1fbf0          UDIV     r11,r1,r0
;;;1061   		usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
000020  4658              MOV      r0,r11
000022  f7fffffe          BL       NAND_LBNtoPBN
000026  4606              MOV      r6,r0
;;;1062   		if (usPBN >= NAND_BLOCK_COUNT)
000028  f5b66f80          CMP      r6,#0x400
00002c  d303              BCC      |L31.54|
;;;1063   		{
;;;1064   			/* 没有格式化，usPBN = 0xFFFF */
;;;1065   			return NAND_FAIL;
00002e  2001              MOVS     r0,#1
                  |L31.48|
;;;1066   		}
;;;1067   
;;;1068   		ulTemp = ((uint64_t)(_SectorNo + i) * _SectorSize) % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1069   		uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;1070   		usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;1071   
;;;1072   		if (FSMC_NAND_ReadData((uint8_t *)&_pBuf[i * _SectorSize], uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_FAIL)
;;;1073   		{
;;;1074   			return NAND_FAIL;	/* 读NAND Flash失败 */
;;;1075   		}
;;;1076   	}
;;;1077   
;;;1078   	/* 成功 */
;;;1079   	return NAND_OK;
;;;1080   }
000030  b004              ADD      sp,sp,#0x10
000032  e8bd9ff0          POP      {r4-r12,pc}
                  |L31.54|
000036  1978              ADDS     r0,r7,r5              ;1068
000038  fba01004          UMULL    r1,r0,r0,r4           ;1068
00003c  f44f3200          MOV      r2,#0x20000           ;1068
000040  2300              MOVS     r3,#0                 ;1068
000042  e9cd1000          STRD     r1,r0,[sp,#0]         ;1068
000046  4608              MOV      r0,r1                 ;1068
000048  9901              LDR      r1,[sp,#4]            ;1068
00004a  f7fffffe          BL       __aeabi_uldivmod
00004e  4690              MOV      r8,r2                 ;1068
000050  01b0              LSLS     r0,r6,#6              ;1069
000052  eb0020d8          ADD      r0,r0,r8,LSR #11      ;1069
000056  9003              STR      r0,[sp,#0xc]          ;1069
000058  f3c8000a          UBFX     r0,r8,#0,#11          ;1070
00005c  9002              STR      r0,[sp,#8]            ;1070
00005e  fb059004          MLA      r0,r5,r4,r9           ;1072
000062  4623              MOV      r3,r4                 ;1072
000064  e9dd2102          LDRD     r2,r1,[sp,#8]         ;1072
000068  f7fffffe          BL       FSMC_NAND_ReadData
00006c  2801              CMP      r0,#1                 ;1072
00006e  d100              BNE      |L31.114|
000070  e7de              B        |L31.48|
                  |L31.114|
000072  1c6d              ADDS     r5,r5,#1              ;1055
                  |L31.116|
000074  4555              CMP      r5,r10                ;1055
000076  d3cb              BCC      |L31.16|
000078  2000              MOVS     r0,#0                 ;1079
00007a  e7d9              B        |L31.48|
;;;1081   
                          ENDP


                          AREA ||i.NAND_ScanBlock||, CODE, READONLY, ALIGN=2

                  NAND_ScanBlock PROC
;;;1315   */
;;;1316   uint8_t NAND_ScanBlock(uint32_t _ulBlockNo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1317   {
000004  4605              MOV      r5,r0
;;;1318   	uint32_t i, k;
;;;1319   	uint32_t ulPageNo;
;;;1320   
;;;1321   	#if 1
;;;1322   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1323   	if (NAND_IsBadBlock(_ulBlockNo))
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       NAND_IsBadBlock
00000c  b110              CBZ      r0,|L32.20|
;;;1324   	{
;;;1325   		return NAND_FAIL;
00000e  2001              MOVS     r0,#1
                  |L32.16|
;;;1326   	}
;;;1327   	#endif
;;;1328   
;;;1329   	/* 下面的代码将通过反复擦除、编程的方式来测试NAND Flash每个块的可靠性 */
;;;1330   	memset(s_ucTempBuf, 0x00, NAND_PAGE_TOTAL_SIZE);
;;;1331   	for (i = 0; i < BAD_BALOK_TEST_CYCLE; i++)
;;;1332   	{
;;;1333   		/* 第1步：擦除这个块 */
;;;1334   		if (FSMC_NAND_EraseBlock(_ulBlockNo) != NAND_READY)
;;;1335   		{
;;;1336   			return NAND_FAIL;
;;;1337   		}
;;;1338   
;;;1339   		/* 第2步：读出块内每个page的数据，并判断是否全0xFF */
;;;1340   		ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
;;;1341   		for (k = 0; k < NAND_BLOCK_SIZE; k++)
;;;1342   		{
;;;1343   			/* 读出整页数据 */
;;;1344   			FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
;;;1345   
;;;1346   			/* 判断存储单元是不是全0xFF */
;;;1347   			if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0xFF) != NAND_OK)
;;;1348   			{
;;;1349   				return NAND_FAIL;
;;;1350   			}
;;;1351   
;;;1352   			ulPageNo++;		/* 继续写下一个页 */
;;;1353   		}
;;;1354   
;;;1355   		/* 第2步：写全0，并读回判断是否全0 */
;;;1356   		ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
;;;1357   		for (k = 0; k < NAND_BLOCK_SIZE; k++)
;;;1358   		{
;;;1359   			/* 填充buf[]缓冲区为全0,并写入NAND Flash */
;;;1360   			memset(s_ucTempBuf, 0x00, NAND_PAGE_TOTAL_SIZE);
;;;1361   			if (FSMC_NAND_WritePage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE) != NAND_OK)
;;;1362   			{
;;;1363   				return NAND_FAIL;
;;;1364   			}
;;;1365   
;;;1366   			/* 读出整页数据, 判断存储单元是不是全0x00 */
;;;1367   			FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
;;;1368   			if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0x00) != NAND_OK)
;;;1369   			{
;;;1370   				return NAND_FAIL;
;;;1371   			}
;;;1372   
;;;1373   			ulPageNo++;		/* 继续一个页 */
;;;1374   		}
;;;1375   	}
;;;1376   
;;;1377   	/* 最后一步：擦除整个块 */
;;;1378   	if (FSMC_NAND_EraseBlock(_ulBlockNo) != NAND_READY)
;;;1379   	{
;;;1380   		return NAND_FAIL;
;;;1381   	}
;;;1382   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
;;;1383   	for (k = 0; k < NAND_BLOCK_SIZE; k++)
;;;1384   	{
;;;1385   		/* 读出整页数据 */
;;;1386   		FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
;;;1387   
;;;1388   		/* 判断存储单元是不是全0xFF */
;;;1389   		if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0xFF) != NAND_OK)
;;;1390   		{
;;;1391   			return NAND_FAIL;
;;;1392   		}
;;;1393   
;;;1394   		ulPageNo++;		/* 继续写下一个页 */
;;;1395   	}
;;;1396   
;;;1397   	return NAND_OK;
;;;1398   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L32.20|
000014  f44f6104          MOV      r1,#0x840             ;1330
000018  4835              LDR      r0,|L32.240|
00001a  f7fffffe          BL       __aeabi_memclr
00001e  2700              MOVS     r7,#0                 ;1331
000020  e044              B        |L32.172|
                  |L32.34|
000022  4628              MOV      r0,r5                 ;1334
000024  f7fffffe          BL       FSMC_NAND_EraseBlock
000028  2840              CMP      r0,#0x40              ;1334
00002a  d001              BEQ      |L32.48|
00002c  2001              MOVS     r0,#1                 ;1336
00002e  e7ef              B        |L32.16|
                  |L32.48|
000030  01ae              LSLS     r6,r5,#6              ;1340
000032  2400              MOVS     r4,#0                 ;1341
000034  e011              B        |L32.90|
                  |L32.54|
000036  f44f6304          MOV      r3,#0x840             ;1344
00003a  2200              MOVS     r2,#0                 ;1344
00003c  4631              MOV      r1,r6                 ;1344
00003e  482c              LDR      r0,|L32.240|
000040  f7fffffe          BL       FSMC_NAND_ReadPage
000044  22ff              MOVS     r2,#0xff              ;1347
000046  f44f6104          MOV      r1,#0x840             ;1347
00004a  4829              LDR      r0,|L32.240|
00004c  f7fffffe          BL       NAND_IsBufOk
000050  b108              CBZ      r0,|L32.86|
000052  2001              MOVS     r0,#1                 ;1349
000054  e7dc              B        |L32.16|
                  |L32.86|
000056  1c76              ADDS     r6,r6,#1              ;1352
000058  1c64              ADDS     r4,r4,#1              ;1341
                  |L32.90|
00005a  2c40              CMP      r4,#0x40              ;1341
00005c  d3eb              BCC      |L32.54|
00005e  01ae              LSLS     r6,r5,#6              ;1356
000060  2400              MOVS     r4,#0                 ;1357
000062  e020              B        |L32.166|
                  |L32.100|
000064  f44f6104          MOV      r1,#0x840             ;1360
000068  4821              LDR      r0,|L32.240|
00006a  f7fffffe          BL       __aeabi_memclr
00006e  f44f6304          MOV      r3,#0x840             ;1361
000072  2200              MOVS     r2,#0                 ;1361
000074  4631              MOV      r1,r6                 ;1361
000076  481e              LDR      r0,|L32.240|
000078  f7fffffe          BL       FSMC_NAND_WritePage
00007c  b108              CBZ      r0,|L32.130|
00007e  2001              MOVS     r0,#1                 ;1363
000080  e7c6              B        |L32.16|
                  |L32.130|
000082  f44f6304          MOV      r3,#0x840             ;1367
000086  2200              MOVS     r2,#0                 ;1367
000088  4631              MOV      r1,r6                 ;1367
00008a  4819              LDR      r0,|L32.240|
00008c  f7fffffe          BL       FSMC_NAND_ReadPage
000090  2200              MOVS     r2,#0                 ;1368
000092  f44f6104          MOV      r1,#0x840             ;1368
000096  4816              LDR      r0,|L32.240|
000098  f7fffffe          BL       NAND_IsBufOk
00009c  b108              CBZ      r0,|L32.162|
00009e  2001              MOVS     r0,#1                 ;1370
0000a0  e7b6              B        |L32.16|
                  |L32.162|
0000a2  1c76              ADDS     r6,r6,#1              ;1373
0000a4  1c64              ADDS     r4,r4,#1              ;1357
                  |L32.166|
0000a6  2c40              CMP      r4,#0x40              ;1357
0000a8  d3dc              BCC      |L32.100|
0000aa  1c7f              ADDS     r7,r7,#1              ;1331
                  |L32.172|
0000ac  2f05              CMP      r7,#5                 ;1331
0000ae  d3b8              BCC      |L32.34|
0000b0  4628              MOV      r0,r5                 ;1378
0000b2  f7fffffe          BL       FSMC_NAND_EraseBlock
0000b6  2840              CMP      r0,#0x40              ;1378
0000b8  d001              BEQ      |L32.190|
0000ba  2001              MOVS     r0,#1                 ;1380
0000bc  e7a8              B        |L32.16|
                  |L32.190|
0000be  01ae              LSLS     r6,r5,#6              ;1382
0000c0  2400              MOVS     r4,#0                 ;1383
0000c2  e011              B        |L32.232|
                  |L32.196|
0000c4  f44f6304          MOV      r3,#0x840             ;1386
0000c8  2200              MOVS     r2,#0                 ;1386
0000ca  4631              MOV      r1,r6                 ;1386
0000cc  4808              LDR      r0,|L32.240|
0000ce  f7fffffe          BL       FSMC_NAND_ReadPage
0000d2  22ff              MOVS     r2,#0xff              ;1389
0000d4  f44f6104          MOV      r1,#0x840             ;1389
0000d8  4805              LDR      r0,|L32.240|
0000da  f7fffffe          BL       NAND_IsBufOk
0000de  b108              CBZ      r0,|L32.228|
0000e0  2001              MOVS     r0,#1                 ;1391
0000e2  e795              B        |L32.16|
                  |L32.228|
0000e4  1c76              ADDS     r6,r6,#1              ;1394
0000e6  1c64              ADDS     r4,r4,#1              ;1383
                  |L32.232|
0000e8  2c40              CMP      r4,#0x40              ;1383
0000ea  d3eb              BCC      |L32.196|
0000ec  2000              MOVS     r0,#0                 ;1397
0000ee  e78f              B        |L32.16|
;;;1399   
                          ENDP

                  |L32.240|
                          DCD      s_ucTempBuf

                          AREA ||i.NAND_Write||, CODE, READONLY, ALIGN=2

                  NAND_Write PROC
;;;829    */
;;;830    uint8_t NAND_Write(uint32_t _ulMemAddr, uint32_t *_pWriteBuf, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;831    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;832    	uint16_t usPBN;			/* 物理块号 */
;;;833    	uint32_t ulPhyPageNo;	/* 物理页号 */
;;;834    	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;835    	uint32_t ulTemp;
;;;836    
;;;837    	/* 数据长度必须是4字节整数倍 */
;;;838    	if ((_usSize % 4) != 0)
00000a  17e1              ASRS     r1,r4,#31
00000c  eb047191          ADD      r1,r4,r1,LSR #30
000010  1089              ASRS     r1,r1,#2
000012  eba40181          SUB      r1,r4,r1,LSL #2
000016  b111              CBZ      r1,|L33.30|
;;;839    	{
;;;840    		return NAND_FAIL;
000018  2001              MOVS     r0,#1
                  |L33.26|
;;;841    	}
;;;842    	/* 数据长度不能超过512字节(遵循 Fat格式) */
;;;843    	if (_usSize > 512)
;;;844    	{
;;;845    		//return NAND_FAIL;
;;;846    	}
;;;847    
;;;848    	usPBN = NAND_AddrToPhyBlockNo(_ulMemAddr);	/* 查询LUT表获得物理块号 */
;;;849    
;;;850    	ulTemp = _ulMemAddr % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;851    	ulPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;852    	usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;853    
;;;854    	/* 读出扇区的内容，判断是否全FF */
;;;855    	if (FSMC_NAND_ReadData(s_ucTempBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;856    	{
;;;857    		return NAND_FAIL;	/* 读NAND Flash失败 */
;;;858    	}
;;;859    	/*　如果是全0xFF, 则可以直接写入，无需擦除 */
;;;860    	if (NAND_IsBufOk(s_ucTempBuf, _usSize, 0xFF))
;;;861    	{
;;;862    		if (FSMC_NAND_WriteData((uint8_t *)_pWriteBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;863    		{
;;;864    			/* 将数据写入到另外一个块（空闲块） */
;;;865    			return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;866    		}
;;;867    
;;;868    		/* 标记该块已用 */
;;;869    		if (NAND_MarkUsedBlock(ulPhyPageNo) == NAND_FAIL)
;;;870    		{
;;;871    			/* 标记失败，将数据写入到另外一个块（空闲块） */
;;;872    			return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;873    		}
;;;874    		return NAND_OK;	/* 写入成功 */
;;;875    	}
;;;876    
;;;877    	/* 将数据写入到另外一个块（空闲块） */
;;;878    	return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;879    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L33.30|
00001e  4638              MOV      r0,r7                 ;848
000020  f7fffffe          BL       NAND_AddrToPhyBlockNo
000024  4681              MOV      r9,r0                 ;848
000026  f3c70610          UBFX     r6,r7,#0,#17          ;850
00002a  ea4f1089          LSL      r0,r9,#6              ;851
00002e  eb0025d6          ADD      r5,r0,r6,LSR #11      ;851
000032  f3c60a0a          UBFX     r10,r6,#0,#11         ;852
000036  4623              MOV      r3,r4                 ;855
000038  4652              MOV      r2,r10                ;855
00003a  4629              MOV      r1,r5                 ;855
00003c  4817              LDR      r0,|L33.156|
00003e  f7fffffe          BL       FSMC_NAND_ReadData
000042  2801              CMP      r0,#1                 ;855
000044  d100              BNE      |L33.72|
000046  e7e8              B        |L33.26|
                  |L33.72|
000048  22ff              MOVS     r2,#0xff              ;860
00004a  4621              MOV      r1,r4                 ;860
00004c  4813              LDR      r0,|L33.156|
00004e  f7fffffe          BL       NAND_IsBufOk
000052  b1e0              CBZ      r0,|L33.142|
000054  4623              MOV      r3,r4                 ;862
000056  4652              MOV      r2,r10                ;862
000058  4629              MOV      r1,r5                 ;862
00005a  4640              MOV      r0,r8                 ;862
00005c  f7fffffe          BL       FSMC_NAND_WriteData
000060  2801              CMP      r0,#1                 ;862
000062  d106              BNE      |L33.114|
000064  4623              MOV      r3,r4                 ;865
000066  4652              MOV      r2,r10                ;865
000068  4641              MOV      r1,r8                 ;865
00006a  4628              MOV      r0,r5                 ;865
00006c  f7fffffe          BL       NAND_WriteToNewBlock
000070  e7d3              B        |L33.26|
                  |L33.114|
000072  4628              MOV      r0,r5                 ;869
000074  f7fffffe          BL       NAND_MarkUsedBlock
000078  2801              CMP      r0,#1                 ;869
00007a  d106              BNE      |L33.138|
00007c  4623              MOV      r3,r4                 ;872
00007e  4652              MOV      r2,r10                ;872
000080  4641              MOV      r1,r8                 ;872
000082  4628              MOV      r0,r5                 ;872
000084  f7fffffe          BL       NAND_WriteToNewBlock
000088  e7c7              B        |L33.26|
                  |L33.138|
00008a  2000              MOVS     r0,#0                 ;874
00008c  e7c5              B        |L33.26|
                  |L33.142|
00008e  4623              MOV      r3,r4                 ;878
000090  4652              MOV      r2,r10                ;878
000092  4641              MOV      r1,r8                 ;878
000094  4628              MOV      r0,r5                 ;878
000096  f7fffffe          BL       NAND_WriteToNewBlock
00009a  e7be              B        |L33.26|
;;;880    
                          ENDP

                  |L33.156|
                          DCD      s_ucTempBuf

                          AREA ||i.NAND_WriteMultiSectors||, CODE, READONLY, ALIGN=2

                  NAND_WriteMultiSectors PROC
;;;938    */
;;;939    uint8_t NAND_WriteMultiSectors(uint8_t *_pBuf, uint32_t _SectorNo, uint16_t _SectorSize, uint32_t _SectorCount)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;940    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  4614              MOV      r4,r2
;;;941    	uint32_t i;
;;;942    	uint32_t usLBN;			/* 逻辑块号 */
;;;943    	uint32_t usPBN;			/* 物理块号 */
;;;944    	uint32_t uiPhyPageNo;	/* 物理页号 */
;;;945    	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;946    	uint32_t ulTemp;
;;;947    	uint8_t ucReturn;
;;;948    
;;;949    	/*
;;;950    		HY27UF081G2A = 128M Flash.  有 1024个BLOCK, 每个BLOCK包含64个PAGE， 每个PAGE包含2048+64字节，
;;;951    		擦除最小单位是BLOCK， 编程最小单位是字节。
;;;952    
;;;953    		每个PAGE在逻辑上可以分为4个512字节扇区。
;;;954    	*/
;;;955    
;;;956    	for (i = 0; i < _SectorCount; i++)
00000c  2500              MOVS     r5,#0
00000e  e070              B        |L34.242|
                  |L34.16|
;;;957    	{
;;;958    		/* 根据逻辑扇区号和扇区大小计算逻辑块号 */
;;;959    		//usLBN = (_SectorNo * _SectorSize) / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;960    		/* (_SectorNo * _SectorSize) 乘积可能大于32位，因此换下面这种写法 */
;;;961    		usLBN = (_SectorNo + i) / (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize));
000010  f44f6000          MOV      r0,#0x800
000014  fb90f0f4          SDIV     r0,r0,r4
000018  0180              LSLS     r0,r0,#6
00001a  eb080105          ADD      r1,r8,r5
00001e  fbb1f0f0          UDIV     r0,r1,r0
000022  9002              STR      r0,[sp,#8]
;;;962    		usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
000024  9802              LDR      r0,[sp,#8]
000026  f7fffffe          BL       NAND_LBNtoPBN
00002a  4607              MOV      r7,r0
;;;963    		if (usPBN >= NAND_BLOCK_COUNT)
00002c  f5b76f80          CMP      r7,#0x400
000030  d303              BCC      |L34.58|
;;;964    		{
;;;965    			/* 没有格式化，usPBN = 0xFFFF */
;;;966    			return NAND_FAIL;
000032  2001              MOVS     r0,#1
                  |L34.52|
;;;967    		}
;;;968    
;;;969    		//ulTemp = ((uint64_t)(_SectorNo + i) * _SectorSize) % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;970    		ulTemp = ((_SectorNo + i) % (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize))) *  _SectorSize;
;;;971    		uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;972    		usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;973    
;;;974    		/* 如果 _SectorCount > 0, 并且是页面首地址，则可以进行优化 */
;;;975    		if (usAddrInPage == 0)
;;;976    		{
;;;977    			/* 暂未处理 */
;;;978    		}
;;;979    
;;;980    		/* 读出扇区的内容，判断是否全FF */
;;;981    		if (FSMC_NAND_ReadData(s_ucTempBuf, uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_FAIL)
;;;982    		{
;;;983    			return NAND_FAIL;	/* 失败 */
;;;984    		}
;;;985    
;;;986    		/*　如果是全0xFF, 则可以直接写入，无需擦除 */
;;;987    		if (NAND_IsBufOk(s_ucTempBuf, _SectorSize, 0xFF))
;;;988    		{
;;;989    			if (FSMC_NAND_WriteData(&_pBuf[i * _SectorSize], uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_FAIL)
;;;990    			{
;;;991    				/* 将数据写入到另外一个块（空闲块） */
;;;992    				ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
;;;993    				if (ucReturn != NAND_OK)
;;;994    				{
;;;995    					return NAND_FAIL;	/* 失败 */
;;;996    				}
;;;997    				continue;
;;;998    			}
;;;999    
;;;1000   			/* 标记该块已用 */
;;;1001   			if (NAND_MarkUsedBlock(uiPhyPageNo) == NAND_FAIL)
;;;1002   			{
;;;1003   				/* 标记失败，将数据写入到另外一个块（空闲块） */
;;;1004   				ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
;;;1005   				if (ucReturn != NAND_OK)
;;;1006   				{
;;;1007   					return NAND_FAIL;	/* 失败 */
;;;1008   				}
;;;1009   				continue;
;;;1010   			}
;;;1011   		}
;;;1012   		else	/* 目标区域已经有数据，不是全FF, 则直接将数据写入另外一个空闲块 */
;;;1013   		{
;;;1014   			/* 将数据写入到另外一个块（空闲块） */
;;;1015   			ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
;;;1016   			if (ucReturn != NAND_OK)
;;;1017   			{
;;;1018   				return NAND_FAIL;	/* 失败 */
;;;1019   			}
;;;1020   			continue;
;;;1021   		}
;;;1022   	}
;;;1023   	return NAND_OK;		/* 成功 */
;;;1024   }
000034  b007              ADD      sp,sp,#0x1c
000036  e8bd8ff0          POP      {r4-r11,pc}
                  |L34.58|
00003a  f44f6000          MOV      r0,#0x800             ;970
00003e  fb90f0f4          SDIV     r0,r0,r4              ;970
000042  0180              LSLS     r0,r0,#6              ;970
000044  eb080105          ADD      r1,r8,r5              ;970
000048  fbb1f2f0          UDIV     r2,r1,r0              ;970
00004c  fb001012          MLS      r0,r0,r2,r1           ;970
000050  fb00fa04          MUL      r10,r0,r4             ;970
000054  01b8              LSLS     r0,r7,#6              ;971
000056  eb0029da          ADD      r9,r0,r10,LSR #11     ;971
00005a  f3ca000a          UBFX     r0,r10,#0,#11         ;972
00005e  9001              STR      r0,[sp,#4]            ;972
000060  4623              MOV      r3,r4                 ;981
000062  4649              MOV      r1,r9                 ;981
000064  4825              LDR      r0,|L34.252|
000066  9a01              LDR      r2,[sp,#4]            ;981
000068  f7fffffe          BL       FSMC_NAND_ReadData
00006c  2801              CMP      r0,#1                 ;981
00006e  d100              BNE      |L34.114|
000070  e7e0              B        |L34.52|
                  |L34.114|
000072  22ff              MOVS     r2,#0xff              ;987
000074  4621              MOV      r1,r4                 ;987
000076  4821              LDR      r0,|L34.252|
000078  f7fffffe          BL       NAND_IsBufOk
00007c  b348              CBZ      r0,|L34.210|
00007e  fb056004          MLA      r0,r5,r4,r6           ;989
000082  4623              MOV      r3,r4                 ;989
000084  4649              MOV      r1,r9                 ;989
000086  9a01              LDR      r2,[sp,#4]            ;989
000088  f7fffffe          BL       FSMC_NAND_WriteData
00008c  2801              CMP      r0,#1                 ;989
00008e  d10d              BNE      |L34.172|
000090  fb056104          MLA      r1,r5,r4,r6           ;992
000094  4623              MOV      r3,r4                 ;992
000096  4648              MOV      r0,r9                 ;992
000098  9a01              LDR      r2,[sp,#4]            ;992
00009a  f7fffffe          BL       NAND_WriteToNewBlock
00009e  4683              MOV      r11,r0                ;992
0000a0  f1bb0f00          CMP      r11,#0                ;993
0000a4  d001              BEQ      |L34.170|
0000a6  2001              MOVS     r0,#1                 ;995
0000a8  e7c4              B        |L34.52|
                  |L34.170|
0000aa  e021              B        |L34.240|
                  |L34.172|
0000ac  4648              MOV      r0,r9                 ;1001
0000ae  f7fffffe          BL       NAND_MarkUsedBlock
0000b2  2801              CMP      r0,#1                 ;1001
0000b4  d11b              BNE      |L34.238|
0000b6  fb056104          MLA      r1,r5,r4,r6           ;1004
0000ba  4623              MOV      r3,r4                 ;1004
0000bc  4648              MOV      r0,r9                 ;1004
0000be  9a01              LDR      r2,[sp,#4]            ;1004
0000c0  f7fffffe          BL       NAND_WriteToNewBlock
0000c4  4683              MOV      r11,r0                ;1004
0000c6  f1bb0f00          CMP      r11,#0                ;1005
0000ca  d001              BEQ      |L34.208|
0000cc  2001              MOVS     r0,#1                 ;1007
0000ce  e7b1              B        |L34.52|
                  |L34.208|
0000d0  e00e              B        |L34.240|
                  |L34.210|
0000d2  fb056104          MLA      r1,r5,r4,r6           ;1015
0000d6  4623              MOV      r3,r4                 ;1015
0000d8  4648              MOV      r0,r9                 ;1015
0000da  9a01              LDR      r2,[sp,#4]            ;1015
0000dc  f7fffffe          BL       NAND_WriteToNewBlock
0000e0  4683              MOV      r11,r0                ;1015
0000e2  f1bb0f00          CMP      r11,#0                ;1016
0000e6  d001              BEQ      |L34.236|
0000e8  2001              MOVS     r0,#1                 ;1018
0000ea  e7a3              B        |L34.52|
                  |L34.236|
0000ec  e000              B        |L34.240|
                  |L34.238|
0000ee  bf00              NOP                            ;997
                  |L34.240|
0000f0  1c6d              ADDS     r5,r5,#1              ;956
                  |L34.242|
0000f2  9806              LDR      r0,[sp,#0x18]         ;956
0000f4  4285              CMP      r5,r0                 ;956
0000f6  d38b              BCC      |L34.16|
0000f8  2000              MOVS     r0,#0                 ;1023
0000fa  e79b              B        |L34.52|
;;;1025   
                          ENDP

                  |L34.252|
                          DCD      s_ucTempBuf

                          AREA ||i.NAND_WriteToNewBlock||, CODE, READONLY, ALIGN=1

                  NAND_WriteToNewBlock PROC
;;;746    */
;;;747    uint8_t NAND_WriteToNewBlock(uint32_t _ulPhyPageNo, uint8_t *_pWriteBuf, uint16_t _usOffset, uint16_t _usSize)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;748    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  469a              MOV      r10,r3
;;;749    	uint16_t n, i;
;;;750    	uint16_t usNewBlock;
;;;751    	uint16_t ulSrcBlock;
;;;752    	uint16_t usOffsetPageNo;
;;;753    
;;;754    	ulSrcBlock = _ulPhyPageNo / NAND_BLOCK_SIZE;		/* 根据物理页号反推块号 */
00000c  f3c7168f          UBFX     r6,r7,#6,#16
;;;755    	usOffsetPageNo = _ulPhyPageNo % NAND_BLOCK_SIZE;	/* 根据物理页号计算物理页号在块内偏移页号 */
000010  f007003f          AND      r0,r7,#0x3f
000014  9001              STR      r0,[sp,#4]
;;;756    	/* 增加循环的目的是处理目标块为坏块的情况 */
;;;757    	for (n = 0; n < 10; n++)
000016  f04f0b00          MOV      r11,#0
00001a  e052              B        |L35.194|
                  |L35.28|
;;;758    	{
;;;759    		/* 如果不是全0xFF， 则需要寻找一个空闲可用块，并将页内的数据全部移到新块中，然后擦除这个块 */
;;;760    		usNewBlock = NAND_FindFreeBlock();	/* 从最后一个Block开始，搜寻一个可用块 */
00001c  f7fffffe          BL       NAND_FindFreeBlock
000020  4605              MOV      r5,r0
;;;761    		if (usNewBlock >= NAND_BLOCK_COUNT)
000022  f5b56f80          CMP      r5,#0x400
000026  db02              BLT      |L35.46|
;;;762    		{
;;;763    			return NAND_FAIL;	/* 查找空闲块失败 */
000028  2001              MOVS     r0,#1
                  |L35.42|
;;;764    		}
;;;765    
;;;766    		/* 使用page-copy功能，将当前块（usPBN）的数据全部搬移到新块（usNewBlock） */
;;;767    		for (i = 0; i < NAND_BLOCK_SIZE; i++)
;;;768    		{
;;;769    			if (i == usOffsetPageNo)
;;;770    			{
;;;771    				/* 如果写入的数据在当前页，则需要使用带随机数据的Copy-Back命令 */
;;;772    				if (FSMC_NAND_PageCopyBackEx(ulSrcBlock * NAND_BLOCK_SIZE + i, usNewBlock * NAND_BLOCK_SIZE + i,
;;;773    					_pWriteBuf, _usOffset, _usSize) == NAND_FAIL)
;;;774    				{
;;;775    					NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;776    					NAND_BuildLUT();				/* 重建LUT表 */
;;;777    					break;
;;;778    				}
;;;779    			}
;;;780    			else
;;;781    			{
;;;782    				/* 使用NAND Flash 提供的整页Copy-Back功能，可以显著提高操作效率 */
;;;783    				if (FSMC_NAND_PageCopyBack(ulSrcBlock * NAND_BLOCK_SIZE + i,
;;;784    					usNewBlock * NAND_BLOCK_SIZE + i) == NAND_FAIL)
;;;785    				{
;;;786    					NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;787    					NAND_BuildLUT();				/* 重建LUT表 */
;;;788    					break;
;;;789    				}
;;;790    			}
;;;791    		}
;;;792    		/* 目标块更新成功 */
;;;793    		if (i == NAND_BLOCK_SIZE)
;;;794    		{
;;;795    			/* 标记新块为已用块 */
;;;796    			if (NAND_MarkUsedBlock(usNewBlock) == NAND_FAIL)
;;;797    			{
;;;798    				NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;799    				NAND_BuildLUT();				/* 重建LUT表 */
;;;800    				continue;
;;;801    			}
;;;802    
;;;803    			/* 擦除源BLOCK */
;;;804    			if (FSMC_NAND_EraseBlock(ulSrcBlock) != NAND_READY)
;;;805    			{
;;;806    				NAND_MarkBadBlock(ulSrcBlock);	/* 将源块标记为坏块 */
;;;807    				NAND_BuildLUT();				/* 重建LUT表 */
;;;808    				continue;
;;;809    			}
;;;810    			NAND_BuildLUT();				/* 重建LUT表 */
;;;811    			break;
;;;812    		}
;;;813    	}
;;;814    
;;;815    	return NAND_OK;	/* 写入成功 */
;;;816    }
00002a  e8bd9ffc          POP      {r2-r12,pc}
                  |L35.46|
00002e  2400              MOVS     r4,#0                 ;767
000030  e024              B        |L35.124|
                  |L35.50|
000032  9801              LDR      r0,[sp,#4]            ;769
000034  4284              CMP      r4,r0                 ;769
000036  d111              BNE      |L35.92|
000038  eb041185          ADD      r1,r4,r5,LSL #6       ;772
00003c  eb041086          ADD      r0,r4,r6,LSL #6       ;772
000040  464b              MOV      r3,r9                 ;772
000042  4642              MOV      r2,r8                 ;772
000044  f8cda000          STR      r10,[sp,#0]           ;772
000048  f7fffffe          BL       FSMC_NAND_PageCopyBackEx
00004c  2801              CMP      r0,#1                 ;772
00004e  d113              BNE      |L35.120|
000050  4628              MOV      r0,r5                 ;775
000052  f7fffffe          BL       NAND_MarkBadBlock
000056  f7fffffe          BL       NAND_BuildLUT
00005a  e011              B        |L35.128|
                  |L35.92|
00005c  eb041185          ADD      r1,r4,r5,LSL #6       ;783
000060  eb041086          ADD      r0,r4,r6,LSL #6       ;783
000064  f7fffffe          BL       FSMC_NAND_PageCopyBack
000068  2801              CMP      r0,#1                 ;783
00006a  d105              BNE      |L35.120|
00006c  4628              MOV      r0,r5                 ;786
00006e  f7fffffe          BL       NAND_MarkBadBlock
000072  f7fffffe          BL       NAND_BuildLUT
000076  e003              B        |L35.128|
                  |L35.120|
000078  1c60              ADDS     r0,r4,#1              ;767
00007a  b284              UXTH     r4,r0                 ;767
                  |L35.124|
00007c  2c40              CMP      r4,#0x40              ;767
00007e  dbd8              BLT      |L35.50|
                  |L35.128|
000080  bf00              NOP                            ;777
000082  2c40              CMP      r4,#0x40              ;793
000084  d118              BNE      |L35.184|
000086  4628              MOV      r0,r5                 ;796
000088  f7fffffe          BL       NAND_MarkUsedBlock
00008c  2801              CMP      r0,#1                 ;796
00008e  d105              BNE      |L35.156|
000090  4628              MOV      r0,r5                 ;798
000092  f7fffffe          BL       NAND_MarkBadBlock
000096  f7fffffe          BL       NAND_BuildLUT
00009a  e00e              B        |L35.186|
                  |L35.156|
00009c  4630              MOV      r0,r6                 ;804
00009e  f7fffffe          BL       FSMC_NAND_EraseBlock
0000a2  2840              CMP      r0,#0x40              ;804
0000a4  d005              BEQ      |L35.178|
0000a6  4630              MOV      r0,r6                 ;806
0000a8  f7fffffe          BL       NAND_MarkBadBlock
0000ac  f7fffffe          BL       NAND_BuildLUT
0000b0  e003              B        |L35.186|
                  |L35.178|
0000b2  f7fffffe          BL       NAND_BuildLUT
0000b6  e007              B        |L35.200|
                  |L35.184|
0000b8  bf00              NOP                            ;800
                  |L35.186|
0000ba  f10b0001          ADD      r0,r11,#1             ;757
0000be  fa1ffb80          UXTH     r11,r0                ;757
                  |L35.194|
0000c2  f1bb0f0a          CMP      r11,#0xa              ;757
0000c6  dba9              BLT      |L35.28|
                  |L35.200|
0000c8  bf00              NOP                            ;811
0000ca  2000              MOVS     r0,#0                 ;815
0000cc  e7ad              B        |L35.42|
;;;817    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_usLUT
                          %        2048
                  s_ucTempBuf
                          %        2112

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  48593237          DCB      "HY27UF081G2A\r\n  1024 Blocks, 64 pages per block, 2048"
000004  55463038
000008  31473241
00000c  0d0a2020
000010  31303234
000014  20426c6f
000018  636b732c
00001c  20363420
000020  70616765
000024  73207065
000028  7220626c
00002c  6f636b2c
000030  20323034
000034  38      
000035  202b2036          DCB      " + 64 bytes per page\r\n",0
000039  34206279
00003d  74657320
000041  70657220
000045  70616765
000049  0d0a00  
00004c  4b394631          DCB      "K9F1G08U0A\r\n  1024 Blocks, 64 pages per block, 2048 +"
000050  47303855
000054  30410d0a
000058  20203130
00005c  32342042
000060  6c6f636b
000064  732c2036
000068  34207061
00006c  67657320
000070  70657220
000074  626c6f63
000078  6b2c2032
00007c  30343820
000080  2b      
000081  20363420          DCB      " 64 bytes per page\r\n",0
000085  62797465
000089  73207065
00008d  72207061
000091  67650d0a
000095  00      
000096  00                DCB      0
000097  00                DCB      0
000098  4b394631          DCB      "K9F1G08U0B\r\n  1024 Blocks, 64 pages per block, 2048 +"
00009c  47303855
0000a0  30420d0a
0000a4  20203130
0000a8  32342042
0000ac  6c6f636b
0000b0  732c2036
0000b4  34207061
0000b8  67657320
0000bc  70657220
0000c0  626c6f63
0000c4  6b2c2032
0000c8  30343820
0000cc  2b      
0000cd  20363420          DCB      " 64 bytes per page\r\n",0
0000d1  62797465
0000d5  73207065
0000d9  72207061
0000dd  67650d0a
0000e1  00      

                          AREA ||.data||, DATA, ALIGN=1

                  s_usValidDataBlockCount
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_nand_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_nand_flash_c_7c01b1d9____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_nand_flash_c_7c01b1d9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_nand_flash_c_7c01b1d9____REVSH|
#line 144
|__asm___16_bsp_nand_flash_c_7c01b1d9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
