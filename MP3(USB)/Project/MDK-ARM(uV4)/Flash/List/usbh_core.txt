; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usbh_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usbh_core.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usbh_core.crf ..\..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connected||, CODE, READONLY, ALIGN=1

                  USBH_Connected PROC
;;;117    */
;;;118    uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;119    {
;;;120      pdev->host.ConnSts = 1;
000002  2201              MOVS     r2,#1
000004  f8c12310          STR      r2,[r1,#0x310]
;;;121      return 0;
000008  2000              MOVS     r0,#0
;;;122    }
00000a  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;192      */
;;;193    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;195      /* Software Init */
;;;196      
;;;197      phost->gState = HOST_IDLE;
000006  2000              MOVS     r0,#0
000008  7020              STRB     r0,[r4,#0]
;;;198      phost->gStateBkp = HOST_IDLE; 
00000a  7060              STRB     r0,[r4,#1]
;;;199      phost->EnumState = ENUM_IDLE;
00000c  70a0              STRB     r0,[r4,#2]
;;;200      phost->RequestState = CMD_SEND;  
00000e  2001              MOVS     r0,#1
000010  70e0              STRB     r0,[r4,#3]
;;;201      
;;;202      phost->Control.state = CTRL_SETUP;
000012  2101              MOVS     r1,#1
000014  7721              STRB     r1,[r4,#0x1c]
;;;203      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000016  2140              MOVS     r1,#0x40
000018  71a1              STRB     r1,[r4,#6]
;;;204      
;;;205      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
00001a  2000              MOVS     r0,#0
00001c  f8840020          STRB     r0,[r4,#0x20]
;;;206      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
000020  2101              MOVS     r1,#1
000022  2021              MOVS     r0,#0x21
000024  5501              STRB     r1,[r0,r4]
;;;207      
;;;208      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000026  7921              LDRB     r1,[r4,#4]
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       USBH_Free_Channel
;;;209      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
00002e  7961              LDRB     r1,[r4,#5]
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       USBH_Free_Channel
;;;210      return USBH_OK;
000036  2000              MOVS     r0,#0
;;;211    }
000038  bd70              POP      {r4-r6,pc}
;;;212    
                          ENDP


                          AREA ||i.USBH_Disconnected||, CODE, READONLY, ALIGN=1

                  USBH_Disconnected PROC
;;;130    
;;;131    uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;132    {
;;;133      pdev->host.ConnSts = 0;
000002  2200              MOVS     r2,#0
000004  f8c12310          STR      r2,[r1,#0x310]
;;;134      return 0;  
000008  2000              MOVS     r0,#0
;;;135    }
00000a  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;370      */
;;;371    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;373      /* Error unrecovered or not supported device speed */
;;;374      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
000006  2d05              CMP      r5,#5
000008  d001              BEQ      |L4.14|
;;;375           (errType == USBH_UNRECOVERED_ERROR) )
00000a  2d04              CMP      r5,#4
00000c  d106              BNE      |L4.28|
                  |L4.14|
;;;376      {
;;;377        phost->usr_cb->UnrecoveredError(); 
00000e  f8d41080          LDR      r1,[r4,#0x80]
000012  6c48              LDR      r0,[r1,#0x44]
000014  4780              BLX      r0
;;;378        phost->gState = HOST_ERROR_STATE;   
000016  200a              MOVS     r0,#0xa
000018  7020              STRB     r0,[r4,#0]
00001a  e007              B        |L4.44|
                  |L4.28|
;;;379      }  
;;;380      /* USB host restart requested from application layer */
;;;381      else if(errType == USBH_APPLY_DEINIT)
00001c  2d06              CMP      r5,#6
00001e  d105              BNE      |L4.44|
;;;382      {
;;;383        phost->gState = HOST_ERROR_STATE;  
000020  200a              MOVS     r0,#0xa
000022  7020              STRB     r0,[r4,#0]
;;;384        /* user callback for initalization */
;;;385        phost->usr_cb->Init();
000024  f8d41080          LDR      r1,[r4,#0x80]
000028  6808              LDR      r0,[r1,#0]
00002a  4780              BLX      r0
                  |L4.44|
;;;386      } 
;;;387    }
00002c  bd70              POP      {r4-r6,pc}
;;;388    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;586      */
;;;587    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;588    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;589      uint8_t direction;  
;;;590      static uint16_t timeout = 0;
;;;591      USBH_Status status = USBH_OK;
000008  f04f0800          MOV      r8,#0
;;;592      URB_STATE URB_Status = URB_IDLE;
00000c  2500              MOVS     r5,#0
;;;593      
;;;594      phost->Control.status = CTRL_START;
00000e  2100              MOVS     r1,#0
000010  74a1              STRB     r1,[r4,#0x12]
;;;595    
;;;596      
;;;597      switch (phost->Control.state)
000012  7f20              LDRB     r0,[r4,#0x1c]
000014  280c              CMP      r0,#0xc
000016  d276              BCS      |L5.262|
000018  e8dff000          TBB      [pc,r0]
00001c  fd060f3d          DCB      0xfd,0x06,0x0f,0x3d
000020  46657691          DCB      0x46,0x65,0x76,0x91
000024  9ac0d7ed          DCB      0x9a,0xc0,0xd7,0xed
;;;598      {
;;;599      case CTRL_SETUP:
;;;600        /* send a SETUP packet */
;;;601        USBH_CtlSendSetup     (pdev, 
000028  7962              LDRB     r2,[r4,#5]
00002a  f1040114          ADD      r1,r4,#0x14
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       USBH_CtlSendSetup
;;;602    	                   phost->Control.setup.d8 , 
;;;603    	                   phost->Control.hc_num_out);  
;;;604        phost->Control.state = CTRL_SETUP_WAIT;  
000034  2102              MOVS     r1,#2
000036  7721              STRB     r1,[r4,#0x1c]
;;;605        break; 
000038  e0ee              B        |L5.536|
;;;606        
;;;607      case CTRL_SETUP_WAIT:
;;;608        
;;;609        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
00003a  7961              LDRB     r1,[r4,#5]
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       HCD_GetURB_State
000042  4605              MOV      r5,r0
;;;610        /* case SETUP packet sent successfully */
;;;611        if(URB_Status == URB_DONE)
000044  2d01              CMP      r5,#1
000046  d11f              BNE      |L5.136|
;;;612        { 
;;;613          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
000048  7d20              LDRB     r0,[r4,#0x14]
00004a  f0000780          AND      r7,r0,#0x80
;;;614          
;;;615          /* check if there is a data stage */
;;;616          if (phost->Control.setup.b.wLength.w != 0 )
00004e  8b60              LDRH     r0,[r4,#0x1a]
000050  b158              CBZ      r0,|L5.106|
;;;617          {        
;;;618            timeout = DATA_STAGE_TIMEOUT;
000052  f2413088          MOV      r0,#0x1388
000056  4972              LDR      r1,|L5.544|
000058  8008              STRH     r0,[r1,#0]
;;;619            if (direction == USB_D2H)
00005a  2f80              CMP      r7,#0x80
00005c  d102              BNE      |L5.100|
;;;620            {
;;;621              /* Data Direction is IN */
;;;622              phost->Control.state = CTRL_DATA_IN;
00005e  2103              MOVS     r1,#3
000060  7721              STRB     r1,[r4,#0x1c]
000062  e00c              B        |L5.126|
                  |L5.100|
;;;623            }
;;;624            else
;;;625            {
;;;626              /* Data Direction is OUT */
;;;627              phost->Control.state = CTRL_DATA_OUT;
000064  2105              MOVS     r1,#5
000066  7721              STRB     r1,[r4,#0x1c]
000068  e009              B        |L5.126|
                  |L5.106|
;;;628            } 
;;;629          }
;;;630          /* No DATA stage */
;;;631          else
;;;632          {
;;;633            timeout = NODATA_STAGE_TIMEOUT;
00006a  2032              MOVS     r0,#0x32
00006c  496c              LDR      r1,|L5.544|
00006e  8008              STRH     r0,[r1,#0]
;;;634            
;;;635            /* If there is No Data Transfer Stage */
;;;636            if (direction == USB_D2H)
000070  2f80              CMP      r7,#0x80
000072  d102              BNE      |L5.122|
;;;637            {
;;;638              /* Data Direction is IN */
;;;639              phost->Control.state = CTRL_STATUS_OUT;
000074  2109              MOVS     r1,#9
000076  7721              STRB     r1,[r4,#0x1c]
000078  e001              B        |L5.126|
                  |L5.122|
;;;640            }
;;;641            else
;;;642            {
;;;643              /* Data Direction is OUT */
;;;644              phost->Control.state = CTRL_STATUS_IN;
00007a  2107              MOVS     r1,#7
00007c  7721              STRB     r1,[r4,#0x1c]
                  |L5.126|
;;;645            } 
;;;646          }          
;;;647          /* Set the delay timer to enable timeout for data stage completion */
;;;648          phost->Control.timer = HCD_GetCurrentFrame(pdev);
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       HCD_GetCurrentFrame
000084  8220              STRH     r0,[r4,#0x10]
000086  e005              B        |L5.148|
                  |L5.136|
;;;649        }
;;;650        else if(URB_Status == URB_ERROR)
000088  2d03              CMP      r5,#3
00008a  d103              BNE      |L5.148|
;;;651        {
;;;652          phost->Control.state = CTRL_ERROR;     
00008c  210b              MOVS     r1,#0xb
00008e  7721              STRB     r1,[r4,#0x1c]
;;;653          phost->Control.status = CTRL_XACTERR;
000090  2105              MOVS     r1,#5
000092  74a1              STRB     r1,[r4,#0x12]
                  |L5.148|
;;;654        }    
;;;655        break;
000094  e0c0              B        |L5.536|
;;;656        
;;;657      case CTRL_DATA_IN:  
;;;658        /* Issue an IN token */ 
;;;659        USBH_CtlReceiveData(pdev,
000096  7923              LDRB     r3,[r4,#4]
000098  89a2              LDRH     r2,[r4,#0xc]
00009a  4630              MOV      r0,r6
00009c  68a1              LDR      r1,[r4,#8]
00009e  f7fffffe          BL       USBH_CtlReceiveData
;;;660                            phost->Control.buff, 
;;;661                            phost->Control.length,
;;;662                            phost->Control.hc_num_in);
;;;663     
;;;664        phost->Control.state = CTRL_DATA_IN_WAIT;
0000a2  2104              MOVS     r1,#4
0000a4  7721              STRB     r1,[r4,#0x1c]
;;;665        break;    
0000a6  e0b7              B        |L5.536|
;;;666        
;;;667      case CTRL_DATA_IN_WAIT:
;;;668        
;;;669        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
0000a8  7921              LDRB     r1,[r4,#4]
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       HCD_GetURB_State
0000b0  4605              MOV      r5,r0
;;;670        
;;;671        /* check is DATA packet transfered successfully */
;;;672        if  (URB_Status == URB_DONE)
0000b2  2d01              CMP      r5,#1
0000b4  d101              BNE      |L5.186|
;;;673        { 
;;;674          phost->Control.state = CTRL_STATUS_OUT;
0000b6  2109              MOVS     r1,#9
0000b8  7721              STRB     r1,[r4,#0x1c]
                  |L5.186|
;;;675        }
;;;676       
;;;677        /* manage error cases*/
;;;678        if  (URB_Status == URB_STALL) 
0000ba  2d04              CMP      r5,#4
0000bc  d102              BNE      |L5.196|
;;;679        { 
;;;680          /* In stall case, return to previous machine state*/
;;;681          phost->gState =   phost->gStateBkp;
0000be  7860              LDRB     r0,[r4,#1]
0000c0  7020              STRB     r0,[r4,#0]
0000c2  e00f              B        |L5.228|
                  |L5.196|
;;;682        }   
;;;683        else if (URB_Status == URB_ERROR)
0000c4  2d03              CMP      r5,#3
0000c6  d102              BNE      |L5.206|
;;;684        {
;;;685          /* Device error */
;;;686          phost->Control.state = CTRL_ERROR;    
0000c8  210b              MOVS     r1,#0xb
0000ca  7721              STRB     r1,[r4,#0x1c]
0000cc  e00a              B        |L5.228|
                  |L5.206|
;;;687        }
;;;688        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       HCD_GetCurrentFrame
0000d4  8a21              LDRH     r1,[r4,#0x10]
0000d6  1a40              SUBS     r0,r0,r1
0000d8  4951              LDR      r1,|L5.544|
0000da  8809              LDRH     r1,[r1,#0]  ; timeout
0000dc  4288              CMP      r0,r1
0000de  d901              BLS      |L5.228|
;;;689        {
;;;690          /* timeout for IN transfer */
;;;691          phost->Control.state = CTRL_ERROR; 
0000e0  210b              MOVS     r1,#0xb
0000e2  7721              STRB     r1,[r4,#0x1c]
                  |L5.228|
;;;692        }   
;;;693        break;
0000e4  e098              B        |L5.536|
;;;694        
;;;695      case CTRL_DATA_OUT:
;;;696        /* Start DATA out transfer (only one DATA packet)*/
;;;697        pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
0000e6  2101              MOVS     r1,#1
0000e8  7962              LDRB     r2,[r4,#5]
0000ea  f506706b          ADD      r0,r6,#0x3ac
0000ee  eb001042          ADD      r0,r0,r2,LSL #5
0000f2  7641              STRB     r1,[r0,#0x19]
;;;698            
;;;699        USBH_CtlSendData (pdev,
0000f4  7963              LDRB     r3,[r4,#5]
0000f6  89a2              LDRH     r2,[r4,#0xc]
0000f8  4630              MOV      r0,r6
0000fa  68a1              LDR      r1,[r4,#8]
0000fc  f7fffffe          BL       USBH_CtlSendData
;;;700                          phost->Control.buff, 
;;;701                          phost->Control.length , 
;;;702                          phost->Control.hc_num_out);
;;;703        
;;;704    
;;;705    
;;;706    
;;;707        
;;;708        phost->Control.state = CTRL_DATA_OUT_WAIT;
000100  2106              MOVS     r1,#6
000102  7721              STRB     r1,[r4,#0x1c]
;;;709        break;
000104  e088              B        |L5.536|
                  |L5.262|
000106  e086              B        |L5.534|
;;;710        
;;;711      case CTRL_DATA_OUT_WAIT:
;;;712        
;;;713        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
000108  7961              LDRB     r1,[r4,#5]
00010a  4630              MOV      r0,r6
00010c  f7fffffe          BL       HCD_GetURB_State
000110  4605              MOV      r5,r0
;;;714        if  (URB_Status == URB_DONE)
000112  2d01              CMP      r5,#1
000114  d102              BNE      |L5.284|
;;;715        { /* If the Setup Pkt is sent successful, then change the state */
;;;716          phost->Control.state = CTRL_STATUS_IN;
000116  2107              MOVS     r1,#7
000118  7721              STRB     r1,[r4,#0x1c]
00011a  e00f              B        |L5.316|
                  |L5.284|
;;;717        }
;;;718        
;;;719        /* handle error cases */
;;;720        else if  (URB_Status == URB_STALL) 
00011c  2d04              CMP      r5,#4
00011e  d104              BNE      |L5.298|
;;;721        { 
;;;722          /* In stall case, return to previous machine state*/
;;;723          phost->gState =   phost->gStateBkp;
000120  7860              LDRB     r0,[r4,#1]
000122  7020              STRB     r0,[r4,#0]
;;;724          phost->Control.state = CTRL_STALLED;  
000124  210c              MOVS     r1,#0xc
000126  7721              STRB     r1,[r4,#0x1c]
000128  e008              B        |L5.316|
                  |L5.298|
;;;725        } 
;;;726        else if  (URB_Status == URB_NOTREADY)
00012a  2d02              CMP      r5,#2
00012c  d102              BNE      |L5.308|
;;;727        { 
;;;728          /* Nack received from device */
;;;729          phost->Control.state = CTRL_DATA_OUT;
00012e  2105              MOVS     r1,#5
000130  7721              STRB     r1,[r4,#0x1c]
000132  e003              B        |L5.316|
                  |L5.308|
;;;730        }    
;;;731        else if (URB_Status == URB_ERROR)
000134  2d03              CMP      r5,#3
000136  d101              BNE      |L5.316|
;;;732        {
;;;733          /* device error */
;;;734          phost->Control.state = CTRL_ERROR;      
000138  210b              MOVS     r1,#0xb
00013a  7721              STRB     r1,[r4,#0x1c]
                  |L5.316|
;;;735        } 
;;;736        break;
00013c  e06c              B        |L5.536|
;;;737        
;;;738        
;;;739      case CTRL_STATUS_IN:
;;;740        /* Send 0 bytes out packet */
;;;741        USBH_CtlReceiveData (pdev,
00013e  7923              LDRB     r3,[r4,#4]
000140  2200              MOVS     r2,#0
000142  4611              MOV      r1,r2
000144  4630              MOV      r0,r6
000146  f7fffffe          BL       USBH_CtlReceiveData
;;;742                             0,
;;;743                             0,
;;;744                             phost->Control.hc_num_in);
;;;745        
;;;746        phost->Control.state = CTRL_STATUS_IN_WAIT;
00014a  2108              MOVS     r1,#8
00014c  7721              STRB     r1,[r4,#0x1c]
;;;747        
;;;748        break;
00014e  e063              B        |L5.536|
;;;749        
;;;750      case CTRL_STATUS_IN_WAIT:
;;;751        
;;;752        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
000150  7921              LDRB     r1,[r4,#4]
000152  4630              MOV      r0,r6
000154  f7fffffe          BL       HCD_GetURB_State
000158  4605              MOV      r5,r0
;;;753        
;;;754        if  ( URB_Status == URB_DONE)
00015a  2d01              CMP      r5,#1
00015c  d104              BNE      |L5.360|
;;;755        { /* Control transfers completed, Exit the State Machine */
;;;756          phost->gState =   phost->gStateBkp;
00015e  7860              LDRB     r0,[r4,#1]
000160  7020              STRB     r0,[r4,#0]
;;;757          phost->Control.state = CTRL_COMPLETE;
000162  210d              MOVS     r1,#0xd
000164  7721              STRB     r1,[r4,#0x1c]
000166  e018              B        |L5.410|
                  |L5.360|
;;;758        }
;;;759        
;;;760        else if (URB_Status == URB_ERROR)
000168  2d03              CMP      r5,#3
00016a  d102              BNE      |L5.370|
;;;761        {
;;;762          phost->Control.state = CTRL_ERROR;  
00016c  210b              MOVS     r1,#0xb
00016e  7721              STRB     r1,[r4,#0x1c]
000170  e013              B        |L5.410|
                  |L5.370|
;;;763        }
;;;764        
;;;765        else if((HCD_GetCurrentFrame(pdev)\
000172  4630              MOV      r0,r6
000174  f7fffffe          BL       HCD_GetCurrentFrame
000178  8a21              LDRH     r1,[r4,#0x10]
00017a  1a40              SUBS     r0,r0,r1
00017c  4928              LDR      r1,|L5.544|
00017e  8809              LDRH     r1,[r1,#0]  ; timeout
000180  4288              CMP      r0,r1
000182  d902              BLS      |L5.394|
;;;766          - phost->Control.timer) > timeout)
;;;767        {
;;;768          phost->Control.state = CTRL_ERROR; 
000184  210b              MOVS     r1,#0xb
000186  7721              STRB     r1,[r4,#0x1c]
000188  e007              B        |L5.410|
                  |L5.394|
;;;769        }
;;;770         else if(URB_Status == URB_STALL)
00018a  2d04              CMP      r5,#4
00018c  d105              BNE      |L5.410|
;;;771        {
;;;772          /* Control transfers completed, Exit the State Machine */
;;;773          phost->gState =   phost->gStateBkp;
00018e  7860              LDRB     r0,[r4,#1]
000190  7020              STRB     r0,[r4,#0]
;;;774          phost->Control.status = CTRL_STALL;
000192  2104              MOVS     r1,#4
000194  74a1              STRB     r1,[r4,#0x12]
;;;775          status = USBH_NOT_SUPPORTED;
000196  f04f0803          MOV      r8,#3
                  |L5.410|
;;;776        }
;;;777        break;
00019a  e03d              B        |L5.536|
;;;778        
;;;779      case CTRL_STATUS_OUT:
;;;780        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
00019c  7961              LDRB     r1,[r4,#5]
00019e  f506706b          ADD      r0,r6,#0x3ac
0001a2  eb001041          ADD      r0,r0,r1,LSL #5
0001a6  7e40              LDRB     r0,[r0,#0x19]
0001a8  f0800101          EOR      r1,r0,#1
0001ac  7962              LDRB     r2,[r4,#5]
0001ae  f506706b          ADD      r0,r6,#0x3ac
0001b2  eb001042          ADD      r0,r0,r2,LSL #5
0001b6  7641              STRB     r1,[r0,#0x19]
;;;781        USBH_CtlSendData (pdev,
0001b8  7963              LDRB     r3,[r4,#5]
0001ba  2200              MOVS     r2,#0
0001bc  4611              MOV      r1,r2
0001be  4630              MOV      r0,r6
0001c0  f7fffffe          BL       USBH_CtlSendData
;;;782                          0,
;;;783                          0,
;;;784                          phost->Control.hc_num_out);
;;;785        
;;;786        phost->Control.state = CTRL_STATUS_OUT_WAIT;
0001c4  210a              MOVS     r1,#0xa
0001c6  7721              STRB     r1,[r4,#0x1c]
;;;787        break;
0001c8  e026              B        |L5.536|
;;;788        
;;;789      case CTRL_STATUS_OUT_WAIT: 
;;;790        
;;;791        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
0001ca  7961              LDRB     r1,[r4,#5]
0001cc  4630              MOV      r0,r6
0001ce  f7fffffe          BL       HCD_GetURB_State
0001d2  4605              MOV      r5,r0
;;;792        if  (URB_Status == URB_DONE)
0001d4  2d01              CMP      r5,#1
0001d6  d104              BNE      |L5.482|
;;;793        { 
;;;794          phost->gState =   phost->gStateBkp; 
0001d8  7860              LDRB     r0,[r4,#1]
0001da  7020              STRB     r0,[r4,#0]
;;;795          phost->Control.state = CTRL_COMPLETE; 
0001dc  210d              MOVS     r1,#0xd
0001de  7721              STRB     r1,[r4,#0x1c]
0001e0  e008              B        |L5.500|
                  |L5.482|
;;;796        }
;;;797        else if  (URB_Status == URB_NOTREADY)
0001e2  2d02              CMP      r5,#2
0001e4  d102              BNE      |L5.492|
;;;798        { 
;;;799          phost->Control.state = CTRL_STATUS_OUT;
0001e6  2109              MOVS     r1,#9
0001e8  7721              STRB     r1,[r4,#0x1c]
0001ea  e003              B        |L5.500|
                  |L5.492|
;;;800        }      
;;;801        else if (URB_Status == URB_ERROR)
0001ec  2d03              CMP      r5,#3
0001ee  d101              BNE      |L5.500|
;;;802        {
;;;803          phost->Control.state = CTRL_ERROR;      
0001f0  210b              MOVS     r1,#0xb
0001f2  7721              STRB     r1,[r4,#0x1c]
                  |L5.500|
;;;804        }
;;;805        break;
0001f4  e010              B        |L5.536|
;;;806        
;;;807      case CTRL_ERROR:
;;;808        /* 
;;;809        After a halt condition is encountered or an error is detected by the 
;;;810        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;811        PID; i.e., recovery actions via some other pipe are not required for control
;;;812        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;813        required to clear the halt or error condition if the next Setup PID is not 
;;;814        accepted.
;;;815        */
;;;816        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001f6  7ba0              LDRB     r0,[r4,#0xe]
0001f8  1c40              ADDS     r0,r0,#1
0001fa  b2c1              UXTB     r1,r0
0001fc  73a1              STRB     r1,[r4,#0xe]
0001fe  2902              CMP      r1,#2
000200  dc02              BGT      |L5.520|
;;;817        {
;;;818          /* Do the transmission again, starting from SETUP Packet */
;;;819          phost->Control.state = CTRL_SETUP; 
000202  2101              MOVS     r1,#1
000204  7721              STRB     r1,[r4,#0x1c]
000206  e005              B        |L5.532|
                  |L5.520|
;;;820        }
;;;821        else
;;;822        {
;;;823          phost->Control.status = CTRL_FAIL;
000208  2108              MOVS     r1,#8
00020a  74a1              STRB     r1,[r4,#0x12]
;;;824          phost->gState =   phost->gStateBkp;
00020c  7860              LDRB     r0,[r4,#1]
00020e  7020              STRB     r0,[r4,#0]
;;;825          
;;;826          status = USBH_FAIL;
000210  f04f0802          MOV      r8,#2
                  |L5.532|
;;;827        }
;;;828        break;
000214  e000              B        |L5.536|
                  |L5.534|
;;;829        
;;;830      default:
;;;831        break;
000216  bf00              NOP      
                  |L5.536|
000218  bf00              NOP                            ;605
;;;832      }
;;;833      return status;
00021a  4640              MOV      r0,r8
;;;834    }
00021c  e8bd81f0          POP      {r4-r8,pc}
;;;835    
                          ENDP

                  |L5.544|
                          DCD      timeout

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;395      */
;;;396    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;397    {
000002  b092              SUB      sp,sp,#0x48
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;398      USBH_Status Status = USBH_BUSY;  
000008  2601              MOVS     r6,#1
;;;399      uint8_t Local_Buffer[64];
;;;400      
;;;401      switch (phost->EnumState)
00000a  78a0              LDRB     r0,[r4,#2]
00000c  280a              CMP      r0,#0xa
00000e  d27a              BCS      |L6.262|
000010  e8dff000          TBB      [pc,r0]
000014  0528375d          DCB      0x05,0x28,0x37,0x5d
000018  667a97b4          DCB      0x66,0x7a,0x97,0xb4
00001c  d1db              DCB      0xd1,0xdb
;;;402      {
;;;403      case ENUM_IDLE:  
;;;404        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;405        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
00001e  2208              MOVS     r2,#8
000020  4621              MOV      r1,r4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Get_DevDesc
000028  b9d8              CBNZ     r0,|L6.98|
;;;406        {
;;;407          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
00002a  f8941029          LDRB     r1,[r4,#0x29]
00002e  71a1              STRB     r1,[r4,#6]
;;;408          
;;;409          /* Issue Reset  */
;;;410          HCD_ResetPort(pdev);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       HCD_ResetPort
;;;411          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
000036  2001              MOVS     r0,#1
000038  70a0              STRB     r0,[r4,#2]
;;;412          
;;;413          /* modify control channels configuration for MaxPacket size */
;;;414          USBH_Modify_Channel (pdev,
00003a  79a0              LDRB     r0,[r4,#6]
00003c  2100              MOVS     r1,#0
00003e  e9cd1000          STRD     r1,r0,[sp,#0]
000042  7961              LDRB     r1,[r4,#5]
000044  2300              MOVS     r3,#0
000046  461a              MOV      r2,r3
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       USBH_Modify_Channel
;;;415                               phost->Control.hc_num_out,
;;;416                               0,
;;;417                               0,
;;;418                               0,
;;;419                               phost->Control.ep0size);
;;;420          
;;;421          USBH_Modify_Channel (pdev,
00004e  79a0              LDRB     r0,[r4,#6]
000050  2100              MOVS     r1,#0
000052  e9cd1000          STRD     r1,r0,[sp,#0]
000056  7921              LDRB     r1,[r4,#4]
000058  2300              MOVS     r3,#0
00005a  461a              MOV      r2,r3
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       USBH_Modify_Channel
                  |L6.98|
;;;422                               phost->Control.hc_num_in,
;;;423                               0,
;;;424                               0,
;;;425                               0,
;;;426                               phost->Control.ep0size);      
;;;427        }
;;;428        break;
000062  e0b5              B        |L6.464|
;;;429        
;;;430      case ENUM_GET_FULL_DEV_DESC:  
;;;431        /* Get FULL Device Desc  */
;;;432        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
000064  2212              MOVS     r2,#0x12
000066  4621              MOV      r1,r4
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       USBH_Get_DevDesc
00006e  b938              CBNZ     r0,|L6.128|
;;;433          == USBH_OK)
;;;434        {
;;;435          /* user callback for device descriptor available */
;;;436          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
000070  f8d40080          LDR      r0,[r4,#0x80]
000074  69c1              LDR      r1,[r0,#0x1c]
000076  f1040022          ADD      r0,r4,#0x22
00007a  4788              BLX      r1
;;;437          phost->EnumState = ENUM_SET_ADDR;
00007c  2002              MOVS     r0,#2
00007e  70a0              STRB     r0,[r4,#2]
                  |L6.128|
;;;438        }
;;;439        break;
000080  e0a6              B        |L6.464|
;;;440       
;;;441      case ENUM_SET_ADDR: 
;;;442        /* set address */
;;;443        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
000082  2201              MOVS     r2,#1
000084  4621              MOV      r1,r4
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       USBH_SetAddress
00008c  b9f0              CBNZ     r0,|L6.204|
;;;444        {
;;;445          USB_OTG_BSP_mDelay(2);
00008e  2002              MOVS     r0,#2
000090  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;446          phost->device_prop.address = USBH_DEVICE_ADDRESS;
000094  2001              MOVS     r0,#1
000096  1ca4              ADDS     r4,r4,#2
000098  77a0              STRB     r0,[r4,#0x1e]
;;;447          
;;;448          /* user callback for device address assigned */
;;;449          phost->usr_cb->DeviceAddressAssigned();
00009a  f8d4107e          LDR      r1,[r4,#0x7e]
00009e  6a08              LDR      r0,[r1,#0x20]
0000a0  4780              BLX      r0
;;;450          phost->EnumState = ENUM_GET_CFG_DESC;
0000a2  2003              MOVS     r0,#3
0000a4  7020              STRB     r0,[r4,#0]
;;;451          
;;;452          /* modify control channels to update device address */
;;;453          USBH_Modify_Channel (pdev,
0000a6  2000              MOVS     r0,#0
0000a8  9000              STR      r0,[sp,#0]
0000aa  9001              STR      r0,[sp,#4]
0000ac  7fa2              LDRB     r2,[r4,#0x1e]
0000ae  78a1              LDRB     r1,[r4,#2]
0000b0  4603              MOV      r3,r0
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       USBH_Modify_Channel
;;;454                               phost->Control.hc_num_in,
;;;455                               phost->device_prop.address,
;;;456                               0,
;;;457                               0,
;;;458                               0);
;;;459          
;;;460          USBH_Modify_Channel (pdev,
0000b8  2000              MOVS     r0,#0
0000ba  9000              STR      r0,[sp,#0]
0000bc  9001              STR      r0,[sp,#4]
0000be  7fa2              LDRB     r2,[r4,#0x1e]
0000c0  1ea4              SUBS     r4,r4,#2
0000c2  7961              LDRB     r1,[r4,#5]
0000c4  4603              MOV      r3,r0
0000c6  4628              MOV      r0,r5
0000c8  f7fffffe          BL       USBH_Modify_Channel
                  |L6.204|
;;;461                               phost->Control.hc_num_out,
;;;462                               phost->device_prop.address,
;;;463                               0,
;;;464                               0,
;;;465                               0);         
;;;466        }
;;;467        break;
0000cc  e080              B        |L6.464|
;;;468        
;;;469      case ENUM_GET_CFG_DESC:  
;;;470        /* get standard configuration descriptor */
;;;471        if ( USBH_Get_CfgDesc(pdev, 
0000ce  2209              MOVS     r2,#9
0000d0  4621              MOV      r1,r4
0000d2  4628              MOV      r0,r5
0000d4  f7fffffe          BL       USBH_Get_CfgDesc
0000d8  b908              CBNZ     r0,|L6.222|
;;;472                              phost,
;;;473                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;474        {
;;;475          phost->EnumState = ENUM_GET_FULL_CFG_DESC;
0000da  2004              MOVS     r0,#4
0000dc  70a0              STRB     r0,[r4,#2]
                  |L6.222|
;;;476        }
;;;477        break;
0000de  e077              B        |L6.464|
;;;478        
;;;479      case ENUM_GET_FULL_CFG_DESC:  
;;;480        /* get FULL config descriptor (config, interface, endpoints) */
;;;481        if (USBH_Get_CfgDesc(pdev, 
0000e0  8ee2              LDRH     r2,[r4,#0x36]
0000e2  4621              MOV      r1,r4
0000e4  4628              MOV      r0,r5
0000e6  f7fffffe          BL       USBH_Get_CfgDesc
0000ea  b958              CBNZ     r0,|L6.260|
;;;482                             phost,
;;;483                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;484        {
;;;485          /* User callback for configuration descriptors available */
;;;486          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
0000ec  f8d40080          LDR      r0,[r4,#0x80]
0000f0  f1040250          ADD      r2,r4,#0x50
0000f4  f104013e          ADD      r1,r4,#0x3e
0000f8  6a43              LDR      r3,[r0,#0x24]
0000fa  f1040034          ADD      r0,r4,#0x34
0000fe  4798              BLX      r3
;;;487                                                          phost->device_prop.Itf_Desc,
;;;488                                                          phost->device_prop.Ep_Desc[0]);
;;;489          
;;;490          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
000100  2005              MOVS     r0,#5
000102  70a0              STRB     r0,[r4,#2]
                  |L6.260|
;;;491        }
;;;492        break;
000104  e064              B        |L6.464|
                  |L6.262|
000106  e062              B        |L6.462|
;;;493        
;;;494      case ENUM_GET_MFC_STRING_DESC:  
;;;495        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
000108  f8940030          LDRB     r0,[r4,#0x30]
00010c  b188              CBZ      r0,|L6.306|
;;;496        { /* Check that Manufacturer String is available */
;;;497          
;;;498          if ( USBH_Get_StringDesc(pdev,
00010e  20ff              MOVS     r0,#0xff
000110  9000              STR      r0,[sp,#0]
000112  f8942030          LDRB     r2,[r4,#0x30]
000116  ab02              ADD      r3,sp,#8
000118  4621              MOV      r1,r4
00011a  4628              MOV      r0,r5
00011c  f7fffffe          BL       USBH_Get_StringDesc
000120  b970              CBNZ     r0,|L6.320|
;;;499                                   phost,
;;;500                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;501                                   Local_Buffer , 
;;;502                                   0xff) == USBH_OK)
;;;503          {
;;;504            /* User callback for Manufacturing string */
;;;505            phost->usr_cb->ManufacturerString(Local_Buffer);
000122  f8d40080          LDR      r0,[r4,#0x80]
000126  6a81              LDR      r1,[r0,#0x28]
000128  a802              ADD      r0,sp,#8
00012a  4788              BLX      r1
;;;506            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00012c  2006              MOVS     r0,#6
00012e  70a0              STRB     r0,[r4,#2]
000130  e006              B        |L6.320|
                  |L6.306|
;;;507          }
;;;508        }
;;;509        else
;;;510        {
;;;511          phost->usr_cb->ManufacturerString("N/A");      
000132  f8d40080          LDR      r0,[r4,#0x80]
000136  6a81              LDR      r1,[r0,#0x28]
000138  a027              ADR      r0,|L6.472|
00013a  4788              BLX      r1
;;;512          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
00013c  2006              MOVS     r0,#6
00013e  70a0              STRB     r0,[r4,#2]
                  |L6.320|
;;;513        }
;;;514        break;
000140  e046              B        |L6.464|
;;;515        
;;;516      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;517        if (phost->device_prop.Dev_Desc.iProduct != 0)
000142  f8940031          LDRB     r0,[r4,#0x31]
000146  b188              CBZ      r0,|L6.364|
;;;518        { /* Check that Product string is available */
;;;519          if ( USBH_Get_StringDesc(pdev,
000148  20ff              MOVS     r0,#0xff
00014a  9000              STR      r0,[sp,#0]
00014c  f8942031          LDRB     r2,[r4,#0x31]
000150  ab02              ADD      r3,sp,#8
000152  4621              MOV      r1,r4
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       USBH_Get_StringDesc
00015a  b970              CBNZ     r0,|L6.378|
;;;520                                   phost,
;;;521                                   phost->device_prop.Dev_Desc.iProduct, 
;;;522                                   Local_Buffer, 
;;;523                                   0xff) == USBH_OK)
;;;524          {
;;;525            /* User callback for Product string */
;;;526            phost->usr_cb->ProductString(Local_Buffer);
00015c  f8d40080          LDR      r0,[r4,#0x80]
000160  6ac1              LDR      r1,[r0,#0x2c]
000162  a802              ADD      r0,sp,#8
000164  4788              BLX      r1
;;;527            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000166  2007              MOVS     r0,#7
000168  70a0              STRB     r0,[r4,#2]
00016a  e006              B        |L6.378|
                  |L6.364|
;;;528          }
;;;529        }
;;;530        else
;;;531        {
;;;532          phost->usr_cb->ProductString("N/A");
00016c  f8d40080          LDR      r0,[r4,#0x80]
000170  6ac1              LDR      r1,[r0,#0x2c]
000172  a019              ADR      r0,|L6.472|
000174  4788              BLX      r1
;;;533          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
000176  2007              MOVS     r0,#7
000178  70a0              STRB     r0,[r4,#2]
                  |L6.378|
;;;534        } 
;;;535        break;
00017a  e029              B        |L6.464|
;;;536        
;;;537      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;538        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
00017c  f8940032          LDRB     r0,[r4,#0x32]
000180  b188              CBZ      r0,|L6.422|
;;;539        { /* Check that Serial number string is available */    
;;;540          if ( USBH_Get_StringDesc(pdev, 
000182  20ff              MOVS     r0,#0xff
000184  9000              STR      r0,[sp,#0]
000186  f8942032          LDRB     r2,[r4,#0x32]
00018a  ab02              ADD      r3,sp,#8
00018c  4621              MOV      r1,r4
00018e  4628              MOV      r0,r5
000190  f7fffffe          BL       USBH_Get_StringDesc
000194  b970              CBNZ     r0,|L6.436|
;;;541                                   phost,
;;;542                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;543                                   Local_Buffer, 
;;;544                                   0xff) == USBH_OK)
;;;545          {
;;;546            /* User callback for Serial number string */
;;;547            phost->usr_cb->SerialNumString(Local_Buffer);
000196  f8d40080          LDR      r0,[r4,#0x80]
00019a  6b01              LDR      r1,[r0,#0x30]
00019c  a802              ADD      r0,sp,#8
00019e  4788              BLX      r1
;;;548            phost->EnumState = ENUM_SET_CONFIGURATION;
0001a0  2008              MOVS     r0,#8
0001a2  70a0              STRB     r0,[r4,#2]
0001a4  e006              B        |L6.436|
                  |L6.422|
;;;549          }
;;;550        }
;;;551        else
;;;552        {
;;;553          phost->usr_cb->SerialNumString("N/A");      
0001a6  f8d40080          LDR      r0,[r4,#0x80]
0001aa  6b01              LDR      r1,[r0,#0x30]
0001ac  a00a              ADR      r0,|L6.472|
0001ae  4788              BLX      r1
;;;554          phost->EnumState = ENUM_SET_CONFIGURATION;
0001b0  2008              MOVS     r0,#8
0001b2  70a0              STRB     r0,[r4,#2]
                  |L6.436|
;;;555        }  
;;;556        break;
0001b4  e00c              B        |L6.464|
;;;557          
;;;558      case ENUM_SET_CONFIGURATION:
;;;559        /* set configuration  (default config) */
;;;560        if (USBH_SetCfg(pdev, 
0001b6  f8942039          LDRB     r2,[r4,#0x39]
0001ba  4621              MOV      r1,r4
0001bc  4628              MOV      r0,r5
0001be  f7fffffe          BL       USBH_SetCfg
0001c2  b908              CBNZ     r0,|L6.456|
;;;561                        phost,
;;;562                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;563        {
;;;564          phost->EnumState = ENUM_DEV_CONFIGURED;
0001c4  2009              MOVS     r0,#9
0001c6  70a0              STRB     r0,[r4,#2]
                  |L6.456|
;;;565        }
;;;566        break;
0001c8  e002              B        |L6.464|
;;;567    
;;;568        
;;;569      case ENUM_DEV_CONFIGURED:
;;;570        /* user callback for enumeration done */
;;;571        Status = USBH_OK;
0001ca  2600              MOVS     r6,#0
;;;572        break;
0001cc  e000              B        |L6.464|
                  |L6.462|
;;;573        
;;;574      default:
;;;575        break;
0001ce  bf00              NOP      
                  |L6.464|
0001d0  bf00              NOP                            ;428
;;;576      }  
;;;577      return Status;
0001d2  4630              MOV      r0,r6
;;;578    }
0001d4  b012              ADD      sp,sp,#0x48
0001d6  bd70              POP      {r4-r6,pc}
;;;579    
                          ENDP

                  |L6.472|
0001d8  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=1

                  USBH_Init PROC
;;;155      */
;;;156    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157                   USB_OTG_CORE_ID_TypeDef coreID,
;;;158                   USBH_HOST *phost,               
;;;159                   USBH_Class_cb_TypeDef *class_cb, 
;;;160                   USBH_Usr_cb_TypeDef *usr_cb)
;;;161    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;162         
;;;163      /* Hardware Init */
;;;164      USB_OTG_BSP_Init(pdev);  
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       USB_OTG_BSP_Init
;;;165      
;;;166      /* configure GPIO pin used for switching VBUS power */
;;;167      USB_OTG_BSP_ConfigVBUS(0);  
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;168      
;;;169      
;;;170      /* Host de-initializations */
;;;171      USBH_DeInit(pdev, phost);
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       USBH_DeInit
;;;172      
;;;173      /*Register class and user callbacks */
;;;174      phost->class_cb = class_cb;
000024  67e5              STR      r5,[r4,#0x7c]
;;;175      phost->usr_cb = usr_cb;  
000026  f8c48080          STR      r8,[r4,#0x80]
;;;176        
;;;177      /* Start the USB OTG core */     
;;;178       HCD_Init(pdev , coreID);
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       HCD_Init
;;;179       
;;;180      /* Upon Init call usr call back */
;;;181      phost->usr_cb->Init();
000032  f8d41080          LDR      r1,[r4,#0x80]
000036  6808              LDR      r0,[r1,#0]
000038  4780              BLX      r0
;;;182      
;;;183      /* Enable Interrupts */
;;;184      USB_OTG_BSP_EnableInterrupt(pdev);
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       USB_OTG_BSP_EnableInterrupt
;;;185    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;186    
                          ENDP


                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;218    */
;;;219    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  b53e              PUSH     {r1-r5,lr}
;;;220    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;221      volatile USBH_Status status = USBH_FAIL;
000006  2002              MOVS     r0,#2
000008  9002              STR      r0,[sp,#8]
;;;222      
;;;223      
;;;224      /* check for Host port events */
;;;225      if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HCD_IsDeviceConnected
000010  b930              CBNZ     r0,|L8.32|
000012  7820              LDRB     r0,[r4,#0]
000014  b120              CBZ      r0,|L8.32|
;;;226      {
;;;227        if(phost->gState != HOST_DEV_DISCONNECTED) 
000016  7820              LDRB     r0,[r4,#0]
000018  2802              CMP      r0,#2
00001a  d001              BEQ      |L8.32|
;;;228        {
;;;229          phost->gState = HOST_DEV_DISCONNECTED;
00001c  2002              MOVS     r0,#2
00001e  7020              STRB     r0,[r4,#0]
                  |L8.32|
;;;230        }
;;;231      }
;;;232        
;;;233      switch (phost->gState)
000020  7820              LDRB     r0,[r4,#0]
000022  280b              CMP      r0,#0xb
000024  d275              BCS      |L8.274|
000026  e8dff000          TBB      [pc,r0]
00002a  0610              DCB      0x06,0x10
00002c  9cb44d68          DCB      0x9c,0xb4,0x4d,0x68
000030  7b87598c          DCB      0x7b,0x87,0x59,0x8c
000034  8d00              DCB      0x8d,0x00
;;;234      {
;;;235      
;;;236      case HOST_IDLE :
;;;237        
;;;238        if (HCD_IsDeviceConnected(pdev))  
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       HCD_IsDeviceConnected
00003c  b120              CBZ      r0,|L8.72|
;;;239        {
;;;240          phost->gState = HOST_DEV_ATTACHED;
00003e  2001              MOVS     r0,#1
000040  7020              STRB     r0,[r4,#0]
;;;241          USB_OTG_BSP_mDelay(100);
000042  2064              MOVS     r0,#0x64
000044  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L8.72|
;;;242        }
;;;243        break;
000048  e0a4              B        |L8.404|
;;;244       
;;;245      case HOST_DEV_ATTACHED :
;;;246        
;;;247        phost->usr_cb->DeviceAttached();
00004a  f8d41080          LDR      r1,[r4,#0x80]
00004e  6888              LDR      r0,[r1,#8]
000050  4780              BLX      r0
;;;248        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
000052  2100              MOVS     r1,#0
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       USBH_Alloc_Channel
00005a  7160              STRB     r0,[r4,#5]
;;;249        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
00005c  2180              MOVS     r1,#0x80
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       USBH_Alloc_Channel
000064  7120              STRB     r0,[r4,#4]
;;;250      
;;;251        /* Reset USB Device */
;;;252        if ( HCD_ResetPort(pdev) == 0)
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       HCD_ResetPort
00006c  bb48              CBNZ     r0,|L8.194|
;;;253        {
;;;254          phost->usr_cb->ResetDevice();
00006e  f8d41080          LDR      r1,[r4,#0x80]
000072  68c8              LDR      r0,[r1,#0xc]
000074  4780              BLX      r0
;;;255          /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
;;;256          Host is Now ready to start the Enumeration 
;;;257          */
;;;258          
;;;259          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       HCD_GetCurrentSpeed
00007c  b2c1              UXTB     r1,r0
00007e  2021              MOVS     r0,#0x21
000080  5501              STRB     r1,[r0,r4]
;;;260          
;;;261          phost->gState = HOST_ENUMERATION;
000082  2004              MOVS     r0,#4
000084  7020              STRB     r0,[r4,#0]
;;;262          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
000086  2221              MOVS     r2,#0x21
000088  5d10              LDRB     r0,[r2,r4]
00008a  f8d42080          LDR      r2,[r4,#0x80]
00008e  6991              LDR      r1,[r2,#0x18]
000090  4788              BLX      r1
;;;263            
;;;264          /* Open Control pipes */
;;;265          USBH_Open_Channel (pdev,
000092  79a0              LDRB     r0,[r4,#6]
000094  2100              MOVS     r1,#0
000096  e9cd1000          STRD     r1,r0,[sp,#0]
00009a  2021              MOVS     r0,#0x21
00009c  5d03              LDRB     r3,[r0,r4]
00009e  f8942020          LDRB     r2,[r4,#0x20]
0000a2  7921              LDRB     r1,[r4,#4]
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       USBH_Open_Channel
;;;266                               phost->Control.hc_num_in,
;;;267                               phost->device_prop.address,
;;;268                               phost->device_prop.speed,
;;;269                               EP_TYPE_CTRL,
;;;270                               phost->Control.ep0size); 
;;;271          
;;;272          /* Open Control pipes */
;;;273          USBH_Open_Channel (pdev,
0000aa  79a0              LDRB     r0,[r4,#6]
0000ac  2100              MOVS     r1,#0
0000ae  e9cd1000          STRD     r1,r0,[sp,#0]
0000b2  2021              MOVS     r0,#0x21
0000b4  5d03              LDRB     r3,[r0,r4]
0000b6  f8942020          LDRB     r2,[r4,#0x20]
0000ba  7961              LDRB     r1,[r4,#5]
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       USBH_Open_Channel
                  |L8.194|
;;;274                               phost->Control.hc_num_out,
;;;275                               phost->device_prop.address,
;;;276                               phost->device_prop.speed,
;;;277                               EP_TYPE_CTRL,
;;;278                               phost->Control.ep0size);          
;;;279       }
;;;280        break;
0000c2  e067              B        |L8.404|
;;;281        
;;;282      case HOST_ENUMERATION:     
;;;283        /* Check for enumeration status */  
;;;284        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
0000c4  4621              MOV      r1,r4
0000c6  4628              MOV      r0,r5
0000c8  f7fffffe          BL       USBH_HandleEnum
0000cc  b928              CBNZ     r0,|L8.218|
;;;285        { 
;;;286          /* The function shall return USBH_OK when full enumeration is complete */
;;;287          
;;;288          /* user callback for end of device basic enumeration */
;;;289          phost->usr_cb->EnumerationDone();
0000ce  f8d41080          LDR      r1,[r4,#0x80]
0000d2  6b48              LDR      r0,[r1,#0x34]
0000d4  4780              BLX      r0
;;;290          
;;;291          phost->gState  = HOST_USR_INPUT;    
0000d6  2008              MOVS     r0,#8
0000d8  7020              STRB     r0,[r4,#0]
                  |L8.218|
;;;292        }
;;;293        break;
0000da  e05b              B        |L8.404|
;;;294        
;;;295      case HOST_USR_INPUT:    
;;;296        /*The function should return user response true to move to class state */
;;;297        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
0000dc  f8d41080          LDR      r1,[r4,#0x80]
0000e0  6b88              LDR      r0,[r1,#0x38]
0000e2  4780              BLX      r0
0000e4  2801              CMP      r0,#1
0000e6  d107              BNE      |L8.248|
;;;298        {
;;;299          if((phost->class_cb->Init(pdev, phost))\
0000e8  6fe0              LDR      r0,[r4,#0x7c]
0000ea  4621              MOV      r1,r4
0000ec  6802              LDR      r2,[r0,#0]
0000ee  4628              MOV      r0,r5
0000f0  4790              BLX      r2
0000f2  b908              CBNZ     r0,|L8.248|
;;;300            == USBH_OK)
;;;301          {
;;;302            phost->gState  = HOST_CLASS_REQUEST;     
0000f4  2005              MOVS     r0,#5
0000f6  7020              STRB     r0,[r4,#0]
                  |L8.248|
;;;303          }     
;;;304        }   
;;;305        break;
0000f8  e04c              B        |L8.404|
;;;306        
;;;307      case HOST_CLASS_REQUEST:  
;;;308        /* process class standard contol requests state machine */ 
;;;309        status = phost->class_cb->Requests(pdev, phost);
0000fa  6fe0              LDR      r0,[r4,#0x7c]
0000fc  4621              MOV      r1,r4
0000fe  6882              LDR      r2,[r0,#8]
000100  4628              MOV      r0,r5
000102  4790              BLX      r2
000104  9002              STR      r0,[sp,#8]
;;;310        
;;;311         if(status == USBH_OK)
000106  f89d0008          LDRB     r0,[sp,#8]
00010a  b918              CBNZ     r0,|L8.276|
;;;312         {
;;;313           phost->gState  = HOST_CLASS;
00010c  2006              MOVS     r0,#6
00010e  7020              STRB     r0,[r4,#0]
000110  e005              B        |L8.286|
                  |L8.274|
000112  e03e              B        |L8.402|
                  |L8.276|
;;;314         }  
;;;315         
;;;316         else
;;;317         {
;;;318           USBH_ErrorHandle(phost, status);
000114  f89d1008          LDRB     r1,[sp,#8]
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       USBH_ErrorHandle
                  |L8.286|
;;;319         }
;;;320     
;;;321        
;;;322        break;    
00011e  e039              B        |L8.404|
;;;323      case HOST_CLASS:   
;;;324        /* process class state machine */
;;;325        status = phost->class_cb->Machine(pdev, phost);
000120  6fe0              LDR      r0,[r4,#0x7c]
000122  4621              MOV      r1,r4
000124  68c2              LDR      r2,[r0,#0xc]
000126  4628              MOV      r0,r5
000128  4790              BLX      r2
00012a  9002              STR      r0,[sp,#8]
;;;326        USBH_ErrorHandle(phost, status);
00012c  f89d1008          LDRB     r1,[sp,#8]
000130  4620              MOV      r0,r4
000132  f7fffffe          BL       USBH_ErrorHandle
;;;327        break;       
000136  e02d              B        |L8.404|
;;;328        
;;;329      case HOST_CTRL_XFER:
;;;330        /* process control transfer state machine */
;;;331        USBH_HandleControl(pdev, phost);    
000138  4621              MOV      r1,r4
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       USBH_HandleControl
;;;332        break;
000140  e028              B        |L8.404|
;;;333        
;;;334      case HOST_SUSPENDED:
;;;335        break;
000142  e027              B        |L8.404|
;;;336      
;;;337      case HOST_ERROR_STATE:
;;;338        /* Re-Initilaize Host for new Enumeration */
;;;339        USBH_DeInit(pdev, phost);
000144  4621              MOV      r1,r4
000146  4628              MOV      r0,r5
000148  f7fffffe          BL       USBH_DeInit
;;;340        phost->usr_cb->DeInit();
00014c  f8d41080          LDR      r1,[r4,#0x80]
000150  6848              LDR      r0,[r1,#4]
000152  4780              BLX      r0
;;;341        phost->class_cb->DeInit(pdev, &phost->device_prop);
000154  6fe0              LDR      r0,[r4,#0x7c]
000156  f1040120          ADD      r1,r4,#0x20
00015a  6842              LDR      r2,[r0,#4]
00015c  4628              MOV      r0,r5
00015e  4790              BLX      r2
;;;342        break;
000160  e018              B        |L8.404|
;;;343        
;;;344      case HOST_DEV_DISCONNECTED :
;;;345        
;;;346        /* Manage User disconnect operations*/
;;;347        phost->usr_cb->DeviceDisconnected();
000162  f8d41080          LDR      r1,[r4,#0x80]
000166  6908              LDR      r0,[r1,#0x10]
000168  4780              BLX      r0
;;;348        
;;;349        /* Re-Initilaize Host for new Enumeration */
;;;350        USBH_DeInit(pdev, phost);
00016a  4621              MOV      r1,r4
00016c  4628              MOV      r0,r5
00016e  f7fffffe          BL       USBH_DeInit
;;;351        phost->usr_cb->DeInit();
000172  f8d41080          LDR      r1,[r4,#0x80]
000176  6848              LDR      r0,[r1,#4]
000178  4780              BLX      r0
;;;352        phost->class_cb->DeInit(pdev, &phost->device_prop); 
00017a  6fe0              LDR      r0,[r4,#0x7c]
00017c  f1040120          ADD      r1,r4,#0x20
000180  6842              LDR      r2,[r0,#4]
000182  4628              MOV      r0,r5
000184  4790              BLX      r2
;;;353        USBH_DeAllocate_AllChannel(pdev);  
000186  4628              MOV      r0,r5
000188  f7fffffe          BL       USBH_DeAllocate_AllChannel
;;;354        phost->gState = HOST_IDLE;
00018c  2000              MOVS     r0,#0
00018e  7020              STRB     r0,[r4,#0]
;;;355        
;;;356        break;
000190  e000              B        |L8.404|
                  |L8.402|
;;;357        
;;;358      default :
;;;359        break;
000192  bf00              NOP      
                  |L8.404|
000194  bf00              NOP                            ;243
;;;360      }
;;;361    
;;;362    }
000196  bd3e              POP      {r1-r5,pc}
;;;363    
                          ENDP


                          AREA ||i.USBH_SOF||, CODE, READONLY, ALIGN=1

                  USBH_SOF PROC
;;;143    
;;;144    uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;145    {
;;;146      /* This callback could be used to implement a scheduler process */
;;;147      return 0;  
000002  2000              MOVS     r0,#0
;;;148    }
000004  4770              BX       lr
;;;149    /**
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  USBH_HCD_INT_cb
                          DCD      USBH_SOF
                          DCD      USBH_Connected
                          DCD      USBH_Disconnected
                  USBH_HCD_INT_fops
                          DCD      USBH_HCD_INT_cb
                  timeout
000010  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_usbh_core_c_2210222f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usbh_core_c_2210222f____REVSH|
#line 144
|__asm___11_usbh_core_c_2210222f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
