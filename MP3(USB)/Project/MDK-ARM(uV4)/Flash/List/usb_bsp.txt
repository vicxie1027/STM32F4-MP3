; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_bsp.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_bsp.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usb_bsp.crf ..\..\User\usbh_mass_storage\usb_bsp.c]
                          THUMB

                          AREA ||i.BSP_Delay||, CODE, READONLY, ALIGN=2

                  BSP_Delay PROC
;;;505      */
;;;506    static void BSP_Delay(uint32_t nTime, uint8_t unit)
000000  b570              PUSH     {r4-r6,lr}
;;;507    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;508      
;;;509      BSP_delay = nTime;
000006  4808              LDR      r0,|L1.40|
000008  6005              STR      r5,[r0,#0]  ; BSP_delay
;;;510      BSP_SetTime(unit);  
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       BSP_SetTime
;;;511      while(BSP_delay != 0);
000010  bf00              NOP      
                  |L1.18|
000012  4805              LDR      r0,|L1.40|
000014  6800              LDR      r0,[r0,#0]  ; BSP_delay
000016  2800              CMP      r0,#0
000018  d1fb              BNE      |L1.18|
;;;512      TIM_Cmd(TIM2,DISABLE);
00001a  2100              MOVS     r1,#0
00001c  f04f4080          MOV      r0,#0x40000000
000020  f7fffffe          BL       TIM_Cmd
;;;513    }
000024  bd70              POP      {r4-r6,pc}
;;;514    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      BSP_delay

                          AREA ||i.BSP_SetTime||, CODE, READONLY, ALIGN=1

                  BSP_SetTime PROC
;;;520      */
;;;521    static void BSP_SetTime(uint8_t unit)
000000  b53e              PUSH     {r1-r5,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;524      
;;;525      TIM_Cmd(TIM2,DISABLE);
000004  2100              MOVS     r1,#0
000006  f04f4080          MOV      r0,#0x40000000
00000a  f7fffffe          BL       TIM_Cmd
;;;526      TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE); 
00000e  2200              MOVS     r2,#0
000010  2101              MOVS     r1,#1
000012  0788              LSLS     r0,r1,#30
000014  f7fffffe          BL       TIM_ITConfig
;;;527      
;;;528      
;;;529      if(unit == TIM_USEC_DELAY)
000018  2c02              CMP      r4,#2
00001a  d102              BNE      |L2.34|
;;;530      {  
;;;531        TIM_TimeBaseStructure.TIM_Period = 11;
00001c  200b              MOVS     r0,#0xb
00001e  9001              STR      r0,[sp,#4]
000020  e004              B        |L2.44|
                  |L2.34|
;;;532      }
;;;533      else if(unit == TIM_MSEC_DELAY)
000022  2c01              CMP      r4,#1
000024  d102              BNE      |L2.44|
;;;534      {
;;;535        TIM_TimeBaseStructure.TIM_Period = 11999;
000026  f64260df          MOV      r0,#0x2edf
00002a  9001              STR      r0,[sp,#4]
                  |L2.44|
;;;536      }
;;;537      TIM_TimeBaseStructure.TIM_Prescaler = 5;
00002c  2005              MOVS     r0,#5
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;538      TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000032  2000              MOVS     r0,#0
000034  f8ad0008          STRH     r0,[sp,#8]
;;;539      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
000038  f8ad0002          STRH     r0,[sp,#2]
;;;540      
;;;541      TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
00003c  4669              MOV      r1,sp
00003e  f04f4080          MOV      r0,#0x40000000
000042  f7fffffe          BL       TIM_TimeBaseInit
;;;542      TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
000046  2101              MOVS     r1,#1
000048  0788              LSLS     r0,r1,#30
00004a  f7fffffe          BL       TIM_ClearITPendingBit
;;;543      
;;;544      TIM_ARRPreloadConfig(TIM2, ENABLE);
00004e  2101              MOVS     r1,#1
000050  0788              LSLS     r0,r1,#30
000052  f7fffffe          BL       TIM_ARRPreloadConfig
;;;545      
;;;546      /* TIM IT enable */
;;;547      TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
000056  2201              MOVS     r2,#1
000058  4611              MOV      r1,r2
00005a  0790              LSLS     r0,r2,#30
00005c  f7fffffe          BL       TIM_ITConfig
;;;548      
;;;549      /* TIM2 enable counter */ 
;;;550      TIM_Cmd(TIM2, ENABLE);  
000060  2101              MOVS     r1,#1
000062  0788              LSLS     r0,r1,#30
000064  f7fffffe          BL       TIM_Cmd
;;;551    } 
000068  bd3e              POP      {r1-r5,pc}
;;;552    
                          ENDP


                          AREA ||i.USB_OTG_BSP_ConfigVBUS||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_ConfigVBUS PROC
;;;361    
;;;362    void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
000000  4770              BX       lr
;;;363    {
;;;364    #if 0	
;;;365    #ifndef USE_USB_OTG_HS 
;;;366      GPIO_InitTypeDef GPIO_InitStructure; 
;;;367      
;;;368    #ifdef USE_STM3210C_EVAL
;;;369      RCC_APB2PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
;;;370      
;;;371      
;;;372      /* Configure Power Switch Vbus Pin */
;;;373      GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
;;;374      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;375      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;376      GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
;;;377    #else
;;;378      #ifdef USE_USB_OTG_FS  
;;;379      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOH , ENABLE);  
;;;380      
;;;381      GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
;;;382      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;383      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;384      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;385      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;386      GPIO_Init(HOST_POWERSW_PORT,&GPIO_InitStructure);
;;;387      #endif  
;;;388    #endif
;;;389    
;;;390      /* By Default, DISABLE is needed on output of the Power Switch */
;;;391      GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
;;;392      
;;;393      USB_OTG_BSP_mDelay(200);   /* Delay is need for stabilising the Vbus Low 
;;;394      in Reset Condition, when Vbus=1 and Reset-button is pressed by user */
;;;395    #endif  
;;;396    #endif
;;;397    }
;;;398    
                          ENDP


                          AREA ||i.USB_OTG_BSP_DriveVBUS||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_DriveVBUS PROC
;;;323    
;;;324    void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  4770              BX       lr
;;;325    {
;;;326    #if 0	
;;;327      /*
;;;328      On-chip 5 V VBUS generation is not supported. For this reason, a charge pump 
;;;329      or, if 5 V are available on the application board, a basic power switch, must 
;;;330      be added externally to drive the 5 V VBUS line. The external charge pump can 
;;;331      be driven by any GPIO output. When the application decides to power on VBUS 
;;;332      using the chosen GPIO, it must also set the port power bit in the host port 
;;;333      control and status register (PPWR bit in OTG_FS_HPRT).
;;;334      
;;;335      Bit 12 PPWR: Port power
;;;336      The application uses this field to control power to this port, and the core 
;;;337      clears this bit on an overcurrent condition.
;;;338      */
;;;339      
;;;340    #ifndef USE_USB_OTG_HS   
;;;341      if (0 == state)
;;;342      { 
;;;343        /* DISABLE is needed on output of the Power Switch */
;;;344        GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
;;;345      }
;;;346      else
;;;347      {
;;;348        /*ENABLE the Power Switch by driving the Enable LOW */
;;;349        GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
;;;350      }
;;;351    #endif  
;;;352    #endif  
;;;353    }
;;;354    
                          ENDP


                          AREA ||i.USB_OTG_BSP_EnableInterrupt||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_EnableInterrupt PROC
;;;299      */
;;;300    void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;301    {
000002  4604              MOV      r4,r0
;;;302      NVIC_InitTypeDef NVIC_InitStructure; 
;;;303      
;;;304      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000004  f44f60c0          MOV      r0,#0x600
000008  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;305    #ifdef USE_USB_OTG_HS   
;;;306      NVIC_InitStructure.NVIC_IRQChannel = OTG_HS_IRQn;
00000c  204d              MOVS     r0,#0x4d
00000e  f88d0000          STRB     r0,[sp,#0]
;;;307    #else
;;;308      NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;  
;;;309    #endif
;;;310      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000012  2001              MOVS     r0,#1
000014  f88d0001          STRB     r0,[sp,#1]
;;;311      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;312      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001e  2001              MOVS     r0,#1
000020  f88d0003          STRB     r0,[sp,#3]
;;;313      NVIC_Init(&NVIC_InitStructure);  
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       NVIC_Init
;;;314    
;;;315    }
00002a  bd38              POP      {r3-r5,pc}
;;;316    
                          ENDP


                          AREA ||i.USB_OTG_BSP_Init||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_Init PROC
;;;131    
;;;132    void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
000000  b51c              PUSH     {r2-r4,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134    
;;;135    // EXTI_InitTypeDef EXTI_InitStructure;
;;;136     #ifdef USE_STM3210C_EVAL
;;;137    
;;;138      RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLLVCO_Div3);
;;;139      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_OTG_FS, ENABLE) ;
;;;140    
;;;141    #else // USE_STM322xG_EVAL  
;;;142      GPIO_InitTypeDef GPIO_InitStructure;
;;;143     #ifdef USE_USB_OTG_FS 
;;;144    
;;;145      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
;;;146      
;;;147      /* Configure SOF VBUS ID DM DP Pins */
;;;148      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8  | GPIO_Pin_11 | GPIO_Pin_12;  
;;;149      
;;;150      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;151      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;152      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;153      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;154      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;155      
;;;156      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
;;;157      
;;;158      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;159      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;160      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;161      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;162      GPIO_Init(GPIOA, &GPIO_InitStructure);    
;;;163      
;;;164      GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
;;;165      GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
;;;166      GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
;;;167      
;;;168      /* this for ID line debug */  
;;;169      
;;;170      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
;;;171      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;172      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
;;;173      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;174      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;175      GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
;;;176    
;;;177    
;;;178      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;179      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
;;;180     #else // USE_USB_OTG_HS 
;;;181    
;;;182      #ifdef USE_ULPI_PHY // ULPI
;;;183      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | 
;;;184                             RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOH | 
;;;185                               RCC_AHB1Periph_GPIOI, ENABLE);    
;;;186      
;;;187      
;;;188      GPIO_PinAFConfig(GPIOA,GPIO_PinSource3, GPIO_AF_OTG2_HS) ; // D0
;;;189      GPIO_PinAFConfig(GPIOA,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // CLK
;;;190      GPIO_PinAFConfig(GPIOB,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // D1
;;;191      GPIO_PinAFConfig(GPIOB,GPIO_PinSource1, GPIO_AF_OTG2_HS) ; // D2
;;;192      GPIO_PinAFConfig(GPIOB,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // D7
;;;193      GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_OTG2_HS) ; // D3
;;;194      GPIO_PinAFConfig(GPIOB,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // D4
;;;195      GPIO_PinAFConfig(GPIOB,GPIO_PinSource12,GPIO_AF_OTG2_HS) ; // D5
;;;196      GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_HS) ; // D6
;;;197      GPIO_PinAFConfig(GPIOH,GPIO_PinSource4, GPIO_AF_OTG2_HS) ; // NXT
;;;198      GPIO_PinAFConfig(GPIOI,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // DIR
;;;199      GPIO_PinAFConfig(GPIOC,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // STP
;;;200      
;;;201      // CLK
;;;202      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 ; 
;;;203      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;204      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;205      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;206      
;;;207      // D0
;;;208      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3  ; 
;;;209      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;210      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;211      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;212      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;213      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;214      
;;;215      
;;;216      
;;;217      // D1 D2 D3 D4 D5 D6 D7
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1  |
;;;219        GPIO_Pin_5 | GPIO_Pin_10 | 
;;;220          GPIO_Pin_11| GPIO_Pin_12 | 
;;;221            GPIO_Pin_13 ;
;;;222      
;;;223      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;224      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;225      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;226      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;227      GPIO_Init(GPIOB, &GPIO_InitStructure);  
;;;228      
;;;229      
;;;230      // STP
;;;231      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  ;
;;;232      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;233      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;234      GPIO_Init(GPIOC, &GPIO_InitStructure);  
;;;235      
;;;236      //NXT  
;;;237      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
;;;238      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;239      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;240      GPIO_Init(GPIOH, &GPIO_InitStructure);  
;;;241      
;;;242      
;;;243      //DIR
;;;244      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 ; 
;;;245      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;246      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;247      GPIO_Init(GPIOI, &GPIO_InitStructure);  
;;;248      
;;;249      
;;;250      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS | 
;;;251                             RCC_AHB1Periph_OTG_HS_ULPI, ENABLE) ;    
;;;252       
;;;253      #else
;;;254    
;;;255    	#if 1
;;;256    
;;;257    	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;258    	  
;;;259    	  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14 | GPIO_Pin_15;
00000c  f44f4040          MOV      r0,#0xc000
000010  9000              STR      r0,[sp,#0]
;;;260    	  
;;;261    	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000012  2003              MOVS     r0,#3
000014  f88d0005          STRB     r0,[sp,#5]
;;;262    	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000018  2002              MOVS     r0,#2
00001a  f88d0004          STRB     r0,[sp,#4]
;;;263    	  GPIO_Init(GPIOB, &GPIO_InitStructure);  
00001e  4669              MOV      r1,sp
000020  4809              LDR      r0,|L6.72|
000022  f7fffffe          BL       GPIO_Init
;;;264    	  
;;;265    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_OTG2_FS) ; 
000026  220c              MOVS     r2,#0xc
000028  210e              MOVS     r1,#0xe
00002a  4807              LDR      r0,|L6.72|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;266    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_OTG2_FS) ;
000030  220c              MOVS     r2,#0xc
000032  210f              MOVS     r1,#0xf
000034  4804              LDR      r0,|L6.72|
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;267    	  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  
00003a  2101              MOVS     r1,#1
00003c  0748              LSLS     r0,r1,#29
00003e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;268    	#else
;;;269    	  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
;;;270    	  
;;;271    	  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12  | 
;;;272    		GPIO_Pin_13 |
;;;273    		  GPIO_Pin_14 | 
;;;274    			GPIO_Pin_15;
;;;275    	  
;;;276    	  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;277    	  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;278    	  GPIO_Init(GPIOB, &GPIO_InitStructure);  
;;;279    	  
;;;280    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource12, GPIO_AF_OTG2_FS) ; 
;;;281    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_FS) ; 
;;;282    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_OTG2_FS) ; 
;;;283    	  GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_OTG2_FS) ;
;;;284    	  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  	
;;;285    	#endif
;;;286     
;;;287      #endif
;;;288     #endif //USB_OTG_HS
;;;289    #endif //USE_STM322xG_EVAL
;;;290    
;;;291      /* Intialize Timer for delay function */
;;;292      USB_OTG_BSP_TimeInit();   
000042  f7fffffe          BL       USB_OTG_BSP_TimeInit
;;;293    }
000046  bd1c              POP      {r2-r4,pc}
;;;294    /**
                          ENDP

                  |L6.72|
                          DCD      0x40020400

                          AREA ||i.USB_OTG_BSP_TimeInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_TimeInit PROC
;;;404      */
;;;405    static void USB_OTG_BSP_TimeInit ( void )
000000  b508              PUSH     {r3,lr}
;;;406    {
;;;407    #ifdef USE_ACCURATE_TIME   
;;;408      NVIC_InitTypeDef NVIC_InitStructure;
;;;409      
;;;410      /* Set the Vector Table base address at 0x08000000 */
;;;411      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x00);
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;412      
;;;413      /* Configure the Priority Group to 2 bits */
;;;414      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;415      
;;;416      /* Enable the TIM2 gloabal Interrupt */
;;;417      NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
000014  201c              MOVS     r0,#0x1c
000016  f88d0000          STRB     r0,[sp,#0]
;;;418      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00001a  2001              MOVS     r0,#1
00001c  f88d0001          STRB     r0,[sp,#1]
;;;419      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000020  f88d0002          STRB     r0,[sp,#2]
;;;420      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  f88d0003          STRB     r0,[sp,#3]
;;;421      
;;;422      NVIC_Init(&NVIC_InitStructure);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       NVIC_Init
;;;423      
;;;424      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);  
00002e  2101              MOVS     r1,#1
000030  4608              MOV      r0,r1
000032  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;425    #endif  
;;;426    }
000036  bd08              POP      {r3,pc}
;;;427    
                          ENDP


                          AREA ||i.USB_OTG_BSP_TimerIRQ||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_TimerIRQ PROC
;;;478    
;;;479    void USB_OTG_BSP_TimerIRQ (void)
000000  b510              PUSH     {r4,lr}
;;;480    {
;;;481    #ifdef USE_ACCURATE_TIME 
;;;482        
;;;483      if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b188              CBZ      r0,|L8.48|
;;;484      {
;;;485        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
00000c  2101              MOVS     r1,#1
00000e  0788              LSLS     r0,r1,#30
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;486        if (BSP_delay > 0x00)
000014  4807              LDR      r0,|L8.52|
000016  6800              LDR      r0,[r0,#0]  ; BSP_delay
000018  b128              CBZ      r0,|L8.38|
;;;487        { 
;;;488          BSP_delay--;
00001a  4806              LDR      r0,|L8.52|
00001c  6800              LDR      r0,[r0,#0]  ; BSP_delay
00001e  1e40              SUBS     r0,r0,#1
000020  4904              LDR      r1,|L8.52|
000022  6008              STR      r0,[r1,#0]  ; BSP_delay
000024  e004              B        |L8.48|
                  |L8.38|
;;;489        }
;;;490        else
;;;491        {
;;;492          TIM_Cmd(TIM2,DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f4080          MOV      r0,#0x40000000
00002c  f7fffffe          BL       TIM_Cmd
                  |L8.48|
;;;493        }
;;;494      }
;;;495    #endif  
;;;496    } 
000030  bd10              POP      {r4,pc}
;;;497    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      BSP_delay

                          AREA ||i.USB_OTG_BSP_mDelay||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_mDelay PROC
;;;460      */
;;;461    void USB_OTG_BSP_mDelay (const uint32_t msec)
000000  b510              PUSH     {r4,lr}
;;;462    { 
000002  4604              MOV      r4,r0
;;;463    #ifdef USE_ACCURATE_TIME  
;;;464        BSP_Delay(msec,TIM_MSEC_DELAY);   
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       BSP_Delay
;;;465    #else
;;;466        USB_OTG_BSP_uDelay(msec * 1000);   
;;;467    #endif    
;;;468    
;;;469    }
00000c  bd10              POP      {r4,pc}
;;;470    
                          ENDP


                          AREA ||i.USB_OTG_BSP_uDelay||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_uDelay PROC
;;;433      */
;;;434    void USB_OTG_BSP_uDelay (const uint32_t usec)
000000  b510              PUSH     {r4,lr}
;;;435    {
000002  4604              MOV      r4,r0
;;;436      
;;;437    #ifdef USE_ACCURATE_TIME    
;;;438      BSP_Delay(usec,TIM_USEC_DELAY); 
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       BSP_Delay
;;;439    #else
;;;440      __IO uint32_t count = 0;
;;;441      const uint32_t utime = (120 * usec / 7);
;;;442      do
;;;443      {
;;;444        if ( ++count > utime )
;;;445        {
;;;446          return ;
;;;447        }
;;;448      }
;;;449      while (1);
;;;450    #endif   
;;;451      
;;;452    }
00000c  bd10              POP      {r4,pc}
;;;453    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  HSEStartUpStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  BSP_delay
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\usbh_mass_storage\\usb_bsp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_bsp_c_6771ef19____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_bsp_c_6771ef19____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_bsp_c_6771ef19____REVSH|
#line 144
|__asm___9_usb_bsp_c_6771ef19____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
