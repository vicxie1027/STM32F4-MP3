; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\bsp_usart.crf ..\..\User\bsp_stm32f4xx\src\bsp_usart.c]
                          THUMB

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;217    */
;;;218    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;219    {
;;;220    	NVIC_InitTypeDef NVIC_InitStructure;
;;;221    
;;;222    #if USART1_EN == 1
;;;223    	/* 使能串口1中断 */
;;;224    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;225    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
;;;226    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;227    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;228    	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;229    	
;;;230    	NVIC_InitStructure.NVIC_IRQChannel =  DMA2_Stream7_IRQn;   				// 指定IRQ通道
000020  2046              MOVS     r0,#0x46
000022  f88d0000          STRB     r0,[sp,#0]
;;;231    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;   			// 先占优先级0级
000026  2001              MOVS     r0,#1
000028  f88d0001          STRB     r0,[sp,#1]
;;;232    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;          			// 从优先级0级
00002c  2003              MOVS     r0,#3
00002e  f88d0002          STRB     r0,[sp,#2]
;;;233    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             			// IRQ通道被使能
000032  2001              MOVS     r0,#1
000034  f88d0003          STRB     r0,[sp,#3]
;;;234    	NVIC_Init(&NVIC_InitStructure);                             			// 根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;235    #endif
;;;236    	
;;;237    #if USART3_EN == 1
;;;238    	/* 使能串口1中断 */
;;;239    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00003e  2027              MOVS     r0,#0x27
000040  f88d0000          STRB     r0,[sp,#0]
;;;240    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000044  2000              MOVS     r0,#0
000046  f88d0001          STRB     r0,[sp,#1]
;;;241    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
00004a  2002              MOVS     r0,#2
00004c  f88d0002          STRB     r0,[sp,#2]
;;;242    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d0003          STRB     r0,[sp,#3]
;;;243    	NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;244    	
;;;245    	NVIC_InitStructure.NVIC_IRQChannel =  DMA1_Stream3_IRQn;   				// 指定IRQ通道
00005c  200e              MOVS     r0,#0xe
00005e  f88d0000          STRB     r0,[sp,#0]
;;;246    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;   			// 先占优先级0级
000062  2001              MOVS     r0,#1
000064  f88d0001          STRB     r0,[sp,#1]
;;;247    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;          			// 从优先级0级
000068  2003              MOVS     r0,#3
00006a  f88d0002          STRB     r0,[sp,#2]
;;;248    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             			// IRQ通道被使能
00006e  2001              MOVS     r0,#1
000070  f88d0003          STRB     r0,[sp,#3]
;;;249    	NVIC_Init(&NVIC_InitStructure);                             			// 根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000074  4668              MOV      r0,sp
000076  f7fffffe          BL       NVIC_Init
;;;250    #endif
;;;251    }
00007a  bd08              POP      {r3,pc}
;;;252    
                          ENDP


                          AREA ||i.DMA1_Stream3_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream3_IRQHandler PROC
;;;406    */
;;;407    void DMA1_Stream3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;408    {
;;;409    	if(DMA_GetITStatus(DMA1_Stream3,DMA_IT_TCIF3)!= RESET)
000002  490a              LDR      r1,|L2.44|
000004  480a              LDR      r0,|L2.48|
000006  f7fffffe          BL       DMA_GetITStatus
00000a  b168              CBZ      r0,|L2.40|
;;;410    	{
;;;411    		DMA_ClearITPendingBit(DMA1_Stream3,DMA_IT_TCIF3);                           //	清除中断标志位
00000c  4907              LDR      r1,|L2.44|
00000e  4808              LDR      r0,|L2.48|
000010  f7fffffe          BL       DMA_ClearITPendingBit
;;;412    		DMA_Cmd(DMA1_Stream3, DISABLE);	                                       			// 	关闭DMA
000014  2100              MOVS     r1,#0
000016  4806              LDR      r0,|L2.48|
000018  f7fffffe          BL       DMA_Cmd
;;;413    		USART_ITConfig(USART3, USART_IT_TC, ENABLE);	 															//	使能USART发送完成中断，发送完成最后两个字节。					
00001c  2201              MOVS     r2,#1
00001e  f2406126          MOV      r1,#0x626
000022  4804              LDR      r0,|L2.52|
000024  f7fffffe          BL       USART_ITConfig
                  |L2.40|
;;;414    	}	
;;;415    }
000028  bd10              POP      {r4,pc}
;;;416    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x18008000
                  |L2.48|
                          DCD      0x40026058
                  |L2.52|
                          DCD      0x40004800

                          AREA ||i.DMA2_Stream7_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA2_Stream7_IRQHandler PROC
;;;389    */
;;;390    void DMA2_Stream7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;391    {
;;;392    	if(DMA_GetITStatus(DMA2_Stream7,DMA_IT_TCIF7)!= RESET)
000002  490a              LDR      r1,|L3.44|
000004  480a              LDR      r0,|L3.48|
000006  f7fffffe          BL       DMA_GetITStatus
00000a  b168              CBZ      r0,|L3.40|
;;;393    	{
;;;394    		DMA_ClearITPendingBit(DMA2_Stream7,DMA_IT_TCIF7);                           //	清除中断标志位
00000c  4907              LDR      r1,|L3.44|
00000e  4808              LDR      r0,|L3.48|
000010  f7fffffe          BL       DMA_ClearITPendingBit
;;;395    		DMA_Cmd(DMA2_Stream7, DISABLE);	                                       			// 	关闭DMA
000014  2100              MOVS     r1,#0
000016  4806              LDR      r0,|L3.48|
000018  f7fffffe          BL       DMA_Cmd
;;;396    		USART_ITConfig(USART1, USART_IT_TC, ENABLE);	 															//	使能USART发送完成中断，发送完成最后两个字节。					
00001c  2201              MOVS     r2,#1
00001e  f2406126          MOV      r1,#0x626
000022  4804              LDR      r0,|L3.52|
000024  f7fffffe          BL       USART_ITConfig
                  |L3.40|
;;;397    	}	
;;;398    }
000028  bd10              POP      {r4,pc}
;;;399    /*
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x28008000
                  |L3.48|
                          DCD      0x400264b8
                  |L3.52|
                          DCD      0x40011000

                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;105    */
;;;106    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;107    {
000002  b087              SUB      sp,sp,#0x1c
;;;108    	GPIO_InitTypeDef GPIO_InitStructure;
;;;109    	USART_InitTypeDef USART_InitStructure;
;;;110    //	DMA_InitTypeDef DMA_InitStructure;
;;;111    
;;;112    #if USART1_EN == 1		
;;;113    	/*打开 DMA　时钟*/
;;;114    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
000004  2101              MOVS     r1,#1
000006  0588              LSLS     r0,r1,#22
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;115    	
;;;116    	/* 打开 GPIO 时钟 */
;;;117    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;118    
;;;119    	/* 打开 UART 时钟 */
;;;120    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000014  2101              MOVS     r1,#1
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121    
;;;122    	/* 将 PA9 映射为 USART1_TX */
;;;123    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
00001c  2207              MOVS     r2,#7
00001e  2109              MOVS     r1,#9
000020  4854              LDR      r0,|L4.372|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;124    
;;;125    	/* 将 PA10 映射为 USART1_RX */
;;;126    	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
000026  2207              MOVS     r2,#7
000028  210a              MOVS     r1,#0xa
00002a  4852              LDR      r0,|L4.372|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;127    
;;;128    	/* 配置 USART Tx 为复用功能 */
;;;129    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000030  2000              MOVS     r0,#0
000032  f88d001a          STRB     r0,[sp,#0x1a]
;;;130    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
000036  2001              MOVS     r0,#1
000038  f88d001b          STRB     r0,[sp,#0x1b]
;;;131    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
00003c  2002              MOVS     r0,#2
00003e  f88d0018          STRB     r0,[sp,#0x18]
;;;132    
;;;133    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000042  0200              LSLS     r0,r0,#8
000044  9005              STR      r0,[sp,#0x14]
;;;134    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000046  2002              MOVS     r0,#2
000048  f88d0019          STRB     r0,[sp,#0x19]
;;;135    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00004c  a905              ADD      r1,sp,#0x14
00004e  4849              LDR      r0,|L4.372|
000050  f7fffffe          BL       GPIO_Init
;;;136    
;;;137    	/* 配置 USART Rx 为复用功能 */
;;;138    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000054  2002              MOVS     r0,#2
000056  f88d0018          STRB     r0,[sp,#0x18]
;;;139    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00005a  0240              LSLS     r0,r0,#9
00005c  9005              STR      r0,[sp,#0x14]
;;;140    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00005e  a905              ADD      r1,sp,#0x14
000060  4844              LDR      r0,|L4.372|
000062  f7fffffe          BL       GPIO_Init
;;;141    
;;;142    	/* 第2步： 配置串口硬件参数 */
;;;143    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000066  f44f30e1          MOV      r0,#0x1c200
00006a  9001              STR      r0,[sp,#4]
;;;144    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00006c  2000              MOVS     r0,#0
00006e  f8ad0008          STRH     r0,[sp,#8]
;;;145    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000072  f8ad000a          STRH     r0,[sp,#0xa]
;;;146    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000076  f8ad000c          STRH     r0,[sp,#0xc]
;;;147    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00007a  f8ad0010          STRH     r0,[sp,#0x10]
;;;148    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00007e  200c              MOVS     r0,#0xc
000080  f8ad000e          STRH     r0,[sp,#0xe]
;;;149    	USART_Init(USART1, &USART_InitStructure);
000084  a901              ADD      r1,sp,#4
000086  483c              LDR      r0,|L4.376|
000088  f7fffffe          BL       USART_Init
;;;150    
;;;151    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00008c  2201              MOVS     r2,#1
00008e  f2405125          MOV      r1,#0x525
000092  4839              LDR      r0,|L4.376|
000094  f7fffffe          BL       USART_ITConfig
;;;152    
;;;153    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000098  2101              MOVS     r1,#1
00009a  4837              LDR      r0,|L4.376|
00009c  f7fffffe          BL       USART_Cmd
;;;154    
;;;155    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0000a0  2140              MOVS     r1,#0x40
0000a2  4835              LDR      r0,|L4.376|
0000a4  f7fffffe          BL       USART_ClearFlag
;;;156    	
;;;157    	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);															// Enable USART1 DMA TX request	 												UART1使用DMA请求						 
0000a8  2201              MOVS     r2,#1
0000aa  2180              MOVS     r1,#0x80
0000ac  4832              LDR      r0,|L4.376|
0000ae  f7fffffe          BL       USART_DMACmd
;;;158      DMA_Cmd(DMA2_Stream7, ENABLE);                                              // Enable DMA2 Channel7 全能DMA2 7通道
0000b2  2101              MOVS     r1,#1
0000b4  4831              LDR      r0,|L4.380|
0000b6  f7fffffe          BL       DMA_Cmd
;;;159    	
;;;160    #endif
;;;161    
;;;162    #if USART3_EN == 1
;;;163    	/*打开 DMA　时钟*/
;;;164    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
0000ba  2101              MOVS     r1,#1
0000bc  0548              LSLS     r0,r1,#21
0000be  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;165    	/* 打开 GPIO 时钟 */
;;;166    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
0000c2  2101              MOVS     r1,#1
0000c4  2002              MOVS     r0,#2
0000c6  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;167    
;;;168    	/* 打开 UART 时钟 */
;;;169    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
0000ca  2101              MOVS     r1,#1
0000cc  0488              LSLS     r0,r1,#18
0000ce  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;170    
;;;171    	/* 将 PB10 映射为 USART3_TX */
;;;172    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_USART3);
0000d2  2207              MOVS     r2,#7
0000d4  210a              MOVS     r1,#0xa
0000d6  482a              LDR      r0,|L4.384|
0000d8  f7fffffe          BL       GPIO_PinAFConfig
;;;173    
;;;174    	/* 将 PB11 映射为 USART3_RX */
;;;175    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_USART3);
0000dc  2207              MOVS     r2,#7
0000de  210b              MOVS     r1,#0xb
0000e0  4827              LDR      r0,|L4.384|
0000e2  f7fffffe          BL       GPIO_PinAFConfig
;;;176    
;;;177    	/* 配置 USART Tx 为复用功能 */
;;;178    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
0000e6  2000              MOVS     r0,#0
0000e8  f88d001a          STRB     r0,[sp,#0x1a]
;;;179    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
0000ec  2001              MOVS     r0,#1
0000ee  f88d001b          STRB     r0,[sp,#0x1b]
;;;180    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
0000f2  2002              MOVS     r0,#2
0000f4  f88d0018          STRB     r0,[sp,#0x18]
;;;181    
;;;182    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
0000f8  0240              LSLS     r0,r0,#9
0000fa  9005              STR      r0,[sp,#0x14]
;;;183    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000fc  2002              MOVS     r0,#2
0000fe  f88d0019          STRB     r0,[sp,#0x19]
;;;184    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000102  a905              ADD      r1,sp,#0x14
000104  481e              LDR      r0,|L4.384|
000106  f7fffffe          BL       GPIO_Init
;;;185    
;;;186    	/* 配置 USART Rx 为复用功能 */
;;;187    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00010a  2002              MOVS     r0,#2
00010c  f88d0018          STRB     r0,[sp,#0x18]
;;;188    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000110  0280              LSLS     r0,r0,#10
000112  9005              STR      r0,[sp,#0x14]
;;;189    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000114  a905              ADD      r1,sp,#0x14
000116  481a              LDR      r0,|L4.384|
000118  f7fffffe          BL       GPIO_Init
;;;190    
;;;191    	/* 第2步： 配置串口硬件参数 */
;;;192    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
00011c  f44f30e1          MOV      r0,#0x1c200
000120  9001              STR      r0,[sp,#4]
;;;193    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000122  2000              MOVS     r0,#0
000124  f8ad0008          STRH     r0,[sp,#8]
;;;194    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000128  f8ad000a          STRH     r0,[sp,#0xa]
;;;195    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00012c  f8ad000c          STRH     r0,[sp,#0xc]
;;;196    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000130  f8ad0010          STRH     r0,[sp,#0x10]
;;;197    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000134  200c              MOVS     r0,#0xc
000136  f8ad000e          STRH     r0,[sp,#0xe]
;;;198    	USART_Init(USART3, &USART_InitStructure);
00013a  a901              ADD      r1,sp,#4
00013c  4811              LDR      r0,|L4.388|
00013e  f7fffffe          BL       USART_Init
;;;199    
;;;200    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000142  2201              MOVS     r2,#1
000144  f2405125          MOV      r1,#0x525
000148  480e              LDR      r0,|L4.388|
00014a  f7fffffe          BL       USART_ITConfig
;;;201    
;;;202    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
00014e  2101              MOVS     r1,#1
000150  480c              LDR      r0,|L4.388|
000152  f7fffffe          BL       USART_Cmd
;;;203    
;;;204    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000156  2140              MOVS     r1,#0x40
000158  480a              LDR      r0,|L4.388|
00015a  f7fffffe          BL       USART_ClearFlag
;;;205    	
;;;206    	USART_DMACmd(USART3, USART_DMAReq_Tx, ENABLE);															// Enable USART1 DMA TX request	 												UART1使用DMA请求						 
00015e  2201              MOVS     r2,#1
000160  2180              MOVS     r1,#0x80
000162  4808              LDR      r0,|L4.388|
000164  f7fffffe          BL       USART_DMACmd
;;;207      DMA_Cmd(DMA1_Stream3, ENABLE);                                              // Enable DMA2 Channel7 全能DMA2 7通道
000168  2101              MOVS     r1,#1
00016a  4807              LDR      r0,|L4.392|
00016c  f7fffffe          BL       DMA_Cmd
;;;208    #endif
;;;209    }
000170  b007              ADD      sp,sp,#0x1c
000172  bd00              POP      {pc}
;;;210    /*
                          ENDP

                  |L4.372|
                          DCD      0x40020000
                  |L4.376|
                          DCD      0x40011000
                  |L4.380|
                          DCD      0x400264b8
                  |L4.384|
                          DCD      0x40020400
                  |L4.388|
                          DCD      0x40004800
                  |L4.392|
                          DCD      0x40026058

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;480    */
;;;481    void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;482    {
;;;483    	if(TIM_GetITStatus(TIM7,TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  4811              LDR      r0,|L5.76|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1e8              CBZ      r0,|L5.72|
;;;484    	{
;;;485    		TIM_ClearITPendingBit(TIM7,TIM_IT_Update);
00000c  2101              MOVS     r1,#1
00000e  480f              LDR      r0,|L5.76|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;486    
;;;487    #if USART1_EN == 1
;;;488    		if(g_tUsart1.ucCnt > 0)							   			 		                         
000014  480e              LDR      r0,|L5.80|
000016  6940              LDR      r0,[r0,#0x14]  ; g_tUsart1
000018  b148              CBZ      r0,|L5.46|
;;;489    		{
;;;490    			g_tUsart1.ucCnt-- ;							   			   		                       
00001a  480d              LDR      r0,|L5.80|
00001c  6940              LDR      r0,[r0,#0x14]  ; g_tUsart1
00001e  1e40              SUBS     r0,r0,#1
000020  490b              LDR      r1,|L5.80|
000022  6148              STR      r0,[r1,#0x14]  ; g_tUsart1
;;;491    			if(g_tUsart1.ucCnt == 0)						   		   			                      
000024  4608              MOV      r0,r1
000026  6940              LDR      r0,[r0,#0x14]  ; g_tUsart1
000028  b908              CBNZ     r0,|L5.46|
;;;492    			{
;;;493    				g_tUsart1.ucRxFinish = 1;                               	          
00002a  2001              MOVS     r0,#1
00002c  7448              STRB     r0,[r1,#0x11]
                  |L5.46|
;;;494    			}
;;;495    		}		
;;;496    #endif
;;;497    		
;;;498    #if USART3_EN == 1
;;;499    		if(g_tUsart3.ucCnt > 0)							   			 		                         
00002e  4809              LDR      r0,|L5.84|
000030  6940              LDR      r0,[r0,#0x14]  ; g_tUsart3
000032  b148              CBZ      r0,|L5.72|
;;;500    		{
;;;501    			g_tUsart3.ucCnt-- ;							   			   		                       
000034  4807              LDR      r0,|L5.84|
000036  6940              LDR      r0,[r0,#0x14]  ; g_tUsart3
000038  1e40              SUBS     r0,r0,#1
00003a  4906              LDR      r1,|L5.84|
00003c  6148              STR      r0,[r1,#0x14]  ; g_tUsart3
;;;502    			if(g_tUsart3.ucCnt == 0)						   		   			                      
00003e  4608              MOV      r0,r1
000040  6940              LDR      r0,[r0,#0x14]  ; g_tUsart3
000042  b908              CBNZ     r0,|L5.72|
;;;503    			{
;;;504    				g_tUsart3.ucRxFinish = 1;                               	          
000044  2001              MOVS     r0,#1
000046  7448              STRB     r0,[r1,#0x11]
                  |L5.72|
;;;505    			}
;;;506    		}		
;;;507    #endif
;;;508    	}
;;;509    }
000048  bd10              POP      {r4,pc}
;;;510    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      0x40001400
                  |L5.80|
                          DCD      g_tUsart1
                  |L5.84|
                          DCD      g_tUsart3

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;425    #if USART1_EN == 1
;;;426    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428    	if(USART_GetITStatus(USART1,USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4814              LDR      r0,|L6.88|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1a0              CBZ      r0,|L6.56|
;;;429    	{  				
;;;430    		if(g_tUsart1.usRxCount < g_tUsart1.usRxSize)
00000e  4813              LDR      r0,|L6.92|
000010  89c0              LDRH     r0,[r0,#0xe]  ; g_tUsart1
000012  4912              LDR      r1,|L6.92|
000014  8949              LDRH     r1,[r1,#0xa]  ; g_tUsart1
000016  4288              CMP      r0,r1
000018  da0e              BGE      |L6.56|
;;;431    		{
;;;432    			g_tUsart1.pRxBuf[g_tUsart1.usRxCount] = USART_ReceiveData(USART1) ;									 	
00001a  480f              LDR      r0,|L6.88|
00001c  f7fffffe          BL       USART_ReceiveData
000020  490e              LDR      r1,|L6.92|
000022  6849              LDR      r1,[r1,#4]  ; g_tUsart1
000024  4a0d              LDR      r2,|L6.92|
000026  89d2              LDRH     r2,[r2,#0xe]  ; g_tUsart1
000028  5488              STRB     r0,[r1,r2]
;;;433    			g_tUsart1.usRxCount++ ;	                                                          
00002a  480c              LDR      r0,|L6.92|
00002c  89c0              LDRH     r0,[r0,#0xe]  ; g_tUsart1
00002e  1c40              ADDS     r0,r0,#1
000030  490a              LDR      r1,|L6.92|
000032  81c8              STRH     r0,[r1,#0xe]
;;;434    			g_tUsart1.ucCnt = ((1000000 / (UART1_BAUD / (8+2))) / CYCLE_TIME) * 3 ;
000034  2018              MOVS     r0,#0x18
000036  6148              STR      r0,[r1,#0x14]  ; g_tUsart1
                  |L6.56|
;;;435    		}
;;;436    	}
;;;437    	
;;;438    	if(USART_GetITStatus(USART1,USART_IT_TC) != RESET)
000038  f2406126          MOV      r1,#0x626
00003c  4806              LDR      r0,|L6.88|
00003e  f7fffffe          BL       USART_GetITStatus
000042  b140              CBZ      r0,|L6.86|
;;;439    	{
;;;440    		USART_ITConfig(USART1, USART_IT_TC, DISABLE);	 														
000044  2200              MOVS     r2,#0
000046  f2406126          MOV      r1,#0x626
00004a  4803              LDR      r0,|L6.88|
00004c  f7fffffe          BL       USART_ITConfig
;;;441    		g_tUsart1.ucTxFinish = 1 ;
000050  2001              MOVS     r0,#1
000052  4902              LDR      r1,|L6.92|
000054  7408              STRB     r0,[r1,#0x10]
                  |L6.86|
;;;442    	}
;;;443    }
000056  bd10              POP      {r4,pc}
;;;444    #endif
                          ENDP

                  |L6.88|
                          DCD      0x40011000
                  |L6.92|
                          DCD      g_tUsart1

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;453    #if USART3_EN == 1
;;;454    void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;455    {
;;;456    	if(USART_GetITStatus(USART3,USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4814              LDR      r0,|L7.88|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1a0              CBZ      r0,|L7.56|
;;;457    	{  				
;;;458    		if(g_tUsart3.usRxCount < g_tUsart3.usRxSize)
00000e  4813              LDR      r0,|L7.92|
000010  89c0              LDRH     r0,[r0,#0xe]  ; g_tUsart3
000012  4912              LDR      r1,|L7.92|
000014  8949              LDRH     r1,[r1,#0xa]  ; g_tUsart3
000016  4288              CMP      r0,r1
000018  da0e              BGE      |L7.56|
;;;459    		{
;;;460    			g_tUsart3.pRxBuf[g_tUsart3.usRxCount] = USART_ReceiveData(USART3) ;									 	
00001a  480f              LDR      r0,|L7.88|
00001c  f7fffffe          BL       USART_ReceiveData
000020  490e              LDR      r1,|L7.92|
000022  6849              LDR      r1,[r1,#4]  ; g_tUsart3
000024  4a0d              LDR      r2,|L7.92|
000026  89d2              LDRH     r2,[r2,#0xe]  ; g_tUsart3
000028  5488              STRB     r0,[r1,r2]
;;;461    			g_tUsart3.usRxCount++ ;	                                                          
00002a  480c              LDR      r0,|L7.92|
00002c  89c0              LDRH     r0,[r0,#0xe]  ; g_tUsart3
00002e  1c40              ADDS     r0,r0,#1
000030  490a              LDR      r1,|L7.92|
000032  81c8              STRH     r0,[r1,#0xe]
;;;462    			g_tUsart3.ucCnt = ((1000000 / (UART3_BAUD / (8+2))) / CYCLE_TIME) * 3 ;
000034  2018              MOVS     r0,#0x18
000036  6148              STR      r0,[r1,#0x14]  ; g_tUsart3
                  |L7.56|
;;;463    		}
;;;464    	}
;;;465    	
;;;466    	if(USART_GetITStatus(USART3,USART_IT_TC) != RESET)
000038  f2406126          MOV      r1,#0x626
00003c  4806              LDR      r0,|L7.88|
00003e  f7fffffe          BL       USART_GetITStatus
000042  b140              CBZ      r0,|L7.86|
;;;467    	{
;;;468    		USART_ITConfig(USART3, USART_IT_TC, DISABLE);	 														
000044  2200              MOVS     r2,#0
000046  f2406126          MOV      r1,#0x626
00004a  4803              LDR      r0,|L7.88|
00004c  f7fffffe          BL       USART_ITConfig
;;;469    		g_tUsart3.ucTxFinish = 1 ;
000050  2001              MOVS     r0,#1
000052  4902              LDR      r1,|L7.92|
000054  7408              STRB     r0,[r1,#0x10]
                  |L7.86|
;;;470    	}
;;;471    }
000056  bd10              POP      {r4,pc}
;;;472    #endif
                          ENDP

                  |L7.88|
                          DCD      0x40004800
                  |L7.92|
                          DCD      g_tUsart3

                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;69     */
;;;70     static void UartVarInit(void)
000000  4813              LDR      r0,|L8.80|
;;;71     {
;;;72     #if USART1_EN == 1
;;;73     	g_tUsart1.pRxBuf = ucRxBuf1;
000002  4914              LDR      r1,|L8.84|
000004  6048              STR      r0,[r1,#4]  ; g_tUsart1
;;;74     	g_tUsart1.usRxSize = UART1_RX_BUF_SIZE;
000006  f44f6080          MOV      r0,#0x400
00000a  8148              STRH     r0,[r1,#0xa]
;;;75     	g_tUsart1.usRxCount = 0;
00000c  2000              MOVS     r0,#0
00000e  81c8              STRH     r0,[r1,#0xe]
;;;76     	g_tUsart1.ucRxFinish = 0;
000010  7448              STRB     r0,[r1,#0x11]
;;;77     	g_tUsart1.ucCnt = 0;
000012  6148              STR      r0,[r1,#0x14]  ; g_tUsart1
;;;78     	
;;;79     	g_tUsart1.pTxBuf = ucTxBuf1;
000014  4810              LDR      r0,|L8.88|
000016  6008              STR      r0,[r1,#0]  ; g_tUsart1
;;;80     	g_tUsart1.usTxSize = UART1_TX_BUF_SIZE;
000018  f44f6080          MOV      r0,#0x400
00001c  8108              STRH     r0,[r1,#8]
;;;81     	g_tUsart1.usTxCount = 0;
00001e  2000              MOVS     r0,#0
000020  8188              STRH     r0,[r1,#0xc]
;;;82     	g_tUsart1.ucTxFinish = 1;
000022  2001              MOVS     r0,#1
000024  7408              STRB     r0,[r1,#0x10]
;;;83     #endif
;;;84     	
;;;85     #if USART3_EN == 1
;;;86     	g_tUsart3.pRxBuf = ucRxBuf3;
000026  480d              LDR      r0,|L8.92|
000028  490d              LDR      r1,|L8.96|
00002a  6048              STR      r0,[r1,#4]  ; g_tUsart3
;;;87     	g_tUsart3.usRxSize = UART3_RX_BUF_SIZE;
00002c  f44f6080          MOV      r0,#0x400
000030  8148              STRH     r0,[r1,#0xa]
;;;88     	g_tUsart3.usRxCount = 0;
000032  2000              MOVS     r0,#0
000034  81c8              STRH     r0,[r1,#0xe]
;;;89     	g_tUsart3.ucRxFinish = 0;
000036  7448              STRB     r0,[r1,#0x11]
;;;90     	g_tUsart3.ucCnt = 0;
000038  6148              STR      r0,[r1,#0x14]  ; g_tUsart3
;;;91     		
;;;92     	g_tUsart3.pTxBuf = ucTxBuf3;
00003a  480a              LDR      r0,|L8.100|
00003c  6008              STR      r0,[r1,#0]  ; g_tUsart3
;;;93     	g_tUsart3.usTxSize = UART3_TX_BUF_SIZE;
00003e  f44f6080          MOV      r0,#0x400
000042  8108              STRH     r0,[r1,#8]
;;;94     	g_tUsart3.usTxCount = 0;
000044  2000              MOVS     r0,#0
000046  8188              STRH     r0,[r1,#0xc]
;;;95     	g_tUsart3.ucTxFinish = 1;
000048  2001              MOVS     r0,#1
00004a  7408              STRB     r0,[r1,#0x10]
;;;96     #endif
;;;97     }
00004c  4770              BX       lr
;;;98     /*
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      ucRxBuf1
                  |L8.84|
                          DCD      g_tUsart1
                  |L8.88|
                          DCD      ucTxBuf1
                  |L8.92|
                          DCD      ucRxBuf3
                  |L8.96|
                          DCD      g_tUsart3
                  |L8.100|
                          DCD      ucTxBuf3

                          AREA ||i.Usart1_SendDMA||, CODE, READONLY, ALIGN=2

                  Usart1_SendDMA PROC
;;;317    #if USART1_EN == 1
;;;318    void Usart1_SendDMA(void)
000000  b500              PUSH     {lr}
;;;319    {
000002  b08f              SUB      sp,sp,#0x3c
;;;320    	DMA_InitTypeDef DMA_InitStructure;
;;;321    	
;;;322    	DMA_DeInit(DMA2_Stream7);                                              			//  将DMA2数据流4ch 4寄存器重设为初始值
000004  481a              LDR      r0,|L9.112|
000006  f7fffffe          BL       DMA_DeInit
;;;323    	DMA_InitStructure.DMA_Channel = DMA_Channel_4 ;                             //	设置DMA通道
00000a  f04f6000          MOV      r0,#0x8000000
00000e  9000              STR      r0,[sp,#0]
;;;324    	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&USART1->DR;            		// 	DMA外设USART1基地址
000010  4818              LDR      r0,|L9.116|
000012  9001              STR      r0,[sp,#4]
;;;325    	DMA_InitStructure.DMA_Memory0BaseAddr = (u32)g_tUsart1.pTxBuf;              // 	定义DMA中内存基地址
000014  4818              LDR      r0,|L9.120|
000016  6800              LDR      r0,[r0,#0]  ; g_tUsart1
000018  9002              STR      r0,[sp,#8]
;;;326    	DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;                     //  定义DMA的方向	
00001a  2040              MOVS     r0,#0x40
00001c  9003              STR      r0,[sp,#0xc]
;;;327    	DMA_InitStructure.DMA_BufferSize = g_tUsart1.usTxCount;                      //  DMA通道的DMA缓存的大小
00001e  4816              LDR      r0,|L9.120|
000020  8980              LDRH     r0,[r0,#0xc]  ; g_tUsart1
000022  9004              STR      r0,[sp,#0x10]
;;;328    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        		//  外设地址寄存器不变
000024  2000              MOVS     r0,#0
000026  9005              STR      r0,[sp,#0x14]
;;;329    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 		//  内存地址寄存器递增
000028  f44f6080          MOV      r0,#0x400
00002c  9006              STR      r0,[sp,#0x18]
;;;330    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; 		//	设置DMA外设数据宽度为8位
00002e  2000              MOVS     r0,#0
000030  9007              STR      r0,[sp,#0x1c]
;;;331    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;        			// 	设置DMA内存数据宽度为8位
000032  9008              STR      r0,[sp,#0x20]
;;;332    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           		// 	工作在正常缓存模式
000034  9009              STR      r0,[sp,#0x24]
;;;333    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                    			// 	DMA通道拥有高优先级
000036  f44f3000          MOV      r0,#0x20000
00003a  900a              STR      r0,[sp,#0x28]
;;;334    	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;											//	指定如果FIFO模式或直接模式将用于指定的流 ： 不使能FIFO模式
00003c  2000              MOVS     r0,#0
00003e  900b              STR      r0,[sp,#0x2c]
;;;335    	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;						//	指定了FIFO阈值水平
000040  2001              MOVS     r0,#1
000042  900c              STR      r0,[sp,#0x30]
;;;336    	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                 //	指定的Burst转移配置内存传输
000044  2000              MOVS     r0,#0
000046  900d              STR      r0,[sp,#0x34]
;;;337    	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;         //	指定的Burst转移配置外围转移
000048  900e              STR      r0,[sp,#0x38]
;;;338    	DMA_Init(DMA2_Stream7, &DMA_InitStructure);                           			// 	根据DMA_InitStruct中指定的参数初始化DMA的通道
00004a  4669              MOV      r1,sp
00004c  4808              LDR      r0,|L9.112|
00004e  f7fffffe          BL       DMA_Init
;;;339    
;;;340    	DMA_Cmd(DMA2_Stream7, ENABLE);	                                     
000052  2101              MOVS     r1,#1
000054  4806              LDR      r0,|L9.112|
000056  f7fffffe          BL       DMA_Cmd
;;;341    	DMA_ITConfig(DMA2_Stream7, DMA_IT_TC, ENABLE);
00005a  2201              MOVS     r2,#1
00005c  2110              MOVS     r1,#0x10
00005e  4804              LDR      r0,|L9.112|
000060  f7fffffe          BL       DMA_ITConfig
;;;342    	g_tUsart1.ucTxFinish = 0;
000064  2000              MOVS     r0,#0
000066  4904              LDR      r1,|L9.120|
000068  7408              STRB     r0,[r1,#0x10]
;;;343    }
00006a  b00f              ADD      sp,sp,#0x3c
00006c  bd00              POP      {pc}
;;;344    #endif
                          ENDP

00006e  0000              DCW      0x0000
                  |L9.112|
                          DCD      0x400264b8
                  |L9.116|
                          DCD      0x40011004
                  |L9.120|
                          DCD      g_tUsart1

                          AREA ||i.Usart3_SendDMA||, CODE, READONLY, ALIGN=2

                  Usart3_SendDMA PROC
;;;353    #if USART3_EN == 1
;;;354    void Usart3_SendDMA(void)
000000  b500              PUSH     {lr}
;;;355    {
000002  b08f              SUB      sp,sp,#0x3c
;;;356    	
;;;357    	DMA_InitTypeDef DMA_InitStructure;
;;;358    	
;;;359    	DMA_DeInit(DMA1_Stream3);                                              			//  将DMA1数据流3ch 4寄存器重设为初始值
000004  481a              LDR      r0,|L10.112|
000006  f7fffffe          BL       DMA_DeInit
;;;360    	DMA_InitStructure.DMA_Channel = DMA_Channel_4 ;                             //	设置DMA通道
00000a  f04f6000          MOV      r0,#0x8000000
00000e  9000              STR      r0,[sp,#0]
;;;361    	DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&USART3->DR;            		// 	DMA外设USART1基地址
000010  4818              LDR      r0,|L10.116|
000012  9001              STR      r0,[sp,#4]
;;;362    	DMA_InitStructure.DMA_Memory0BaseAddr = (u32)g_tUsart3.pTxBuf;              // 	定义DMA中内存基地址
000014  4818              LDR      r0,|L10.120|
000016  6800              LDR      r0,[r0,#0]  ; g_tUsart3
000018  9002              STR      r0,[sp,#8]
;;;363    	DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;                     //  定义DMA的方向	
00001a  2040              MOVS     r0,#0x40
00001c  9003              STR      r0,[sp,#0xc]
;;;364    	DMA_InitStructure.DMA_BufferSize = g_tUsart3.usTxCount;                      //  DMA通道的DMA缓存的大小
00001e  4816              LDR      r0,|L10.120|
000020  8980              LDRH     r0,[r0,#0xc]  ; g_tUsart3
000022  9004              STR      r0,[sp,#0x10]
;;;365    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;        		//  外设地址寄存器不变
000024  2000              MOVS     r0,#0
000026  9005              STR      r0,[sp,#0x14]
;;;366    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 		//  内存地址寄存器递增
000028  f44f6080          MOV      r0,#0x400
00002c  9006              STR      r0,[sp,#0x18]
;;;367    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte; 		//	设置DMA外设数据宽度为8位
00002e  2000              MOVS     r0,#0
000030  9007              STR      r0,[sp,#0x1c]
;;;368    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;        			// 	设置DMA内存数据宽度为8位
000032  9008              STR      r0,[sp,#0x20]
;;;369    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           		// 	工作在正常缓存模式
000034  9009              STR      r0,[sp,#0x24]
;;;370    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                    			// 	DMA通道拥有高优先级
000036  f44f3000          MOV      r0,#0x20000
00003a  900a              STR      r0,[sp,#0x28]
;;;371    	DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;											//	指定如果FIFO模式或直接模式将用于指定的流 ： 不使能FIFO模式
00003c  2000              MOVS     r0,#0
00003e  900b              STR      r0,[sp,#0x2c]
;;;372    	DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;						//	指定了FIFO阈值水平
000040  2001              MOVS     r0,#1
000042  900c              STR      r0,[sp,#0x30]
;;;373    	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;                 //	指定的Burst转移配置内存传输
000044  2000              MOVS     r0,#0
000046  900d              STR      r0,[sp,#0x34]
;;;374    	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;         //	指定的Burst转移配置外围转移
000048  900e              STR      r0,[sp,#0x38]
;;;375    	DMA_Init(DMA1_Stream3, &DMA_InitStructure);                           			// 	根据DMA_InitStruct中指定的参数初始化DMA的通道
00004a  4669              MOV      r1,sp
00004c  4808              LDR      r0,|L10.112|
00004e  f7fffffe          BL       DMA_Init
;;;376    
;;;377    	DMA_Cmd(DMA1_Stream3, ENABLE);	                                     
000052  2101              MOVS     r1,#1
000054  4806              LDR      r0,|L10.112|
000056  f7fffffe          BL       DMA_Cmd
;;;378    	DMA_ITConfig(DMA1_Stream3, DMA_IT_TC, ENABLE);
00005a  2201              MOVS     r2,#1
00005c  2110              MOVS     r1,#0x10
00005e  4804              LDR      r0,|L10.112|
000060  f7fffffe          BL       DMA_ITConfig
;;;379    	g_tUsart3.ucTxFinish = 0;
000064  2000              MOVS     r0,#0
000066  4904              LDR      r1,|L10.120|
000068  7408              STRB     r0,[r1,#0x10]
;;;380    }
00006a  b00f              ADD      sp,sp,#0x3c
00006c  bd00              POP      {pc}
;;;381    #endif
                          ENDP

00006e  0000              DCW      0x0000
                  |L10.112|
                          DCD      0x40026058
                  |L10.116|
                          DCD      0x40004804
                  |L10.120|
                          DCD      g_tUsart3

                          AREA ||i.Usart_Send||, CODE, READONLY, ALIGN=2

                  Usart_Send PROC
;;;284    */
;;;285    void Usart_Send(USART_TypeDef* _USARTx ,const char *_ucaBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;287    #if USART1_EN == 1
;;;288    	if(_USARTx == USART1)
000006  4819              LDR      r0,|L11.108|
000008  4284              CMP      r4,r0
00000a  d115              BNE      |L11.56|
;;;289    	{
;;;290    		while(g_tUsart1.ucTxFinish != 1) ;               														
00000c  bf00              NOP      
                  |L11.14|
00000e  4818              LDR      r0,|L11.112|
000010  7c00              LDRB     r0,[r0,#0x10]  ; g_tUsart1
000012  2801              CMP      r0,#1
000014  d1fb              BNE      |L11.14|
;;;291    		memset(g_tUsart1.pTxBuf,0,g_tUsart1.usTxSize);																
000016  4a16              LDR      r2,|L11.112|
000018  8911              LDRH     r1,[r2,#8]  ; g_tUsart1
00001a  6810              LDR      r0,[r2,#0]  ; g_tUsart1
00001c  f7fffffe          BL       __aeabi_memclr
;;;292        g_tUsart1.usTxCount = strlen(_ucaBuf);                                       
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       strlen
000026  4912              LDR      r1,|L11.112|
000028  8188              STRH     r0,[r1,#0xc]
;;;293    		memcpy(g_tUsart1.pTxBuf,_ucaBuf,g_tUsart1.usTxCount);                      
00002a  898a              LDRH     r2,[r1,#0xc]  ; g_tUsart1
00002c  6808              LDR      r0,[r1,#0]  ; g_tUsart1
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       __aeabi_memcpy
;;;294    		Usart1_SendDMA();		
000034  f7fffffe          BL       Usart1_SendDMA
                  |L11.56|
;;;295    	}
;;;296    #endif
;;;297    	
;;;298    #if USART3_EN == 1
;;;299    	if(_USARTx == USART3)
000038  480e              LDR      r0,|L11.116|
00003a  4284              CMP      r4,r0
00003c  d115              BNE      |L11.106|
;;;300    	{
;;;301    		while(g_tUsart3.ucTxFinish != 1) ;               														
00003e  bf00              NOP      
                  |L11.64|
000040  480d              LDR      r0,|L11.120|
000042  7c00              LDRB     r0,[r0,#0x10]  ; g_tUsart3
000044  2801              CMP      r0,#1
000046  d1fb              BNE      |L11.64|
;;;302    		memset(g_tUsart3.pTxBuf,0,g_tUsart3.usTxSize);																
000048  4a0b              LDR      r2,|L11.120|
00004a  8911              LDRH     r1,[r2,#8]  ; g_tUsart3
00004c  6810              LDR      r0,[r2,#0]  ; g_tUsart3
00004e  f7fffffe          BL       __aeabi_memclr
;;;303        g_tUsart3.usTxCount = strlen(_ucaBuf);                                       
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       strlen
000058  4907              LDR      r1,|L11.120|
00005a  8188              STRH     r0,[r1,#0xc]
;;;304    		memcpy(g_tUsart3.pTxBuf,_ucaBuf,g_tUsart3.usTxCount);                      
00005c  898a              LDRH     r2,[r1,#0xc]  ; g_tUsart3
00005e  6808              LDR      r0,[r1,#0]  ; g_tUsart3
000060  4629              MOV      r1,r5
000062  f7fffffe          BL       __aeabi_memcpy
;;;305    		Usart3_SendDMA();				
000066  f7fffffe          BL       Usart3_SendDMA
                  |L11.106|
;;;306    	}
;;;307    #endif
;;;308    }
00006a  bd70              POP      {r4-r6,pc}
;;;309    /*
                          ENDP

                  |L11.108|
                          DCD      0x40011000
                  |L11.112|
                          DCD      g_tUsart1
                  |L11.116|
                          DCD      0x40004800
                  |L11.120|
                          DCD      g_tUsart3

                          AREA ||i.bsp_InitTIM7||, CODE, READONLY, ALIGN=2

                  bsp_InitTIM7 PROC
;;;252    
;;;253    static void bsp_InitTIM7(uint16_t ARR,uint16_t PSC)
000000  b57f              PUSH     {r0-r6,lr}
;;;254    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;255    		TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;256    		NVIC_InitTypeDef NVIC_InitStructure;
;;;257    	
;;;258    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);           			        // TIM7 clock enable	TIM7使能
000006  2101              MOVS     r1,#1
000008  2020              MOVS     r0,#0x20
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;259    
;;;260    		TIM_TimeBaseStructure.TIM_Period = ARR - 1; 							                  // 设置在下一个更新事件装入活动的自动重装载寄存器周期的值	1ms的定时	 arr：自动重装值   //ARR的值  TIM_Period=SYSCLK(72000 000)/(Prescaler(35)+1)/(ClockDivision)/1000ms
00000e  1e68              SUBS     r0,r5,#1
000010  9002              STR      r0,[sp,#8]
;;;261    		TIM_TimeBaseStructure.TIM_Prescaler = PSC - 1 ; 						                // 设置用来作为TIMx时钟频率除数的预分频值   	psc：时钟预分频数    定时时间计算=(1S/(SYSCLK/(Prescaler+1)))*ARR值         (1S/(72000 000/(36+1)))*1000=0.001S=1ms
000012  1e60              SUBS     r0,r4,#1
000014  b280              UXTH     r0,r0
000016  f8ad0004          STRH     r0,[sp,#4]
;;;262    		TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 				            // 设置时钟分割:TDTS = Tck_tim                                     ARR=定时时间/(1S/(SYSCLK/(Prescaler+1)))  0.001S/(1S/(72000 000/(36+1))) =0.001/0.000 001=1000
00001a  2000              MOVS     r0,#0
00001c  f8ad000c          STRH     r0,[sp,#0xc]
;;;263    		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;                  // TIM向上计数模式
000020  f8ad0006          STRH     r0,[sp,#6]
;;;264    		TIM_TimeBaseStructure.TIM_RepetitionCounter=TIM_PSCReloadMode_Update;    		// TIM 预分频值在更新事件装入,只在TIM1和TIM8中有用
000024  f88d000e          STRB     r0,[sp,#0xe]
;;;265    		TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);							                // 根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000028  a901              ADD      r1,sp,#4
00002a  480f              LDR      r0,|L12.104|
00002c  f7fffffe          BL       TIM_TimeBaseInit
;;;266    		
;;;267    		TIM_ARRPreloadConfig(TIM7, DISABLE);									                      // 禁止ARR预装载缓冲器
000030  2100              MOVS     r1,#0
000032  480d              LDR      r0,|L12.104|
000034  f7fffffe          BL       TIM_ARRPreloadConfig
;;;268    		TIM_ITConfig(TIM7,TIM_IT_Update,ENABLE);								                    // 使能指定的TIM中断(TIMx外设,TIM中断源,TIMx中断的新状态)		 												  
000038  2201              MOVS     r2,#1
00003a  4611              MOV      r1,r2
00003c  480a              LDR      r0,|L12.104|
00003e  f7fffffe          BL       TIM_ITConfig
;;;269    		TIM_Cmd(TIM7, ENABLE);  												                            // 使能TIMx外设	 TIM_TypeDef* TIMx
000042  2101              MOVS     r1,#1
000044  4808              LDR      r0,|L12.104|
000046  f7fffffe          BL       TIM_Cmd
;;;270    
;;;271    		NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;    		         		          // 指定IRQ通道
00004a  2037              MOVS     r0,#0x37
00004c  f88d0000          STRB     r0,[sp,#0]
;;;272    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;   			          // 先占优先级0级
000050  2002              MOVS     r0,#2
000052  f88d0001          STRB     r0,[sp,#1]
;;;273    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;          			          // 从优先级3级
000056  f88d0002          STRB     r0,[sp,#2]
;;;274    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;             			          // IRQ通道被使能
00005a  2001              MOVS     r0,#1
00005c  f88d0003          STRB     r0,[sp,#3]
;;;275    		NVIC_Init(&NVIC_InitStructure);                             			          // 根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
000060  4668              MOV      r0,sp
000062  f7fffffe          BL       NVIC_Init
;;;276    }
000066  bd7f              POP      {r0-r6,pc}
;;;277    /*
                          ENDP

                  |L12.104|
                          DCD      0x40001400

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;51     */
;;;52     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;55     
;;;56     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;57     
;;;58     	ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;59     	
;;;60     	bsp_InitTIM7(CYCLE_TIME,84);
00000e  2154              MOVS     r1,#0x54
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       bsp_InitTIM7
;;;61     }
000016  bd10              POP      {r4,pc}
;;;62     /*
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;536    */
;;;537    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;538    {
000002  4604              MOV      r4,r0
;;;539    	/* 等待串口1输入数据 */
;;;540    	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
000004  bf00              NOP      
                  |L14.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L14.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L14.6|
;;;541    
;;;542    	return (int)USART_ReceiveData(USART1);
000012  4802              LDR      r0,|L14.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;543    }
000018  bd10              POP      {r4,pc}
;;;544    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40011000

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;518    */
;;;519    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;521    	USART_SendData(USART1, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L15.32|
00000a  f7fffffe          BL       USART_SendData
;;;522    
;;;523    	/* 等待发送结束 */
;;;524    	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L15.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L15.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L15.16|
;;;525    	{}
;;;526    	return ch;
00001c  4620              MOV      r0,r4
;;;527    }
00001e  bd70              POP      {r4-r6,pc}
;;;528    
                          ENDP

                  |L15.32|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUsart1
                          %        24
                  ucTxBuf1
                          %        1024
                  ucRxBuf1
                          %        1024
                  g_tUsart3
                          %        24
                  ucTxBuf3
                          %        1024
                  ucRxBuf3
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_usart_c_b28b0d00____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_usart_c_b28b0d00____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_usart_c_b28b0d00____REVSH|
#line 144
|__asm___11_bsp_usart_c_b28b0d00____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
