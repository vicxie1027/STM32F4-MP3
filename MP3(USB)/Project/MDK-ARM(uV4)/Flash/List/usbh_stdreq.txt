; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usbh_stdreq.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usbh_stdreq.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbh_mass_storage -I..\..\User\bsp_stm32f4xx\inc -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --omf_browse=.\flash\obj\usbh_stdreq.crf ..\..\Libraries\STM32_USB_HOST_Library\Core\src\usbh_stdreq.c]
                          THUMB

                          AREA ||i.USBH_ClrFeature||, CODE, READONLY, ALIGN=1

                  USBH_ClrFeature PROC
;;;327    */
;;;328    USBH_Status USBH_ClrFeature(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;329                                USBH_HOST *phost,
;;;330                                uint8_t ep_num, 
;;;331                                uint8_t hc_num) 
;;;332    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;333      
;;;334      phost->Control.setup.b.bmRequestType = USB_H2D | 
00000c  2102              MOVS     r1,#2
00000e  7521              STRB     r1,[r4,#0x14]
;;;335                                             USB_REQ_RECIPIENT_ENDPOINT |
;;;336                                             USB_REQ_TYPE_STANDARD;
;;;337      
;;;338      phost->Control.setup.b.bRequest = USB_REQ_CLEAR_FEATURE;
000010  2101              MOVS     r1,#1
000012  7561              STRB     r1,[r4,#0x15]
;;;339      phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
000014  2100              MOVS     r1,#0
000016  82e1              STRH     r1,[r4,#0x16]
;;;340      phost->Control.setup.b.wIndex.w = ep_num;
000018  8326              STRH     r6,[r4,#0x18]
;;;341      phost->Control.setup.b.wLength.w = 0;           
00001a  8361              STRH     r1,[r4,#0x1a]
;;;342      
;;;343      if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
00001c  f0060080          AND      r0,r6,#0x80
000020  2880              CMP      r0,#0x80
000022  d105              BNE      |L1.48|
;;;344      { /* EP Type is IN */
;;;345        pdev->host.hc[hc_num].toggle_in = 0; 
000024  f505706b          ADD      r0,r5,#0x3ac
000028  eb001047          ADD      r0,r0,r7,LSL #5
00002c  7601              STRB     r1,[r0,#0x18]
00002e  e005              B        |L1.60|
                  |L1.48|
;;;346      }
;;;347      else
;;;348      {/* EP Type is OUT */
;;;349        pdev->host.hc[hc_num].toggle_out = 0; 
000030  2100              MOVS     r1,#0
000032  f505706b          ADD      r0,r5,#0x3ac
000036  eb001047          ADD      r0,r0,r7,LSL #5
00003a  7641              STRB     r1,[r0,#0x19]
                  |L1.60|
;;;350      }
;;;351      
;;;352      return USBH_CtlReq(pdev, phost, 0 , 0 );   
00003c  2300              MOVS     r3,#0
00003e  461a              MOV      r2,r3
000040  4621              MOV      r1,r4
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       USBH_CtlReq
;;;353    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;354    
                          ENDP


                          AREA ||i.USBH_GetDescriptor||, CODE, READONLY, ALIGN=1

                  USBH_GetDescriptor PROC
;;;227    */
;;;228    USBH_Status USBH_GetDescriptor(USB_OTG_CORE_HANDLE *pdev,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;229                                   USBH_HOST           *phost,                                
;;;230                                   uint8_t  req_type,
;;;231                                   uint16_t value_idx, 
;;;232                                   uint8_t* buff, 
;;;233                                   uint16_t length )
;;;234    { 
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
00000c  e9dd9708          LDRD     r9,r7,[sp,#0x20]
;;;235      phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
000010  f0460180          ORR      r1,r6,#0x80
000014  7521              STRB     r1,[r4,#0x14]
;;;236      phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
000016  2106              MOVS     r1,#6
000018  7561              STRB     r1,[r4,#0x15]
;;;237      phost->Control.setup.b.wValue.w = value_idx;
00001a  82e5              STRH     r5,[r4,#0x16]
;;;238      
;;;239      if ((value_idx & 0xff00) == USB_DESC_STRING)
00001c  f405407f          AND      r0,r5,#0xff00
000020  f5b07f40          CMP      r0,#0x300
000024  d103              BNE      |L2.46|
;;;240      {
;;;241        phost->Control.setup.b.wIndex.w = 0x0409;
000026  f2404109          MOV      r1,#0x409
00002a  8321              STRH     r1,[r4,#0x18]
00002c  e001              B        |L2.50|
                  |L2.46|
;;;242      }
;;;243      else
;;;244      {
;;;245        phost->Control.setup.b.wIndex.w = 0;
00002e  2100              MOVS     r1,#0
000030  8321              STRH     r1,[r4,#0x18]
                  |L2.50|
;;;246      }
;;;247      phost->Control.setup.b.wLength.w = length;           
000032  8367              STRH     r7,[r4,#0x1a]
;;;248      return USBH_CtlReq(pdev, phost, buff , length );     
000034  463b              MOV      r3,r7
000036  464a              MOV      r2,r9
000038  4621              MOV      r1,r4
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       USBH_CtlReq
;;;249    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;250    
                          ENDP


                          AREA ||i.USBH_GetNextDesc||, CODE, READONLY, ALIGN=1

                  USBH_GetNextDesc PROC
;;;575    */
;;;576    USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
000000  b510              PUSH     {r4,lr}
;;;577    {
000002  4602              MOV      r2,r0
;;;578      USBH_DescHeader_t  *pnext;
;;;579     
;;;580      *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
000004  880b              LDRH     r3,[r1,#0]
000006  7814              LDRB     r4,[r2,#0]
000008  4423              ADD      r3,r3,r4
00000a  800b              STRH     r3,[r1,#0]
;;;581      pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
00000c  7813              LDRB     r3,[r2,#0]
00000e  1898              ADDS     r0,r3,r2
;;;582             ((USBH_DescHeader_t *)pbuf)->bLength);
;;;583     
;;;584      return(pnext);
;;;585    }
000010  bd10              POP      {r4,pc}
;;;586    
                          ENDP


                          AREA ||i.USBH_Get_CfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_Get_CfgDesc PROC
;;;152    */
;;;153    USBH_Status USBH_Get_CfgDesc(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;154                                 USBH_HOST           *phost,                      
;;;155                                 uint16_t length)
;;;156    
;;;157    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;158      USBH_Status status;
;;;159      uint16_t index = 0;
00000a  2700              MOVS     r7,#0
;;;160      
;;;161      if((status = USBH_GetDescriptor(pdev,
00000c  f5047088          ADD      r0,r4,#0x110
000010  f44f7300          MOV      r3,#0x200
000014  2200              MOVS     r2,#0
000016  4629              MOV      r1,r5
000018  e9cd0600          STRD     r0,r6,[sp,#0]
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       USBH_GetDescriptor
000022  ea5f0800          MOVS     r8,r0
000026  d114              BNE      |L4.82|
;;;162                                      phost,
;;;163                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;164                                      USB_DESC_CONFIGURATION, 
;;;165                                      pdev->host.Rx_Buffer,
;;;166                                      length)) == USBH_OK)
;;;167      {
;;;168        /*save Cfg descriptor for class parsing usage */
;;;169        for( ; index < length ; index ++)
000028  e006              B        |L4.56|
                  |L4.42|
;;;170        {
;;;171          USBH_CfgDesc[index] = pdev->host.Rx_Buffer[index];
00002a  f5047088          ADD      r0,r4,#0x110
00002e  5dc0              LDRB     r0,[r0,r7]
000030  4909              LDR      r1,|L4.88|
000032  55c8              STRB     r0,[r1,r7]
000034  1c78              ADDS     r0,r7,#1              ;169
000036  b287              UXTH     r7,r0                 ;169
                  |L4.56|
000038  42b7              CMP      r7,r6                 ;169
00003a  dbf6              BLT      |L4.42|
;;;172        }
;;;173        
;;;174        /* Commands successfully sent and Response Received  */       
;;;175        USBH_ParseCfgDesc (&phost->device_prop.Cfg_Desc,
00003c  f5047388          ADD      r3,r4,#0x110
000040  f1050250          ADD      r2,r5,#0x50
000044  f105013e          ADD      r1,r5,#0x3e
000048  f1050034          ADD      r0,r5,#0x34
00004c  9600              STR      r6,[sp,#0]
00004e  f7fffffe          BL       USBH_ParseCfgDesc
                  |L4.82|
;;;176                           phost->device_prop.Itf_Desc,
;;;177                           phost->device_prop.Ep_Desc, 
;;;178                           pdev->host.Rx_Buffer,
;;;179                           length); 
;;;180        
;;;181      }
;;;182      return status;
000052  4640              MOV      r0,r8
;;;183    }
000054  e8bd81fc          POP      {r2-r8,pc}
;;;184    
                          ENDP

                  |L4.88|
                          DCD      USBH_CfgDesc

                          AREA ||i.USBH_Get_DevDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_DevDesc PROC
;;;120    */
;;;121    USBH_Status USBH_Get_DevDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;122                                 USBH_HOST *phost,
;;;123                                 uint8_t length)
;;;124    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;125      
;;;126      USBH_Status status;
;;;127      
;;;128      if((status = USBH_GetDescriptor(pdev, 
00000a  f5047088          ADD      r0,r4,#0x110
00000e  f44f7380          MOV      r3,#0x100
000012  2200              MOVS     r2,#0
000014  4629              MOV      r1,r5
000016  e9cd0600          STRD     r0,r6,[sp,#0]
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       USBH_GetDescriptor
000020  0007              MOVS     r7,r0
000022  d106              BNE      |L5.50|
;;;129                                      phost,
;;;130                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                          
;;;131                                      USB_DESC_DEVICE, 
;;;132                                      pdev->host.Rx_Buffer,
;;;133                                      length)) == USBH_OK)
;;;134      {
;;;135        /* Commands successfully sent and Response Received */       
;;;136        USBH_ParseDevDesc(&phost->device_prop.Dev_Desc, pdev->host.Rx_Buffer, length);
000024  4632              MOV      r2,r6
000026  f5047188          ADD      r1,r4,#0x110
00002a  f1050022          ADD      r0,r5,#0x22
00002e  f7fffffe          BL       USBH_ParseDevDesc
                  |L5.50|
;;;137      }
;;;138      return status;      
000032  4638              MOV      r0,r7
;;;139    }
000034  e8bd81fc          POP      {r2-r8,pc}
;;;140    
                          ENDP


                          AREA ||i.USBH_Get_StringDesc||, CODE, READONLY, ALIGN=1

                  USBH_Get_StringDesc PROC
;;;195    */
;;;196    USBH_Status USBH_Get_StringDesc(USB_OTG_CORE_HANDLE *pdev,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;197                                    USBH_HOST *phost,
;;;198                                    uint8_t string_index, 
;;;199                                    uint8_t *buff, 
;;;200                                    uint16_t length)
;;;201    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  9f0a              LDR      r7,[sp,#0x28]
;;;202      USBH_Status status;
;;;203      
;;;204      if((status = USBH_GetDescriptor(pdev,
00000e  f5047088          ADD      r0,r4,#0x110
000012  f4457340          ORR      r3,r5,#0x300
000016  2200              MOVS     r2,#0
000018  4641              MOV      r1,r8
00001a  e9cd0700          STRD     r0,r7,[sp,#0]
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       USBH_GetDescriptor
000024  ea5f0900          MOVS     r9,r0
000028  d105              BNE      |L6.54|
;;;205                                      phost,
;;;206                                      USB_REQ_RECIPIENT_DEVICE | USB_REQ_TYPE_STANDARD,                                    
;;;207                                      USB_DESC_STRING | string_index, 
;;;208                                      pdev->host.Rx_Buffer,
;;;209                                      length)) == USBH_OK)
;;;210      {
;;;211        /* Commands successfully sent and Response Received  */       
;;;212        USBH_ParseStringDesc(pdev->host.Rx_Buffer,buff, length);    
00002a  463a              MOV      r2,r7
00002c  4631              MOV      r1,r6
00002e  f5047088          ADD      r0,r4,#0x110
000032  f7fffffe          BL       USBH_ParseStringDesc
                  |L6.54|
;;;213      }
;;;214      return status;
000036  4648              MOV      r0,r9
;;;215    }
000038  e8bd87fc          POP      {r2-r10,pc}
;;;216    
                          ENDP


                          AREA ||i.USBH_ParseCfgDesc||, CODE, READONLY, ALIGN=2

                  USBH_ParseCfgDesc PROC
;;;397    */
;;;398    static void  USBH_ParseCfgDesc (USBH_CfgDesc_TypeDef* cfg_desc,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;399                                    USBH_InterfaceDesc_TypeDef* itf_desc,
;;;400                                    USBH_EpDesc_TypeDef   ep_desc[][USBH_MAX_NUM_ENDPOINTS], 
;;;401                                    uint8_t *buf, 
;;;402                                    uint16_t length)
;;;403    {  
000004  b085              SUB      sp,sp,#0x14
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  461d              MOV      r5,r3
;;;404      USBH_InterfaceDesc_TypeDef    *pif ;
;;;405      USBH_InterfaceDesc_TypeDef    temp_pif ;  
;;;406      USBH_EpDesc_TypeDef           *pep;  
;;;407      USBH_DescHeader_t             *pdesc = (USBH_DescHeader_t *)buf;
00000e  462c              MOV      r4,r5
;;;408      uint16_t                      ptr;
;;;409      int8_t                        if_ix = 0;
000010  2700              MOVS     r7,#0
;;;410      int8_t                        ep_ix = 0;  
000012  46b8              MOV      r8,r7
;;;411      static uint16_t               prev_ep_size = 0;
;;;412      static uint8_t                prev_itf = 0;  
;;;413      
;;;414      
;;;415      pdesc   = (USBH_DescHeader_t *)buf;
000014  bf00              NOP      
;;;416      
;;;417      /* Parse configuration descriptor */
;;;418      cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
000016  7828              LDRB     r0,[r5,#0]
000018  7030              STRB     r0,[r6,#0]
;;;419      cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
00001a  7868              LDRB     r0,[r5,#1]
00001c  7070              STRB     r0,[r6,#1]
;;;420      cfg_desc->wTotalLength        = LE16 (buf + 2);
00001e  78a9              LDRB     r1,[r5,#2]
000020  78e8              LDRB     r0,[r5,#3]
000022  eb012000          ADD      r0,r1,r0,LSL #8
000026  8070              STRH     r0,[r6,#2]
;;;421      cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
000028  7928              LDRB     r0,[r5,#4]
00002a  7130              STRB     r0,[r6,#4]
;;;422      cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
00002c  7968              LDRB     r0,[r5,#5]
00002e  7170              STRB     r0,[r6,#5]
;;;423      cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
000030  79a8              LDRB     r0,[r5,#6]
000032  71b0              STRB     r0,[r6,#6]
;;;424      cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
000034  79e8              LDRB     r0,[r5,#7]
000036  71f0              STRB     r0,[r6,#7]
;;;425      cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
000038  7a28              LDRB     r0,[r5,#8]
00003a  7230              STRB     r0,[r6,#8]
;;;426      
;;;427      
;;;428      if (length > USB_CONFIGURATION_DESC_SIZE)
00003c  980e              LDR      r0,[sp,#0x38]
00003e  2809              CMP      r0,#9
000040  dd64              BLE      |L7.268|
;;;429      {
;;;430        ptr = USB_LEN_CFG_DESC;
000042  2009              MOVS     r0,#9
000044  9000              STR      r0,[sp,#0]
;;;431        
;;;432        if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
000046  7930              LDRB     r0,[r6,#4]
000048  2802              CMP      r0,#2
00004a  dc5a              BGT      |L7.258|
;;;433        {
;;;434          pif = (USBH_InterfaceDesc_TypeDef *)0;
00004c  46bb              MOV      r11,r7
;;;435          
;;;436          while (ptr < cfg_desc->wTotalLength ) 
00004e  e053              B        |L7.248|
                  |L7.80|
;;;437          {
;;;438            pdesc = USBH_GetNextDesc((uint8_t *)pdesc, &ptr);
000050  4669              MOV      r1,sp
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       USBH_GetNextDesc
000058  4604              MOV      r4,r0
;;;439            if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
00005a  7860              LDRB     r0,[r4,#1]
00005c  2804              CMP      r0,#4
00005e  d14b              BNE      |L7.248|
;;;440            {
;;;441              if_ix             = *(((uint8_t *)pdesc ) + 2);
000060  78a0              LDRB     r0,[r4,#2]
000062  b247              SXTB     r7,r0
;;;442              pif               = &itf_desc[if_ix];
000064  eb0700c7          ADD      r0,r7,r7,LSL #3
000068  eb000b09          ADD      r11,r0,r9
;;;443              
;;;444              if((*((uint8_t *)pdesc + 3)) < 3)
00006c  78e0              LDRB     r0,[r4,#3]
00006e  2803              CMP      r0,#3
000070  da42              BGE      |L7.248|
;;;445              {
;;;446              USBH_ParseInterfaceDesc (&temp_pif, (uint8_t *)pdesc);            
000072  4621              MOV      r1,r4
000074  a802              ADD      r0,sp,#8
000076  f7fffffe          BL       USBH_ParseInterfaceDesc
;;;447              ep_ix = 0;
00007a  f04f0800          MOV      r8,#0
;;;448              
;;;449              /* Parse Ep descriptors relative to the current interface */
;;;450              if(temp_pif.bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
00007e  f89d000c          LDRB     r0,[sp,#0xc]
000082  2802              CMP      r0,#2
000084  dc38              BGT      |L7.248|
;;;451              {          
;;;452                while (ep_ix < temp_pif.bNumEndpoints) 
000086  e032              B        |L7.238|
                  |L7.136|
;;;453                {
;;;454                  pdesc = USBH_GetNextDesc((void* )pdesc, &ptr);
000088  4669              MOV      r1,sp
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       USBH_GetNextDesc
000090  4604              MOV      r4,r0
;;;455                  if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
000092  7860              LDRB     r0,[r4,#1]
000094  2805              CMP      r0,#5
000096  d12a              BNE      |L7.238|
;;;456                  {  
;;;457                    pep               = &ep_desc[if_ix][ep_ix];
000098  eb0a1007          ADD      r0,r10,r7,LSL #4
00009c  eb0000c8          ADD      r0,r0,r8,LSL #3
0000a0  9001              STR      r0,[sp,#4]
;;;458                    
;;;459                    if(prev_itf != if_ix)
0000a2  481c              LDR      r0,|L7.276|
0000a4  7800              LDRB     r0,[r0,#0]  ; prev_itf
0000a6  42b8              CMP      r0,r7
0000a8  d006              BEQ      |L7.184|
;;;460                    {
;;;461                      prev_itf = if_ix;
0000aa  491a              LDR      r1,|L7.276|
0000ac  700f              STRB     r7,[r1,#0]
;;;462                      USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif); 
0000ae  a902              ADD      r1,sp,#8
0000b0  4658              MOV      r0,r11
0000b2  f7fffffe          BL       USBH_ParseInterfaceDesc
0000b6  e00c              B        |L7.210|
                  |L7.184|
;;;463                    }
;;;464                    else
;;;465                    {
;;;466                      if(prev_ep_size > LE16((uint8_t *)pdesc + 4))
0000b8  7921              LDRB     r1,[r4,#4]
0000ba  7960              LDRB     r0,[r4,#5]
0000bc  eb012000          ADD      r0,r1,r0,LSL #8
0000c0  4915              LDR      r1,|L7.280|
0000c2  8809              LDRH     r1,[r1,#0]  ; prev_ep_size
0000c4  4288              CMP      r0,r1
0000c6  da00              BGE      |L7.202|
;;;467                      {
;;;468                        break;
0000c8  e015              B        |L7.246|
                  |L7.202|
;;;469                      }
;;;470                      else
;;;471                      {
;;;472                        USBH_ParseInterfaceDesc (pif, (uint8_t *)&temp_pif);    
0000ca  a902              ADD      r1,sp,#8
0000cc  4658              MOV      r0,r11
0000ce  f7fffffe          BL       USBH_ParseInterfaceDesc
                  |L7.210|
;;;473                      }
;;;474                    }
;;;475                    USBH_ParseEPDesc (pep, (uint8_t *)pdesc);
0000d2  4621              MOV      r1,r4
0000d4  9801              LDR      r0,[sp,#4]
0000d6  f7fffffe          BL       USBH_ParseEPDesc
;;;476                    prev_ep_size = LE16((uint8_t *)pdesc + 4);
0000da  7921              LDRB     r1,[r4,#4]
0000dc  7960              LDRB     r0,[r4,#5]
0000de  eb012000          ADD      r0,r1,r0,LSL #8
0000e2  490d              LDR      r1,|L7.280|
0000e4  8008              STRH     r0,[r1,#0]
;;;477                    ep_ix++;
0000e6  f1080001          ADD      r0,r8,#1
0000ea  fa4ff880          SXTB     r8,r0
                  |L7.238|
0000ee  f89d000c          LDRB     r0,[sp,#0xc]          ;452
0000f2  4540              CMP      r0,r8                 ;452
0000f4  dcc8              BGT      |L7.136|
                  |L7.246|
0000f6  bf00              NOP                            ;468
                  |L7.248|
0000f8  8870              LDRH     r0,[r6,#2]            ;436
0000fa  f8bd1000          LDRH     r1,[sp,#0]            ;436
0000fe  4288              CMP      r0,r1                 ;436
000100  dca6              BGT      |L7.80|
                  |L7.258|
;;;478                  }
;;;479                }
;;;480              }
;;;481             }
;;;482            }
;;;483          }
;;;484        }
;;;485        prev_ep_size = 0;
000102  2000              MOVS     r0,#0
000104  4904              LDR      r1,|L7.280|
000106  8008              STRH     r0,[r1,#0]
;;;486        prev_itf = 0; 
000108  4902              LDR      r1,|L7.276|
00010a  7008              STRB     r0,[r1,#0]
                  |L7.268|
;;;487      }  
;;;488    }
00010c  b005              ADD      sp,sp,#0x14
00010e  e8bd8ff0          POP      {r4-r11,pc}
;;;489    
                          ENDP

000112  0000              DCW      0x0000
                  |L7.276|
                          DCD      prev_itf
                  |L7.280|
                          DCD      prev_ep_size

                          AREA ||i.USBH_ParseDevDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseDevDesc PROC
;;;362    */
;;;363    static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
000000  b510              PUSH     {r4,lr}
;;;364                                    uint8_t *buf, 
;;;365                                    uint16_t length)
;;;366    {
;;;367      dev_desc->bLength            = *(uint8_t  *) (buf +  0);
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
;;;368      dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
000006  784b              LDRB     r3,[r1,#1]
000008  7043              STRB     r3,[r0,#1]
;;;369      dev_desc->bcdUSB             = LE16 (buf +  2);
00000a  788c              LDRB     r4,[r1,#2]
00000c  78cb              LDRB     r3,[r1,#3]
00000e  eb042303          ADD      r3,r4,r3,LSL #8
000012  8043              STRH     r3,[r0,#2]
;;;370      dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
000014  790b              LDRB     r3,[r1,#4]
000016  7103              STRB     r3,[r0,#4]
;;;371      dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
000018  794b              LDRB     r3,[r1,#5]
00001a  7143              STRB     r3,[r0,#5]
;;;372      dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
00001c  798b              LDRB     r3,[r1,#6]
00001e  7183              STRB     r3,[r0,#6]
;;;373      dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
000020  79cb              LDRB     r3,[r1,#7]
000022  71c3              STRB     r3,[r0,#7]
;;;374      
;;;375      if (length > 8)
000024  2a08              CMP      r2,#8
000026  dd16              BLE      |L8.86|
;;;376      { /* For 1st time after device connection, Host may issue only 8 bytes for 
;;;377        Device Descriptor Length  */
;;;378        dev_desc->idVendor           = LE16 (buf +  8);
000028  7a0c              LDRB     r4,[r1,#8]
00002a  7a4b              LDRB     r3,[r1,#9]
00002c  eb042303          ADD      r3,r4,r3,LSL #8
000030  8103              STRH     r3,[r0,#8]
;;;379        dev_desc->idProduct          = LE16 (buf + 10);
000032  7a8c              LDRB     r4,[r1,#0xa]
000034  7acb              LDRB     r3,[r1,#0xb]
000036  eb042303          ADD      r3,r4,r3,LSL #8
00003a  8143              STRH     r3,[r0,#0xa]
;;;380        dev_desc->bcdDevice          = LE16 (buf + 12);
00003c  7b0c              LDRB     r4,[r1,#0xc]
00003e  7b4b              LDRB     r3,[r1,#0xd]
000040  eb042303          ADD      r3,r4,r3,LSL #8
000044  8183              STRH     r3,[r0,#0xc]
;;;381        dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
000046  7b8b              LDRB     r3,[r1,#0xe]
000048  7383              STRB     r3,[r0,#0xe]
;;;382        dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
00004a  7bcb              LDRB     r3,[r1,#0xf]
00004c  73c3              STRB     r3,[r0,#0xf]
;;;383        dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
00004e  7c0b              LDRB     r3,[r1,#0x10]
000050  7403              STRB     r3,[r0,#0x10]
;;;384        dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
000052  7c4b              LDRB     r3,[r1,#0x11]
000054  7443              STRB     r3,[r0,#0x11]
                  |L8.86|
;;;385      }
;;;386    }
000056  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.USBH_ParseEPDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseEPDesc PROC
;;;518    */
;;;519    static void  USBH_ParseEPDesc (USBH_EpDesc_TypeDef  *ep_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;520                                   uint8_t *buf)
;;;521    {
;;;522      
;;;523      ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;524      ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;525      ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;526      ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;527      ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
000010  790b              LDRB     r3,[r1,#4]
000012  794a              LDRB     r2,[r1,#5]
000014  eb032202          ADD      r2,r3,r2,LSL #8
000018  8082              STRH     r2,[r0,#4]
;;;528      ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
00001a  798a              LDRB     r2,[r1,#6]
00001c  7182              STRB     r2,[r0,#6]
;;;529    }
00001e  4770              BX       lr
;;;530    
                          ENDP


                          AREA ||i.USBH_ParseInterfaceDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseInterfaceDesc PROC
;;;497    */
;;;498    static void  USBH_ParseInterfaceDesc (USBH_InterfaceDesc_TypeDef *if_descriptor, 
000000  780a              LDRB     r2,[r1,#0]
;;;499                                          uint8_t *buf)
;;;500    {
;;;501      if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
000002  7002              STRB     r2,[r0,#0]
;;;502      if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
000004  784a              LDRB     r2,[r1,#1]
000006  7042              STRB     r2,[r0,#1]
;;;503      if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
000008  788a              LDRB     r2,[r1,#2]
00000a  7082              STRB     r2,[r0,#2]
;;;504      if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
00000c  78ca              LDRB     r2,[r1,#3]
00000e  70c2              STRB     r2,[r0,#3]
;;;505      if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
000010  790a              LDRB     r2,[r1,#4]
000012  7102              STRB     r2,[r0,#4]
;;;506      if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
000014  794a              LDRB     r2,[r1,#5]
000016  7142              STRB     r2,[r0,#5]
;;;507      if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
000018  798a              LDRB     r2,[r1,#6]
00001a  7182              STRB     r2,[r0,#6]
;;;508      if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
00001c  79ca              LDRB     r2,[r1,#7]
00001e  71c2              STRB     r2,[r0,#7]
;;;509      if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
000020  7a0a              LDRB     r2,[r1,#8]
000022  7202              STRB     r2,[r0,#8]
;;;510    }
000024  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.USBH_ParseStringDesc||, CODE, READONLY, ALIGN=1

                  USBH_ParseStringDesc PROC
;;;538    */
;;;539    static void USBH_ParseStringDesc (uint8_t* psrc, 
000000  b530              PUSH     {r4,r5,lr}
;;;540                                      uint8_t* pdest, 
;;;541                                      uint16_t length)
;;;542    {
000002  4613              MOV      r3,r2
;;;543      uint16_t strlength;
;;;544      uint16_t idx;
;;;545      
;;;546      /* The UNICODE string descriptor is not NULL-terminated. The string length is
;;;547      computed by substracting two from the value of the first byte of the descriptor.
;;;548      */
;;;549      
;;;550      /* Check which is lower size, the Size of string or the length of bytes read 
;;;551      from the device */
;;;552      
;;;553      if ( psrc[1] == USB_DESC_TYPE_STRING)
000004  7845              LDRB     r5,[r0,#1]
000006  2d03              CMP      r5,#3
000008  d114              BNE      |L11.52|
;;;554      { /* Make sure the Descriptor is String Type */
;;;555        
;;;556        /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
;;;557        strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
00000a  7805              LDRB     r5,[r0,#0]
00000c  1ead              SUBS     r5,r5,#2
00000e  429d              CMP      r5,r3
000010  dc02              BGT      |L11.24|
000012  7805              LDRB     r5,[r0,#0]
000014  1ead              SUBS     r5,r5,#2
000016  e000              B        |L11.26|
                  |L11.24|
000018  461d              MOV      r5,r3
                  |L11.26|
00001a  b2ac              UXTH     r4,r5
;;;558        psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
00001c  1c80              ADDS     r0,r0,#2
;;;559        
;;;560        for (idx = 0; idx < strlength; idx+=2 )
00001e  2200              MOVS     r2,#0
000020  e004              B        |L11.44|
                  |L11.34|
;;;561        {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
;;;562          *pdest =  psrc[idx];
000022  5c85              LDRB     r5,[r0,r2]
000024  700d              STRB     r5,[r1,#0]
;;;563          pdest++;
000026  1c49              ADDS     r1,r1,#1
000028  1c95              ADDS     r5,r2,#2              ;560
00002a  b2aa              UXTH     r2,r5                 ;560
                  |L11.44|
00002c  42a2              CMP      r2,r4                 ;560
00002e  dbf8              BLT      |L11.34|
;;;564        }  
;;;565        *pdest = 0; /* mark end of string */  
000030  2500              MOVS     r5,#0
000032  700d              STRB     r5,[r1,#0]
                  |L11.52|
;;;566      }
;;;567    }
000034  bd30              POP      {r4,r5,pc}
;;;568    
                          ENDP


                          AREA ||i.USBH_SetAddress||, CODE, READONLY, ALIGN=1

                  USBH_SetAddress PROC
;;;257    */
;;;258    USBH_Status USBH_SetAddress(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;259                                USBH_HOST *phost,
;;;260                                uint8_t DeviceAddress)
;;;261    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;262      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
000008  2100              MOVS     r1,#0
00000a  7521              STRB     r1,[r4,#0x14]
;;;263        USB_REQ_TYPE_STANDARD;
;;;264      
;;;265      phost->Control.setup.b.bRequest = USB_REQ_SET_ADDRESS;
00000c  2105              MOVS     r1,#5
00000e  7561              STRB     r1,[r4,#0x15]
;;;266      
;;;267      phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
000010  82e5              STRH     r5,[r4,#0x16]
;;;268      phost->Control.setup.b.wIndex.w = 0;
000012  2100              MOVS     r1,#0
000014  8321              STRH     r1,[r4,#0x18]
;;;269      phost->Control.setup.b.wLength.w = 0;
000016  8361              STRH     r1,[r4,#0x1a]
;;;270      
;;;271      return USBH_CtlReq(pdev, phost, 0 , 0 );
000018  2300              MOVS     r3,#0
00001a  461a              MOV      r2,r3
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       USBH_CtlReq
;;;272    }
000024  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP


                          AREA ||i.USBH_SetCfg||, CODE, READONLY, ALIGN=1

                  USBH_SetCfg PROC
;;;280    */
;;;281    USBH_Status USBH_SetCfg(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;282                            USBH_HOST *phost,
;;;283                            uint16_t cfg_idx)
;;;284    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;285      
;;;286      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
000008  2100              MOVS     r1,#0
00000a  7521              STRB     r1,[r4,#0x14]
;;;287        USB_REQ_TYPE_STANDARD;
;;;288      phost->Control.setup.b.bRequest = USB_REQ_SET_CONFIGURATION;
00000c  2109              MOVS     r1,#9
00000e  7561              STRB     r1,[r4,#0x15]
;;;289      phost->Control.setup.b.wValue.w = cfg_idx;
000010  82e5              STRH     r5,[r4,#0x16]
;;;290      phost->Control.setup.b.wIndex.w = 0;
000012  2100              MOVS     r1,#0
000014  8321              STRH     r1,[r4,#0x18]
;;;291      phost->Control.setup.b.wLength.w = 0;           
000016  8361              STRH     r1,[r4,#0x1a]
;;;292      
;;;293      return USBH_CtlReq(pdev, phost, 0 , 0 );      
000018  2300              MOVS     r3,#0
00001a  461a              MOV      r2,r3
00001c  4621              MOV      r1,r4
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       USBH_CtlReq
;;;294    }
000024  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP


                          AREA ||i.USBH_SetInterface||, CODE, READONLY, ALIGN=1

                  USBH_SetInterface PROC
;;;302    */
;;;303    USBH_Status USBH_SetInterface(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;304                            USBH_HOST *phost,
;;;305                            uint8_t ep_num, uint8_t altSetting)
;;;306    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;307      
;;;308      
;;;309      phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_INTERFACE | \
00000c  2101              MOVS     r1,#1
00000e  7521              STRB     r1,[r4,#0x14]
;;;310        USB_REQ_TYPE_STANDARD;
;;;311      
;;;312      phost->Control.setup.b.bRequest = USB_REQ_SET_INTERFACE;
000010  210b              MOVS     r1,#0xb
000012  7561              STRB     r1,[r4,#0x15]
;;;313      phost->Control.setup.b.wValue.w = altSetting;
000014  82e6              STRH     r6,[r4,#0x16]
;;;314      phost->Control.setup.b.wIndex.w = ep_num;
000016  8325              STRH     r5,[r4,#0x18]
;;;315      phost->Control.setup.b.wLength.w = 0;           
000018  2100              MOVS     r1,#0
00001a  8361              STRH     r1,[r4,#0x1a]
;;;316     
;;;317      return USBH_CtlReq(pdev, phost, 0 , 0 );     
00001c  2300              MOVS     r3,#0
00001e  461a              MOV      r2,r3
000020  4621              MOV      r1,r4
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       USBH_CtlReq
;;;318    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;319    /**
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USBH_CfgDesc
                          %        512

                          AREA ||.data||, DATA, ALIGN=1

                  prev_ep_size
000000  0000              DCW      0x0000
                  prev_itf
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_HOST_Library\\Core\\src\\usbh_stdreq.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_usbh_stdreq_c_3531d2fa____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_usbh_stdreq_c_3531d2fa____REVSH|
#line 144
|__asm___13_usbh_stdreq_c_3531d2fa____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
